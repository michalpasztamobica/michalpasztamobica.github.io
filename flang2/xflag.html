
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Other Compiler Switches &#8212; Flang 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Cross Reference" href="xref.html" />
    <link rel="prev" title="Maintenance Info" href="fin.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Flang 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Other Compiler Switches</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="fin.html">Maintenance Info</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="xref.html">Cross Reference</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="other-compiler-switches">
<h1>Other Compiler Switches<a class="headerlink" href="#other-compiler-switches" title="Permalink to this headline">¶</a></h1>
<p><em>-x Compiler Switches</em></p>
<p>The compilers have a number of supported and unsupported switches
that are used internal to the compilers.
These are referred to as
<strong>xflags</strong>.
This section documents the xflags.</p>
<p>These xflags can be invoked in two ways.</p>
<ol class="arabic simple">
<li>Use
<code class="docutils literal notranslate"><span class="pre">-x</span></code>
<em>&lt;number&gt; &lt;value&gt;</em>
where
<em>&lt;number&gt;</em>
is a decimal number and ranges from 0 to 127.
For example, to turn on information generation during compilation use:
<code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">0</span> <span class="pre">2</span></code>.</li>
<li>The compiler may use symbolic names to map to certain xflags.
For example, the
<code class="docutils literal notranslate"><span class="pre">-alpha</span></code>
switch is identical to using
<code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">25</span> <span class="pre">15</span></code>
and
<code class="docutils literal notranslate"><span class="pre">-beta</span></code>
is identical to using
<code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">25</span> <span class="pre">240</span></code>.</li>
</ol>
<p>The first number in an xflag invocation is an array index into the array
<code class="docutils literal notranslate"><span class="pre">flg.x[128]</span></code>.
The second number is used to mask the value from that array.
This sets up the xflag switches to be easily used as bit masks.
The macro,
<code class="docutils literal notranslate"><span class="pre">XBIT(n,m)</span></code>,
should be used to test an xflag where
<code class="docutils literal notranslate"><span class="pre">n</span></code>
is the xflag number and
<code class="docutils literal notranslate"><span class="pre">m</span></code>
is the mask.</p>
<p>The following is a brief summary of the reserved xflags.  Note that
not all are implemented.</p>
<p>flg.x[] - Values and Meanings</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">0:</span></code></dt>
<dd><p class="first">Used to turn on information reporting regarding compiler (stderr):</p>
<p><strong>0x01:</strong>
compilation statistics</p>
<p><strong>0x02:</strong>
general information on loops</p>
<p><strong>0x04:</strong>
(pgc dev only) - prototypes for function definitons</p>
<p><strong>0x08:</strong>
inlining information (TBD)</p>
<p><strong>0x10:</strong>
code block sizes in cycles</p>
<p><strong>0x20:</strong>
put symbol comments into assembly file</p>
<p><strong>0x40:</strong>
put verbose comments into assembly file (includes ili)</p>
<p><strong>0x80:</strong>
put misc info out to stderr</p>
<p><strong>0x100:</strong>
OpenMp information.</p>
<p><strong>0x200:</strong>
Variable information within parallel regions.</p>
<p><strong>0x400:</strong>
Integrate info messages with source code and save to a .info file</p>
<p><strong>0x800:</strong>
Info on data flow optimizations (e.g. CSE, PRE, hoisting)</p>
<p><strong>0x1000:</strong>
issue variable use before def warning messages.</p>
<p><strong>0x2000:</strong>
for ST100, override default and put command line into assembly file</p>
<p><strong>0x4000:</strong>
Compute / Data Intensity output</p>
<p><strong>0x8000:</strong>
issue unrecognized pragma/directive messages (development/DEBUG
versions only)</p>
<p><strong>0x10000:</strong>
Info on control flow optimizations (e.g. predication)</p>
<p><strong>0x20000:</strong>
describe when loops can be parallelized</p>
<p><strong>0x40000:</strong>
describe vector streaming calls</p>
<p><strong>0x80000:</strong>
produce negative loop information</p>
<p><strong>0x100000:</strong>
describe when barriers are deleted</p>
<p><strong>0x200000:</strong>
minfo messages for IPA optimizations</p>
<p><strong>0x400000:</strong>
minfo messages for Unified Binary optimizations</p>
<p><strong>0x800000:</strong>
minfo messages for -Mautoinline</p>
<p><strong>0x1000000:</strong>
don’t demangle C++ function names in minfo messages</p>
<p><strong>0x2000000:</strong>
Output CCFF to STDERR</p>
<p><strong>0x4000000:</strong>
Use CCFF messages</p>
<p><strong>0x8000000:</strong>
Output minfo/CCFF to stderr when lowering (pgf901)</p>
<p><strong>0x20000000:</strong>
Don’t emit error message text for select error messages.</p>
<p><strong>0x40000000:</strong>
Error messages in dev studio format:</p>
<div class="line-block">
<div class="line">block1 : block2 : block3</div>
<div class="line">block1 : block3</div>
<div class="line">block1 contains &lt;filename&gt;(line number); block2 contains either</div>
<div class="line">error or warning; block3 contains message text.</div>
</div>
<p>In addition, the line number in block1 can also include the column
number, &lt;filename&gt;(n,m). In all cases the line number is required.</p>
<p class="last"><strong>0x80000000:</strong>
L-suffixed constants (dev pgc only).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">1:</span></code></dt>
<dd><p class="first">Used to turn on producing negative and other information (stderr):</p>
<p><strong>0x01:</strong>
Enable enhanced error messages.</p>
<p><strong>0x02:</strong>
general information on loop optimizations not performed</p>
<p><strong>0x04:</strong>
For ST100, describe when (and why) dsp intrinsics are NOT expanded.</p>
<p><strong>0x08:</strong>
For IPA negative information.</p>
<p><strong>0x10:</strong>
For inliner failures</p>
<p><strong>0x800:</strong>
Give failure information on data-flow optimizations (e.g. CSE, PRE, hoisting).</p>
<p><strong>0x10000:</strong>
Give failure information on control-flow optimizations (e.g. predication).</p>
<p><strong>0x20000:</strong>
describe when loops can not be parallelized</p>
<p><strong>0x40000:</strong>
For PFO.</p>
<p class="last"><strong>0x80000:</strong>
For PRE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">2:</span></code></dt>
<dd><p class="first">Used to turn on various non-standard optimizations
Note that combinations can be used to get a desired effect.</p>
<p><strong>0x01:</strong>
C dummy args are treated with the same copyin/copyout semantics
as Fortran dummy args.</p>
<p><strong>0x02:</strong>
C local ptrs do not conflict with any other local variables.</p>
<p><strong>0x04:</strong>
C static ptrs do not conflict with any other static variables.</p>
<p><strong>0x08:</strong>
C global ptrs do not conflict with any other global variables.</p>
<p><strong>0x10:</strong>
C malloc ptrs do not conflict with any other variables.</p>
<p><strong>0x20:</strong>
C struct ptrs do not conflict with other struct ptrs of the same
type unless they are either the same structure or the same field.
In other words, ptrs to structures are not skewed.</p>
<p><strong>0x80:</strong>
Relax dependence checking for unknown dependence relations.</p>
<p><strong>0x100:</strong>
C private ptrs do not conflict with any other private variables.</p>
<p><strong>0x200</strong>
In dependence testing, assume 0/x and x/x are 0 and 1, even when
x is an unknown nonconstant value.</p>
<p><strong>0x400</strong>
Turn off ANSI C pointer rules:
ANSI C pointer rules are implemented in  dependence testing and alias analysis,
it assumes that a pointer to type A cannot conflict with pointer to type B.</p>
<p><strong>0x800</strong>
Disable checking if a member reference is derived from a pointer dereference.</p>
<p><strong>0x1000</strong>
Compile (keep) C/C++ static functions that are never called and
whose addresses are never taken</p>
<p><strong>0x2000</strong>
For x86-64 extended asm, do not consider PDALNG field on pointer input/output
item. Otherwise, look at PDALNG field to see if it’s 16-byte aligned. If so,
we can generate movapd for the input/output item.</p>
<p><strong>0x4000</strong>
Set ADDRTKNP bit for C/C++ structure moves,</p>
<p><strong>0x8000</strong>
AVAILABLE (Was “safer interpretation of -Msafeptr”)</p>
<p><strong>0x10000</strong>
C++ class type-based disambiguation rule.  Different class types do not conflict.
Class objects do not conflict with their pointers.</p>
<p><strong>0x20000</strong>
Do not generate members NMEs for union members (just elide the member).</p>
<p><strong>0x40000</strong>
Do not mangle members name with line number information: so that IPA inlining
can match class types.</p>
<p><strong>0x100000</strong>
Fill in BIH_LINENO with line numbers on inlined blocks.</p>
<p><strong>0x200000</strong>
don’t use SMOVEI/SMOVES instead of SMOVE in exp_rte.c</p>
<p><strong>0x400000</strong>
F90 pointer optimizations.</p>
<p><strong>0x800000</strong>
Use GSMOVE in exp_rte.c</p>
<p class="last"><strong>0x1000000</strong>
Don’t expand SMOVEs (struct moves) in a single IL_SMOVEI/IL_SMOVES</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">3:</span></code></dt>
<dd><p class="first">Used to turn on/off various dual-op/dual-inst/pipelined ops.</p>
<p><strong>0x01:</strong>
turn on pipelined operations</p>
<p><strong>0x02:</strong>
turn on dual-instructions</p>
<p><strong>0x04:</strong>
turn off pipelined operations</p>
<p><strong>0x08:</strong>
turn off dual-instructions on i860 or swpipe on ST100</p>
<p><strong>0x10:</strong>
block level heuristics for above (default is file level)</p>
<p><strong>0x20:</strong>
loop level heuristics for above (dual mod if 1 column loop)</p>
<p><strong>0x40:</strong>
multi-block loop level heuristics for above</p>
<p><strong>0x80:</strong>
function level heuristics for above</p>
<p><strong>0x100:</strong>
Use pipelined moves instead of static dp moves.</p>
<p><strong>0x200:</strong>
For LLVM, use ymm registers on x86 to perform LRE</p>
<p class="last"><strong>0x400:</strong>
Don’t perform reduction compression</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">4:</span></code></dt>
<dd><p class="first">Used to alter optimization/code generation techniques.</p>
<p><strong>0x01:</strong>
Use pipelined operations</p>
<p><strong>0x02:</strong>
Use dual-instruction mode</p>
<p><strong>0x04:</strong>
Enable multiple fp registers to be cached (used on the x86)</p>
<p><strong>0x08:</strong>
used in cgsched.c</p>
<p><strong>0x10:</strong>
used in cgsched.c</p>
<p><strong>0x20:</strong>
used in cgsched.c</p>
<p><strong>0x40:</strong>
used in cgsched.c</p>
<p><strong>0x80:</strong>
used in cgsched.c</p>
<p><strong>0x1000</strong>
Generate a null pointer store fault.</p>
<p><strong>0x2000</strong>
Generate a divide by zero fault.</p>
<p><strong>0x4000</strong>
Generate the above or below fault on the third function, not the first.</p>
<p><strong>0x8000</strong>
Generate an infinite loop fault</p>
<p><strong>0x100000</strong>
In Fortran front end, disable any dependence checking, and assume no forall
or array assignment needs a temp.</p>
<p><strong>0x200000</strong>
In Fortran front end, disable early flow analysis to determine if the forall
or array assignment needs a temp.</p>
<p><strong>0x400000</strong>
In Fortran front end, disable kernels rescoping.</p>
<p class="last"><strong>0x800000</strong>
Initialization of an array with zeros can sometimes be done directly with
machine instructions, rather than a loop nest (array assignment collapsing).
Disable array assignment collapsing optimization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">5:</span></code></dt>
<dd><p class="first">CG uses</p>
<p><strong>0x01:</strong>
Ignore deletable store information.
Hammer - disable register allocation at -O0.</p>
<p><strong>0x02:</strong>
Perform hardcoded register allocation in CG</p>
<p><strong>0x04:</strong>
used in cgsched.c</p>
<p><strong>0x08:</strong>
used in cgsched.c</p>
<p><strong>0x10:</strong>
used in cgsched.c</p>
<p><strong>0x20:</strong>
used in cgsched.c</p>
<p><strong>0x40:</strong>
used in cgsched.c</p>
<p class="last"><strong>0x80:</strong>
used in cgsched.c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">6:</span></code></dt>
<dd><p class="first">Inhibit optimizations</p>
<p><strong>0x01:</strong>
global constant propagation (opt &gt;= 2)</p>
<p><strong>0x02:</strong>
store deletion due to constant propagation (opt &gt;= 2)</p>
<p><strong>0x04:</strong>
copy LOOP ili (bla instruction) (opt &gt;= 2)</p>
<p><strong>0x08:</strong>
br_to_br (opt &gt;= 2)</p>
<p><strong>0x10</strong>
remove useless register moves (opt &gt;= 2)</p>
<p><strong>0x20</strong>
loop live variable checks (opt &gt;= 2)</p>
<p><strong>0x40</strong>
replacement of data initialized local fortran variables or
data initialized const C variables (opt &gt;= 2)</p>
<p><strong>0x80</strong>
using function return registers for global register assignments (opt &gt;= 1,
and only when function returns a value)</p>
<p><strong>0x100</strong>
copy propagation where value already loaded; floating point constant
propagation.</p>
<p><strong>0x200</strong>
prevent copy propagation of values with any floating point compare (x86)</p>
<p><strong>0x400</strong>
inhibit optimization to replace divide-by-constant by multiplication</p>
<p><strong>0x800</strong>
inhibit floating point constant prop. (like 0x100), but this still allows
floating point global regs.</p>
<p><strong>0x1000</strong>
inhibit multiply-accumulate/subtract optimization (e.g. x += a * b).</p>
<p><strong>0x2000</strong>
inhibit remove_jump() optimization</p>
<p><strong>0x4000</strong>
store deletion within an extended basic block.</p>
<p><strong>0x8000</strong>
SAVE (SC_STATIC) removal (invarif.c:save_elim(), fortran-only).</p>
<p><strong>0x10000</strong>
inhibit optimizations based on the LSCOPE f90 symbol table flag.</p>
<p><strong>0x20000</strong>
inhibit optimizations of ‘pure’ functions.</p>
<p><strong>0x40000</strong>
Inhibit block splitting at inline points in expander followed by
block unsplitting call in main.</p>
<p><strong>0x80000</strong>
Inhibit ‘equals’ propagation.</p>
<p><strong>0x100000</strong>
TEMPORARY – topsort the loops</p>
<p><strong>0x200000</strong>
don’t defer compilation of routines based on whether they are called</p>
<p><strong>0x400000</strong>
don’t remove unreachable blocks in fgraph</p>
<p><strong>0x20000000</strong>
Do max/min pattern, but inhibit all other transformations.</p>
<p><strong>0x40000000</strong>
TEMPORARY – don’t check address of threadprivate variables in recog;
Q&amp;D QA to work-around regressions.</p>
<p class="last"><strong>0x80000000</strong>
perform analysis only: inhibit all transformations when
building the flowgraph, discovering loops, and building the flow
information.
Generally, the transformations should not occur when the cg
is calling the optimizer’s functions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">7:</span></code></dt>
<dd><p class="first">Inhibit optimizations</p>
<p><strong>0x01:</strong>
non-constant def copy (opt &gt;= 2)</p>
<p><strong>0x02:</strong>
terminal function optimization (opt &gt;= 1)</p>
<p><strong>0x04:</strong>
a = a (opt &gt;= 2)</p>
<p><strong>0x08:</strong>
separate base pointers (opt &gt;= 3)</p>
<p><strong>0x10:</strong>
glue arg copy (opt &gt;= 2)</p>
<p><strong>0x20:</strong>
non-glue arg copy (opt &gt;= 2)</p>
<p><strong>0x40:</strong>
use scratch as globals if calls present</p>
<p><strong>0x80:</strong>
copy arg/glue if loops present</p>
<p><strong>0x100:</strong>
member store is within its boundaries
(doesn’t mark parent structure as ‘stored’).</p>
<p><strong>0x200:</strong>
invariant hoisting of the LPSTRT &amp; LDLPCT ili (ST100, opt &gt;= 2).</p>
<p><strong>0x400:</strong>
hoisting of the LPSTRT &amp; LDLPCT ili if there exists a call in the
preheader block to which the ili are hoisted (ST100, opt &gt;= 2).</p>
<p><strong>0x800:</strong>
Disable use of scratch as globals in terminal (leaf) functions.</p>
<p><strong>0x1000:</strong>
Inhibit global sign-extension elimination.</p>
<p><strong>0x2000:</strong>
For ST1xx, disable the `HRA16’ (`Holes Register Allocator for GP16’)
GP16 register allocator enhancements.</p>
<p><strong>0x4000:</strong>
Inhibit setting the XMMSAFE flag for functions.</p>
<p><strong>0x8000:</strong>
Enable scalar replacement.</p>
<p><strong>0x10000:</strong>
Enable transitive loop invariant motion.</p>
<p><strong>0x20000:</strong>
Stress transitive loop invariant motion, i.e., disable heuristics to control register pressure.</p>
<p><strong>0x40000:</strong>
Enable class/struct based mod/div replacement by reciprical code emit.
There were problems with this, so we’ve inverted the flag.</p>
<p><strong>0x80000:</strong>
Disable invariant searching of ILI_ALT.</p>
<p><strong>0x100000:</strong>
Disable replacement of data initialized local fortran scalar variables with
assignment statement (opt &gt;= 2)</p>
<p><strong>0x200000:</strong>
Disable optimization where we set GSCOPE on Fortran host subprogram declared symbols only when they are used in a contains subprogram.</p>
<p><strong>0x400000:</strong>
Disable dissociation of local C/C++ struct/class instance members,
an optimization for the modern STL iterator implementation to get
sole members into registers.</p>
<p><strong>0x800000:</strong>
Disable clearing the “address taken” flag on local symbols whose
addresses are taken only in normal load/store sequences.</p>
<p><strong>0x1000000:</strong>
Disable more aggressive expression rewriting with store forwarding to loads.</p>
<p><strong>0x2000000:</strong>
Disable NME rewriting to clean up after constant propagation.</p>
<p><strong>0x4000000:</strong>
Don’t return fast from forward() if other xflags have disabled everything.</p>
<p><strong>0x8000000:</strong>
Disable interval analysis in hlscrub.c.</p>
<p><strong>0x10000000:</strong>
Disable block duplication in hlscrub.c.</p>
<p><strong>0x20000000:</strong>
Disable dead code elimination in hlscrub.c.</p>
<p><strong>0x40000000:</strong>
Disable conversion of pointer inequality loop tests in hlscrub.c.</p>
<p class="last"><strong>0x80000000:</strong>
Disable CSE replacements in hlscrub.c.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">8:</span></code></dt>
<dd><p class="first">Inhibit optimizations</p>
<p><strong>0x01:</strong>
loop count (opt &gt;= 2)</p>
<p><strong>0x02:</strong>
store deletion (opt &gt;= 2)</p>
<p><strong>0x04:</strong>
block merging (opt &gt;= 2)</p>
<p><strong>0x08:</strong>
global register assignment (opt &gt;= 1)
(also disables loop count)</p>
<p><strong>0x10:</strong>
recurrence relations (opt &gt;= 3)</p>
<p><strong>0x20:</strong>
invariant array addresses (opt &gt;= 3)</p>
<p><strong>0x40:</strong>
last value computations (opt &gt;= 2)</p>
<p><strong>0x80:</strong>
loop count if non-induction use occurs (opt &gt;= 2)</p>
<p><strong>0x100:</strong>
replace not-equal test of loop control variable with less than or
greater than test (opt &gt;= 2)</p>
<p><strong>0x200:</strong>
reducing the number of induction variables (opt &gt;= 2)</p>
<p><strong>0x400</strong>
global register allocation (opt &gt;=2) using live ranges (both
integer and floating point globals)</p>
<p><strong>0x800</strong>
allow fp caching in x86 if not innermost loop</p>
<p><strong>0x1000</strong>
turn off fp caching in x86</p>
<p><strong>0x2000:</strong>
recognizer.</p>
<p><strong>0x4000:</strong>
finding common base pointers.</p>
<p><strong>0x8000:</strong>
ignoring a short/char extend when searching for basic induction
variables.</p>
<p><strong>0x10000:</strong>
searching for stores via the same pointer (invar.c) when the
pointer is ‘safe’.</p>
<p><strong>0x20000:</strong>
allowing QJSRs as candidates for invariancy (ST100) – should always
be safe but there may be regarg problems introduced by hoisting QJRs.</p>
<p><strong>0x40000:</strong>
When finding a common base pointer (recog.c), select the use whose
linear reference has offset 0.</p>
<p><strong>0x80000:</strong>
hw looping.</p>
<p><strong>0x100000:</strong>
allocating hw loop registers with respect to the total number of
loops in a loop nest; if XBIT is set, allocate hw loop registers
with respect to the ‘level’ of a loop, i.e., inner-to-outer.</p>
<p><strong>0x200000:</strong>
hw looping for ‘while’ loops.</p>
<p><strong>0x400000:</strong>
hw looping for loops containing calls.</p>
<p><strong>0x800000:</strong>
Inhibit use of H/W loop reload registers (ST1xx)</p>
<p><strong>0x1000000:</strong>
Inhibit signextend elimination (ST1xx)</p>
<p><strong>0x2000000:</strong>
Inhibit detecting PTRSAFE members and POINTER members in invar (PGF90)</p>
<p><strong>0x4000000:</strong>
Inhibit recognition of loops with constant loop count of 1</p>
<p><strong>0x8000000:</strong>
Inhibit hlinduc0:memset/memzero/memcopy idiom recognition.</p>
<p><strong>0x10000000:</strong>
Inhibit hlinduc0:memcopy idiom recognition</p>
<p><strong>0x20000000:</strong>
Disable inhibiting strength reduction for address-mode expressions</p>
<p><strong>0x40000000:</strong>
reserved</p>
<p class="last"><strong>0x80000000:</strong>
inhibit iltutil.c:merge_bih() - WARNING: in certain cases, merging must
occur to complete an optimization, e.g. br_flatten().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">9:</span></code></dt>
<dd>Non-zero value invokes the loop unroller.
If value is other than 1, represents the number of times to unroll loops
or the maximum iteration count if completely unrolling a loop.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">10:</span></code></dt>
<dd>Number of unrolls (# of loop bodies) of a loop with non-constant
iteration count.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">11:</span></code></dt>
<dd><p class="first">Unrolling</p>
<p><strong>0x01:</strong>
Enable completely unrolling a loop when the UNROLL directive is used.</p>
<p><strong>0x02:</strong>
Enable unrolling a loop by a factor specified via the UNROLL(n) directive.</p>
<p><strong>0x04:</strong>
(I386,X86_64) Ignore the check of the number of variable
strides.</p>
<p><strong>0x08:</strong>
Inhibit completely unrolling outer loops.</p>
<p><strong>0x10:</strong>
(I386,X86_64) Don’t reduce the scoring by a factor of two
when there are only variable strides.</p>
<p><strong>0x20:</strong>
(I386,X86_64) Ignore the check of the number of variable
strides when attempting to completely unroll a loop.</p>
<p><strong>0x40:</strong>
(I386,X86_64) Ignore the check of the number of nested
invariant array references when attempting to completely unroll a loop.</p>
<p><strong>0x80:</strong>
(I386,X86_64) Ignore the check of the number of variable
strides from an innerloop when attempting to completely unroll its
containing (outer) loop.</p>
<p><strong>0x100:</strong>
(I386,X86_64) Ignore the check of the number of nested invariant array
references from an innerloop when attempting to completely unroll its
containing (outer) loop.</p>
<p><strong>0x200:</strong>
Enable unrolling of multi-block loops.
The unroll count is initially default 4 or flg.x[10] if that is set.</p>
<p><strong>0x400:</strong>
Disable unrolling of a loop marked with the NOUNROLL directive.</p>
<p class="last"><strong>0x800:</strong>
Do not attempt to increase the threshold for completely unrolling
an innermost multi-block loops.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">12:</span></code></dt>
<dd><p class="first">Inhibit local optimizations</p>
<p><strong>0x01:</strong>
short bte/btne branching</p>
<p><strong>0x02:</strong>
Change float 0.0 compares so that the compare is done in integer unit.</p>
<p><strong>0x04:</strong>
inhibit elimination of redundant float register movement
for SNGL or DBLE casts into
argument registers or global registers.</p>
<p><strong>0x08:</strong>
inhibit branch to bla and branch to branch optimization inside linearizer.</p>
<p><strong>0x10:</strong>
inhibit st_sta_ld pointer precedence checking.</p>
<p><strong>0x20:</strong>
inhibit ulshifti followed by lshifti folding (or visa-versa).</p>
<p><strong>0x40:</strong>
inhibit ANDHI followed by BIEQI/BINEI folding into a BEQANDHI.</p>
<p><strong>0x80:</strong>
Inhibit special treatment of ICJMPZ pointing to a ISUB or ISUBI.</p>
<p><strong>0x100:</strong>
Inhibit BIH_RGSET(bih) register optimization and just use curr_entry-&gt;regset.</p>
<p><strong>0x200:</strong>
Inhibit moving of individual members of a structure.</p>
<p><strong>0x400:</strong>
Inhibit deletion of odd global reg obtained from -x 12 256</p>
<p><strong>0x800:</strong>
Inhibit LDINC/STINC optimizations.</p>
<p class="last"><strong>0x1000:</strong>
Inhibit replacement of uplevel variable address load optimization for llvm target.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">13:</span></code></dt>
<dd><p class="first">Used to turn on experimental inliner techniques.</p>
<p><strong>0x01:</strong>
array formal parameters replaced with pointers;
expressions as arguments allowed.</p>
<p><strong>0x02:</strong>
Turn off CG checking of Fortran inlined SC_BASED variable dependency
checking.</p>
<p><strong>0x04:</strong>
used in inliner.c</p>
<p><strong>0x08:</strong>
Suppress accelerator error messages with -Mextract.</p>
<p><strong>0x10:</strong>
Only available in the dev (under #if DEBUG)
calls inline_mulh to inline IMULH UIMULH KMULH UKMULH calls into the appropriate
ILI to get the upper half of integer/i8 signed/unsigned multiplies.</p>
<p><strong>0x20:</strong>
Replace memcpy/memset with faster hammer __c_mcopy1/__c_mset1 calls.</p>
<p><strong>0x40:</strong>
Replace memset of value 0 with __c_mzero1 on hammer.</p>
<p><strong>0x800</strong>
AVAILABLE</p>
<p><strong>0x1000</strong>
When the extents of the dummy array and actual argument do not
match, linearize the subscript expressions; this amounts to generating
the ilm, INLELEM.
Normally, the dummy array is expressed as a cray pointee and its
corresponding pointer is assigned the address of the actual
argument.</p>
<p><strong>0x8000</strong>
Call-site inlining: inliner will inline those call sites where ipa
auto-inlining has decided to inline. This is in contrast to inline
all call sites for a given callee in a function if ipa finds at least
one call site beneficial to inline.</p>
<p><strong>0x20000</strong>
Replace all memset with __c_mset1 in the fast_libc_calls(). This is
only for an experimental purpose, not for production.</p>
<p><strong>0x20000000</strong>
Enable inlining into OpenACC host_data regions.</p>
<p><strong>0x40000000</strong>
Enable inlining into OpenMP task regions.</p>
<p class="last"><strong>0x80000000</strong>
turn on alpha-level experimental features.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">14:</span></code></dt>
<dd><p class="first">Extractor/Inliner.</p>
<p><strong>0x01:</strong>
Require actual &amp; dummy arrays to match in type, rather than just the
size and alignment of their base types.</p>
<p><strong>0x02:</strong>
Don’t perform the optimization when ‘&amp;var’ is an actual argument.
The optimization replaces the dereference of the formal argument
with ‘&amp;var’.</p>
<p><strong>0x04:</strong>
Don’t reuse inliner temps across inlinings; this allows more precise IPA
pointer target analysis (C)</p>
<p><strong>0x08:</strong>
Don’t extract this function (set by pragma noinline)</p>
<p><strong>0x10:</strong>
Run the extractor in the compiler itself; this is used for one-pass IPA
and IPA-driven inlining.</p>
<p><strong>0x20:</strong>
Do inlining during the expand phase, instead of during the parse phase.
This allows multiple levels of inlining during the compiler without
multiple levels of extraction.</p>
<p><strong>0x40:</strong>
Leave the original names during inlining, instead of changing all names
to ..inline</p>
<p><strong>0x80:</strong>
For Fortran, use IM_FARG for arguments</p>
<p><strong>0x100:</strong>
Compress the extract file, using lz.c</p>
<p><strong>0x200:</strong>
Share inliner temps for local variables from multiple inlines of
the same function (fortran); hopefully, in the near future, will
be reversing the sense of this XBIT.</p>
<p><strong>0x400:</strong>
For C, USED in inliner.c</p>
<p><strong>0x800:</strong>
inliner.c PGCPLUS decode_identifer???</p>
<p><strong>0x1000:</strong>
Don’t automatically create a new ili block if there are calls.
calls.</p>
<p><strong>0x2000:</strong>
Do not mark ‘inline’ functions as ‘static’ (this-file-only).
The default is treat inline like static.</p>
<p><strong>0x4000:</strong>
Used with IPA, allow extracting and inlining of functions or subprograms
with C statics or Fortran SAVE.</p>
<p><strong>0x8000:</strong>
Do not automatically mark static functions as this-file-only,
if extracting for IPA.</p>
<p><strong>0x10000:</strong>
Disable global inliner</p>
<p><strong>0x20000:</strong>
Enable global ILM module, which reads in all ILMs at once</p>
<p><strong>0x40000:</strong>
In the inliner, try to reuse struct/union datatypes and member symbols</p>
<p><strong>0x80000:</strong>
In the inliner, implement ‘small function’ heuristic</p>
<p><strong>0x100000:</strong>
Apply compression to the inline file when extracting ‘inline’ keyword functions.</p>
<p><strong>0x200000:</strong>
Extract and inline functions with the ‘inline’ keyword.</p>
<p><strong>0x400000:</strong>
Used with -x 14 0x200000, extract and inline all functions</p>
<p><strong>0x800000:</strong>
Used with -x 14 0x200000, when extracting functions with the inline keyword,
save the extract file, named EXFILE (for debugging).</p>
<p><strong>0x1000000:</strong>
Apply libc memset() inlining.</p>
<p><strong>0x2000000:</strong>
For C/C++ extractor, extract ALL symbols, change language from C or D to E</p>
<p><strong>0x4000000:</strong>
For Fortran inliner, don’t inline if we must reshape array arguments
with a Cray-pointer style based array.</p>
<p><strong>0x8000000:</strong>
For C/C++, also inline IPA-discovered ‘tiny’ routines.</p>
<p><strong>0x10000000:</strong>
for C/C++, increase the block ilm limit from 60,000 to 90,000</p>
<p><strong>0x20000000:</strong>
for C/C++, don’t extract routines with the INLINE_THIS_FILE_ONLY flag set.
This is useful for extracting for libraries that we only are going to inline
across files, like the libstd or libcpp routines.</p>
<p><strong>0x40000000:</strong>
Allow IPA-driven inlining of file static functions across files in some cases.</p>
<p><strong>0x80000000:</strong>
Don’t allow inlining functions into parallel regions.</p>
<p class="last"><strong>0x10000000:</strong>
Allow functions with statics in C and SAVE in Fortran to be inlined with Minline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">15:</span></code></dt>
<dd><p class="first">ILI strength reductions or transformations</p>
<p><strong>0x01:</strong>
Compute ‘x/y’ as  ‘x *(1.0/y)’, where x is not a constant &amp; y is a constant;
also set by -Mnouniform.</p>
<p><strong>0x02</strong>
Compute ‘x/y/z’ as ‘x/(y*z)’.</p>
<p><strong>0x04</strong>
Compute ‘x/y’ as  ‘x *(1.0/y)’, (if not IEEE switch &amp; -Mprelaxed=div)</p>
<p><strong>0x08</strong>
Disable the sincos transformation</p>
<p><strong>0x10</strong>
Relaxed fpmath.
Enables a set of operations that can be performed using various
methods, such as Newton’s method, that provide reasonable
approximations to the actual results.</p>
<p><strong>0x20</strong>
Do not check cpu type for relaxed fpmath.</p>
<p><strong>0x40</strong>
call mkfunc() instead of mkfunc_cncall() when creating functions as ili
replacements.</p>
<p><strong>0x80</strong>
Don’t transform ‘(double)x &lt;relop&gt; y’ into ‘x &lt;relop&gt; yy’, where y
is a double constant and can be exactly represented as the float yy.</p>
<p><strong>0x100</strong>
Inhibit combining IAMV/KAMV in the operands of an AADD (fortran only).</p>
<p><strong>0x200</strong>
-Mnouniform - do not require fp transformations/optimizatons to be
uniform across simd and scalar generated code; e.g.,
x/constant -&gt; x * (1.0/constant);
the vectorizer may hoist an invarant reciprocal, but the residual will
perform a divide; undo of -Mfprelaxed=div if the recip only has one use,
etc.</p>
<p><strong>0x400</strong>
-Mfprelaxed=intrinsic</p>
<p><strong>0x800</strong>
Disable the generation of [SD]CMPLXDIV ILIs, which perform complex
division using the new representation of complex data types by calling
the fastmath routines “__f[sv][cz]_div”.</p>
<p><strong>0x1000</strong>
Disable sorting of the ILI free list after garbage collection.</p>
<p><strong>0x2000</strong>
AVAILABLE</p>
<p><strong>0x4000</strong>
AVAILABLE</p>
<p><strong>0x8000</strong>
AVAILABLE</p>
<p><strong>0x10000</strong>
Disable the Newton’s appx for single precision sqrt</p>
<p><strong>0x20000</strong>
Disable the Newton’s appx for single precision recip sqrt</p>
<p><strong>0x40000</strong>
Disable the Newton’s appx for single precision divide</p>
<p><strong>0x80000</strong>
AVAILABLE</p>
<p><strong>0x100000</strong>
AVAILABLE</p>
<p><strong>0x200000</strong>
AVAILABLE</p>
<p><strong>0x400000</strong>
AVAILABLE</p>
<p><strong>0x800000</strong>
AVAILABLE</p>
<p><strong>0x1000000</strong>
AVAILABLE</p>
<p><strong>0x2000000</strong>
AVAILABLE</p>
<p><strong>0x4000000</strong>
Do not use the vex/fma4 fast math naming conventions.</p>
<p><strong>0x8000000</strong>
Inhibit IEEE compare semantics unless -Kieee is present</p>
<p><strong>0x10000000</strong>
Compute divide using the approximating instruction.</p>
<p><strong>0x20000000</strong>
Compute sqrt using the approximating instruction.</p>
<p><strong>0x40000000</strong>
Compute rsqrt using the approximating instruction.</p>
<p class="last"><strong>0x80000000</strong>
Experimental ili transformations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">16</span></code></dt>
<dd>alternate code for vectorization;
vectorized code is executed if count is
greater than n, i.e., the value of x[16].</dd>
<dt><code class="docutils literal notranslate"><span class="pre">17</span></code></dt>
<dd>alternate code for software pipelining;
pipelined code is executed if count is
greater than n, i.e., the value of x[17].</dd>
<dt><code class="docutils literal notranslate"><span class="pre">18</span></code></dt>
<dd>alternate code for unrolling;
completely unrolled code is executed if count is
less than or equal to n, i.e., the value of x[18].</dd>
<dt><code class="docutils literal notranslate"><span class="pre">19:</span></code></dt>
<dd><p class="first">Modify optimizations (pragmas/directives)</p>
<p><strong>0x01</strong>
noeqvchk. Don’t check equivalences for data dependencies.</p>
<p><strong>0x02</strong>
nolstval. Don’t compute last values.</p>
<p><strong>0x04</strong>
split.
can split subroutine/function calls from loop.</p>
<p><strong>0x08</strong>
notransform (no hlvect); also novector sets this bit</p>
<p><strong>0x10</strong>
norecog (no llvect); also novector sets this bit</p>
<p><strong>0x20</strong>
noswpipe (no recognize)</p>
<p><strong>0x40</strong>
nostream</p>
<p><strong>0x80</strong>
noinvarif. Don’t perform loop invariant conditional optimizations.</p>
<p><strong>0x100</strong>
independent loop (forall-independent loop).</p>
<p><strong>0x200</strong>
don’t perform tail recursion elimination</p>
<p><strong>0x400</strong>
perform loop vectorisation.</p>
<p><strong>Ox800</strong>
Perform zero trip elimination - will we ever be able to switch the sense?</p>
<p><strong>0x1000</strong>
Allow an induction variable with a nonconstant stride to be
used to compute a loop count.</p>
<p><strong>0x2000</strong>
is_invariant:always_executed() - when is_invariant() is called,
the default is to assume that the fg node containing the ili is
always executed; if the XBIT is set, assume that the fg node
is not always executed.</p>
<p><strong>0x4000</strong>
induc.c:while_repl() - allow calls to be present when attempting
to use hw looping for while loops.</p>
<p><strong>0x8000</strong>
assume that induc.c:max_loop_count() cannot determine the maximum
value of a loop count.</p>
<p><strong>0x10000</strong>
assume that the loop count after unrolling, returned by
unroll.c:unrolled_lpcnt(), is large.</p>
<p><strong>0x20000</strong>
don’t reassociate adds/mults in the front-end</p>
<p><strong>0x40000</strong>
Allow ‘extended range loops’ (a node is not within the lexical scope
of the head and tail nodes) to be countable.  If these types of loops
must be allowed by default, detection needs to be added to the vectorizer
and other high level opts (unrolling).</p>
<p><strong>0x80000</strong>
Change zero-trip checks to use the ST122c ‘skiplp’ instruction.</p>
<p><strong>0x100000</strong>
Assume addresses of dummy array arguments &amp; allocatables/pointers
are valid.</p>
<p><strong>0x200000</strong>
Don’t allow 64-bit int variables as induction variables (TEMPORARY)</p>
<p><strong>0x400000</strong>
Rely on the ADDRTKN flag of static variables being set by the front-end;
phases after the front-end can check the ADDRTKN flag of statics (PGC).</p>
<p><strong>0x800000</strong>
assume that the subscripts to invariant array references which
appear in block that do not dominate the tail of the loop
will not cause an illegal address to be generated.</p>
<p><strong>0x1000000</strong>
only allow reassociation if the terms are variables or constants.
Reassociation is disabled if XBIT(19,0x20000) is set.</p>
<p><strong>0x2000000</strong>
Inhibit prefetching in induc.</p>
<p><strong>0x4000000</strong>
Don’t assume guarded invariant floating point expressions are valid.</p>
<p><strong>0x8000000</strong>
Disable replacing induc’s loop count.</p>
<p><strong>0x10000000</strong>
Turn off tail recursion for X86_32,X86_64</p>
<p><strong>0x20000000</strong>
Select the prefetching in induc.c using the implementation which integrates
both inductive pointers and array address expressions.</p>
<p><strong>0x40000000</strong>
Disable prefetching for indirect loads.</p>
<p class="last"><strong>0x80000000</strong>
USED.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">20:</span></code></dt>
<dd><p class="first">Used to affect exception handling:</p>
<p><strong>0x01:</strong>
hw has exceptions in 21/22 turned off (default is on)</p>
<p><strong>0x02:</strong>
compiler turns off exceptions in 21/22 on program level</p>
<p><strong>0x04:</strong>
compiler turns off exceptions in 21/22 on file level</p>
<p><strong>0x08:</strong>
compiler turns off exceptions in 21/22 on function level (TBD)</p>
<p class="last"><strong>0x10:</strong>
compiler turns off exceptions in 21/22 on block level (TBD)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">21:</span></code></dt>
<dd><p class="first">Used to affect exception handling:
Active status of individual fp exceptions.</p>
<p><strong>0x01:</strong>
all fp exceptions active</p>
<p><strong>0x02:</strong>
divide by zero (DIVZ)</p>
<p><strong>0x04:</strong>
fp overflow (FOVF)</p>
<p><strong>0x08:</strong>
fp underflow (FUNF)</p>
<p><strong>0x10:</strong>
fp invalid input (src denormalized, NaN, or inf)</p>
<p><strong>0x20:</strong>
fp inexact result (pipe or result denorm, NaN)</p>
<p><strong>0x40</strong>
used in cgutil.c for n10</p>
<p class="last"><strong>0x80</strong>
used in cgutil.c for n10</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">22:</span></code></dt>
<dd><p class="first">Used to affect exception handling:
Active status of individual integer exceptions.</p>
<p><strong>0x01:</strong>
all int exceptions active</p>
<p><strong>0x02:</strong>
divide by zero (DIVZ)</p>
<p><strong>0x04:</strong>
int overflow (FOVF)</p>
<p class="last"><strong>0x08:</strong>
int underflow (FUNF)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">23:</span></code></dt>
<dd><p class="first">Used to affect exception handling (fsr):</p>
<p><strong>0x01:</strong>
FTE (floating point trap enable), no flushz</p>
<p><strong>0x02:</strong>
FTE, TI, no flushz</p>
<p><strong>0x04</strong>
FTE, flushz</p>
<p class="last"><strong>0x08</strong>
no FTE, flushz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">24:</span></code></dt>
<dd><p class="first">Used to affect exception handling (traps)</p>
<p><strong>0x01:</strong>
-Ktrap=fp (ABI systems only)</p>
<p><strong>0x02</strong>
-Ktrap=align (ABI systems only)</p>
<p><strong>0x04</strong>
All normal calls are followed by a call to a system routine
that only modifies R30/R31.</p>
<p><strong>0x08</strong>
Ktrap=inv (x86-FCW invalid operation))</p>
<p><strong>0x10</strong>
Ktrap=denorm (x86-FCW denormalized operand))</p>
<p><strong>0x20</strong>
Ktrap=divz (x86-FCW zero divide)</p>
<p><strong>0x40</strong>
Ktrap=ovf (x86-FCW overflow))</p>
<p><strong>0x80</strong>
Ktrap=unf (x86-FCW underflow))</p>
<p class="last"><strong>0x100</strong>
Ktrap=inexact (x86-FCW precision)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">25:</span></code></dt>
<dd><p class="first">Experimental features of compilers.</p>
<p><strong>0x01:</strong>
Turn on alpha-level experimental front-end features.</p>
<p><strong>0x02:</strong>
Turn on alpha-level experimental vectorizer features.</p>
<p><strong>0x04:</strong>
Turn on alpha-level experimental optimizer features.</p>
<p><strong>0x08:</strong>
Turn on alpha-level experimental code generation.</p>
<p><strong>0x10:</strong>
Turn on beta-level experimental front-end features.</p>
<p><strong>0x20:</strong>
Turn on beta-level experimental vectorizer features.</p>
<p><strong>0x40:</strong>
Turn on beta-level experimental optimizer features.</p>
<p class="last"><strong>0x80:</strong>
Turn on beta-level experimental code generation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">26:</span></code></dt>
<dd><p class="first">Modify ILI. Was pipe flushing (deprecated)</p>
<p><strong>0x01:</strong>
TEMPORARY - enable new math names for complex routines under development
(XBIT(164,0x800000) must also be set.
Was “Flush pipes in minimal fashion” (deprecated)</p>
<p><strong>0x02:</strong>
When using the new math naming scheme for scalar routines, follow the ‘vector’
ABI instead of the C ABI.  On x64, this will alter passing a complex double
scalar.
Was “Full flush of all pipes” (deprecated)</p>
<p><strong>0x04:</strong>
used in cgutil.c for n10</p>
<p class="last"><strong>0x08:</strong>
used in cgutil.c for n10</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">27:</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">28:</span></code></dt>
<dd><p class="first">Optimizer - modify behavior</p>
<p><strong>0x01:</strong>
turn on global reg for region 0 if function exits early - a function exits
early if there exists a branch to the exit from the 4th (or earlier) block
of the function.  For region 0 of a function which exits early, new global
regs are not assigned and any registers which were previously assigned are
not propagated; goal is to minimize the amount of code prior to the early
exit.</p>
<p><strong>0x02:</strong>
perform complete induction analysis (override attempts to
exclude certain linear, integer, array references).</p>
<p><strong>0x04:</strong>
propagate any registers assignments for a function which was determined to
exit early.</p>
<p><strong>0x08:</strong>
inhibit recognition of min/max pattern ( if (a &lt;rel&gt; b) a = b ).</p>
<p><strong>0x10:</strong>
Disables copying of POINTER array to sequential temp array at calls.
Disables using the descriptor’s ‘len’ field as the final subscript
multiplier, i.e., assume that the pointer locates a contiguous
array.
Enabling this is nonstandard F90.</p>
<p><strong>0x20:</strong>
At subroutine call, when passing POINTER array to sequential dummy array,
we usually copy to a sequential temp.  If this bit is set, a run-time test for
NULL pointer is inserted, and the temp is not created or copied if it is null.
Note: passing the NULL pointer is nonstandard, but some other compilers
implement this.</p>
<p><strong>0x40</strong>
Allow [unsigned] long long variables to be assigned global registers
for targets, such as the ST100, where the default is to disallow such
assignments.</p>
<p><strong>0x80</strong>
Allow float/double variables to be assigned global registers
for targets, such as the ST100, where the default is to disallow such
assignments.</p>
<p><strong>0x100</strong>
Allow copy propagation of all exprs.  Currently we disallow costly exprs
(if the vectorizer is on.)   [ in optutil.c - cp_loop. ]</p>
<p><strong>0x200</strong>
Use alternate induc method to reduce induction variables; the
actual methods are target dependent.</p>
<p><strong>0x400</strong>
When inlining Fortran, passing 1D array element to array, use a base pointer</p>
<p><strong>0x800</strong>
Do not allow a temp to be assigned to certain types of invariant loads
if its address computation is “costly”; normally, we do not trade a simple
load for a load of a temp.</p>
<p><strong>0x1000</strong>
Use unique temps when replacing fp constants during invar.
May be extended to include scalar replacement.</p>
<p><strong>0x2000</strong>
Use unique temps when replacing invariant expressions.
available</p>
<p><strong>0x4000</strong>
Disable optimizations fg_opt_comp_one/fg_opt_comp_zero from fgraph.c
These are designed to remove useless test/use of intermediate variables that hold results of comparisons</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cond = (a&gt;b) ;
if (cond) {
    ...
}
</pre></div>
</div>
<p>will be transformed into</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cond = (a&gt;b) ;
if (a&gt;b) {
    ...
}
</pre></div>
</div>
<p>Thus if variable cond is no longer used it gets eliminated.
This optimization mainly benefits C++ codes.</p>
<p><strong>0x8000</strong>
Inhibit checking for invariant common base pointers.</p>
<p><strong>0x10000</strong>
inhibit recognition of the if-then-else pattern</p>
<p><strong>0x20000</strong>
inhibit recognition of the if-then pattern</p>
<p><strong>0x40000</strong>
inhibit recognition of the if-the-else &amp; if-then patterns when the
conditional is floating point and the expression are integer or pointer</p>
<p><strong>0x80000</strong>
Disable replacing narrow integer scalars with int temporaries</p>
<p><strong>0x100000</strong>
Disable recognition of the if-then pattern with FREE* ops (often
due to post-mod) and replacement of such a pattern with SELECT.</p>
<p><strong>0x200000</strong>
Reassociate address computation expressions to improve code floating of
subexpressions.</p>
<p><strong>0x400000</strong>
Do not classify an address constant as costly to compute, such as
one for computing the address of an external when -fpic for 64-bit
Costly acons or invariant loads via costly acons may be assigned to
temp.</p>
<p><strong>0x800000</strong>
Exclude all induction pointers used as basepointers in load/store
operations.</p>
<p><strong>0x1000000</strong>
Inhibit combining of invariants in address expressions generated
for subscripting of fortran arrays.</p>
<p><strong>0x2000000</strong>
Restrict -x 28 0x1000000 (combining of invariants …) to fortran pointers.</p>
<p><strong>0x4000000</strong>
Inhibit hlinduc0:do_ptr_branch - create countable loops out of
pointer-controlled loops</p>
<p><strong>0x8000000</strong>
Inhibit hlinduc0:do_ptr_branch - create countable loops out of all
candidate pointer-controlled loops (aggressive)</p>
<p><strong>0x10000000</strong>
Replace loop_cnt with new induction variable even if we cannot determine
that init + (loop_cnt * skip) will not overflow.</p>
<p><strong>0x20000000</strong>
Do not attempt to SIMD-ize a sequence of reciprocal sqrts (aka the gromacs
hack).</p>
<p><strong>0x40000000</strong>
Experimental invar</p>
<p class="last"><strong>0x80000000</strong>
Experimental induc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">29:</span></code></dt>
<dd><p class="first">Optimizer - modify behavior</p>
<p><strong>0x01:</strong>
For the gromacs optimization on AVX, use avx (256-bit avx)</p>
<p><strong>0x02:</strong>
For the gromacs optimization on AVX, use vex (128-bit avx)</p>
<p><strong>0x04:</strong>
(C++) inhibit flow.c:delete_unrefd()</p>
<p><strong>0x08:</strong>
Inhibit recognition of the if-the-else &amp; if-then patterns when the
expressions are floating point</p>
<p><strong>0x10:</strong>
Inhibit recognition of the if-the-else &amp; if-then patterns for a LHS which
is not a scalar variable</p>
<p><strong>0x20:</strong>
Inhibit recognition of power-of-2 multipliers of induction variables
appearing as subscripts</p>
<p><strong>0x40</strong>
For scalar prefetching (induc.c:prefetch_integrated()), the non-stride-1
constraint is applied to the candidate’s induction variable rather than
the induction family/master variable.</p>
<p><strong>0x80</strong>
Experimental flow.c: treat uses of COMPLEX differently.</p>
<p><strong>0x100</strong>
Inhibit the induction branch optimization if a call occurs.</p>
<p><strong>0x200</strong>
Inhibit creating countable loops from pointer-controlled loops; does not apply
when the loop-end condition is a known ‘distance’ away from the initial value
of the pointer</p>
<p><strong>0x400</strong>
Disable scalar replacement for invariant array references within loops.</p>
<p class="last"><strong>0x800</strong>
reserved.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">30-39</span></code></dt>
<dd>Reserved for low-level vectorizer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">30:</span></code></dt>
<dd>High level vectorizer - maximum size of loop nests to process.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">31:</span></code></dt>
<dd>Low-level vectorizer - cache vectors only if strip size &gt;= n.
(860 only).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">32:</span></code></dt>
<dd><p class="first">Low-level vectorizer - amount of cache used by low-level vectorizer.
(860 only).</p>
<p class="last">High-level vectorizer - size of on-chip cache (x86 only).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">33:</span></code></dt>
<dd>Low-level vectorizer - maximum strip size of loops with non-invariant
complex vectors.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">34:</span></code></dt>
<dd><p class="first">Low-level vectorizer - modify behavior.</p>
<p><strong>0x01:</strong>
Generate mcp calls (FPS option).</p>
<p><strong>0x02:</strong>
Streamin/out all linear loads/stores</p>
<p><strong>0x04:</strong>
Generate XP calls.</p>
<p><strong>0x08:</strong>
Inhibit vector intrinsics recognition.</p>
<p><strong>0x10:</strong>
(Sparc only) Don’t allow parallel outer loop.</p>
<p><strong>0x20:</strong>
Sparc: Don’t allow parallel inner loop.
860: Don’t allow parallel loop.</p>
<p><strong>0x40:</strong>
(Sparc only) Designate outer loop to be parallel.</p>
<p><strong>0x80:</strong>
Sparc: Designate inner loop to be parallel.
860: Designate loop to be parallel.</p>
<p><strong>0x100:</strong>
(860 only) Allocate loop iterations to CPUs cyclically.</p>
<p><strong>0x200:</strong>
(mp sparc &amp; 860) Permit automatic parallelization of loops.</p>
<p><strong>0x400:</strong>
(860 only) Permit parallel inner loops to contain invariant vectors.</p>
<p><strong>0x800</strong>
Last values are computed on the last iteration of a loop.</p>
<p><strong>0x1000</strong>
permit innermost loop to be parallelized if parallelizable</p>
<p><strong>0x2000</strong>
don’t check loop count when parallelizing non-innermost loops</p>
<p><strong>0x4000</strong>
disallow to parallelize innermost with conditional reduction</p>
<p><strong>0x8000</strong>
set thread number to be constant 2 for dual_core system</p>
<p><strong>0x10000</strong>
generate only parallel version for runtime testings</p>
<p><strong>0x20000</strong>
generate serial version regarding ncpus setting value 1</p>
<p><strong>0x40000</strong>
disallow pipeline parallelization</p>
<p><strong>0x80000:</strong>
Ignore any array bounds information when determining if stripmining
needs to be performed (i.e., assume that array bounds will be violated in
a vectorizable loop).</p>
<p><strong>0x100000:</strong>
nolastdim. Ignore the (declared) extents of an array in blank common
if the extent of the last dimension is 1 (pgftn-sparc only); directive
scope is either routine or global (not loop).</p>
<p><strong>0x200000:</strong>
in llvect for hammer, disable enhanced array reference alignment testing</p>
<p><strong>0x400000:</strong>
(hammer and x8632 only) `#pragma altcode alignment’: if possible,
generate an alternative version of the loop with extra aligned moves,
guarded by a runtime alignment test.</p>
<p><strong>0x800000:</strong>
Set the minimum loop count of innermost loops to 128 for -Mconcur</p>
<p><strong>0x1000000:</strong>
Disable the the profitablity check for -Mconcur</p>
<p><strong>0x2000000:</strong>
Inhibit the 2nd pass of the high-level vectorizer</p>
<p><strong>0x4000000:</strong>
Classify single level loops as innermost for -Mconcur</p>
<p><strong>0x8000000:</strong>
Disable multi-level invariant hoisting for loop created by array
assignment or loop with same loop bounds.</p>
<p><strong>0x10000000:</strong>
Disable the generation of altcode whose execution is governed by
runtime pointer conflict tests.</p>
<p><strong>0x20000000:</strong>
Enable the following performance enhancement: on x86 targets that
support AVX, only perform LRE (i.e. loop-carried redundancy
elimination) on a loop if it removes at least 10% of the loop’s
real*4, real*8, complex*8 or complex*16 operations.  The rationale for
this is that LRE forces a loop to be vectorised using xmm registers
rather than ymm or zmm ones, so if it only removes a small percentage
of the loop’s operations then its benefit may be outweighed by the
cost of vectorising the loop using smaller vector registers.  For
example this enhancement gives a speed-up for applu by preventing LRE
from being performed on the loop at line 1673 of applu.f, for which it
only removes 2% of the operations.</p>
<p><strong>0x40000000</strong>
Allow conditional vectorization containing reductions (experimental)</p>
<p class="last"><strong>0x80000000</strong>
Disable LLVM vectorization containing SELECT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">35:</span></code></dt>
<dd><p class="first">Low-level vectorizer - maximum loop iteration count; 0 means
unknown.</p>
<p class="last"><strong>0x01:</strong>
Disable limiting number of non temporal stores according to relative alignments’s impact
on write-combining buffer.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">36</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Place the vcache area on the stack.
(860 only).</p>
<p><strong>0x02:</strong>
In parallel loops, allocate static area for the vcache.
(860 only).</p>
<p><strong>0x04:</strong>
Beta fast- and/or relaxed- math scalar/vector versions of certain intrinsics.</p>
<p><strong>0x08:</strong>
LLVM - disable extended scalar analysis in conditional loops with a
definition on only one side of the conditional.</p>
<p><strong>0x10:</strong>
LLVM - disable extended conditional vectorization in all loops where the
predicate size is different than the computational size.</p>
<p><strong>0x20:</strong>
LLVM - allow vectorization if multiple lhs data type sizes exist</p>
<blockquote>
<div>within the inner loop</div></blockquote>
<p><strong>0x40:</strong>
LLVM - don’t allow vectorization of DBLE ili</p>
<p><strong>0x80:</strong>
LLVM - don’t allow vectorization of DFLOAT/IKMV ili</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">37</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Sparc only – generate code for VPU.</p>
<p><strong>0x02:</strong>
Sparc only – use old-style parameter block code.</p>
<p><strong>0x04:</strong>
Put all loops in llv loop table. With loop scope, the following loop
will be placed in the llv loop table, even if not parallelizable.</p>
<p><strong>0x08:</strong>
Put no loops in llv loop table. With loop scope, the following loop
will not be placed in the llv loop table, even if parallelizable.</p>
<p><strong>0x10</strong>
Insert Meiko polling code into outer loops.</p>
<p><strong>0x20</strong>
Allow loops containing stack-based variables to be vectorized.</p>
<p><strong>0x80</strong>
Temporary switch - turns of insertion of vsld32 instruction in front
of certain single precision vector loads.  This instruction is inserted
to work around a hardware problem.</p>
<p><strong>0x100</strong>
Turn off extended scalar expansion</p>
<p><strong>0x200</strong>
Turn off calculation of condtitional vectorization possibilities</p>
<p><strong>0x400</strong>
Disable llvect from generating vectorization code for conditionals</p>
<p><strong>0x800</strong>
Disable llvect from generating masked fdiv fp routine for conditionals</p>
<p><strong>0x1000</strong>
Disable conditional vectorization for compound predicates</p>
<p><strong>0x2000</strong>
Don’t check conditional vectorization masks for all 0’s or 1’s (short circuiting)</p>
<p><strong>0x4000</strong>
Conditional vectorization: turn off extended CSE for code outside current block</p>
<p><strong>0x8000</strong>
Conditional vectorization: don’t use mask vector intrinsics</p>
<p><strong>0x10000</strong>
Check for all 0’s and 1’s regardless of threshhold value</p>
<p><strong>0x20000</strong>
Don’t let intrinsic calls prevent short circuiting</p>
<p><strong>0x40000</strong>
Treat scalars the old way - NOP analysis not affected by conditional vect</p>
<p><strong>0x80000</strong>
Allow chained control dependence with conditional vectorization</p>
<p><strong>0x100000</strong>
Allow complex chained control dependence with conditional vectorization</p>
<p><strong>0x200000</strong>
Turn off vectorization with assigments to logical compares</p>
<p><strong>0x400000</strong>
For llvm compilers, do vectorize max/min operations</p>
<p><strong>0x800000</strong>
For llvm compilers, don’t construct vector ILI trees with math intrinsic calls</p>
<p><strong>0x1000000</strong>
For LLVM compilers, enable vectorization with small ints on rhs</p>
<p><strong>0x2000000</strong>
For LLVM compilers, don’t allow scalar expansion with vector temps within loops</p>
<p><strong>0x4000000</strong>
Native x86 compilers, don’t vectorize conditionals with any “OR” predicates`</p>
<p><strong>0x8000000</strong>
LLVM compilers, check use counts</p>
<p><strong>0x10000000</strong>
LLVM compilers, don’t perform newton’s method within llvect</p>
<p><strong>0x20000000</strong>
Allow CVECT with just one link to flow down this value without merge</p>
<p><strong>0x40000000</strong>
LLVM compilers, don’t perform vectorization on induction iterators</p>
<p><strong>0x80000000</strong>
LLVM compilers, don’t allow any store matching to the RHS within add_vili()</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">38</span></code></dt>
<dd>reserved.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">39:</span></code></dt>
<dd><p class="first">i860 low-level vectorizer: Maximum number of elements over which
array references may span before they can be combined within a single
cache vector. The span between A(i+k1) and A(i+k2) is defined to be
<a href="#id1"><span class="problematic" id="id2">|</span></a>k1-k2|+1. If this switch is 0, allow any span.
Hammer and x8632 low-level vectoriser:</p>
<p><strong>0x01:</strong>
Don’t generate prefetches in vectorised loops or loops that are
unrolled by the vectoriser.</p>
<p><strong>0x02:</strong>
Don’t vectorise loops (though the vectoriser can unroll them).</p>
<p><strong>0x04:</strong>
Don’t unroll a vector loop body.</p>
<p><strong>0x08:</strong>
Prefetch one vector iteration ahead.</p>
<p><strong>0x10:</strong>
Disable the vectorisation profitability test for real*4 loads and
stores with (stride != 1).</p>
<p><strong>0x20:</strong>
Disable the streaming store optimization.</p>
<p><strong>0x80:</strong>
Enable vectorisation and llvect unrolling of loops containing
intrinsic function calls.</p>
<p><strong>0x100:</strong>
Disable all vectorisation profitability tests.</p>
<p><strong>0x200:</strong>
-Mnontemporal or -Mmovnt: generate non-temporal stores even in loops
that are not in memory altcode.  (They’re generated by default in
memory altcode loops.)</p>
<p><strong>0x400:</strong>
Disable the optimisation of stride-2 loads and stores.</p>
<p><strong>0x800:</strong>
Generate “prefetchnta” instructions instead of the default prefetch
instructions.</p>
<p><strong>0x1000:</strong>
Generate “prefetchw” instructions for arrays that are stored into.</p>
<p><strong>0x2000:</strong>
Don’t vectorise loops that are “too big”.</p>
<p><strong>0x4000:</strong>
Generate “prefetcht0” instructions.  (This is the default anyway.)</p>
<p><strong>0x8000:</strong>
Disable unrolling of non-vectorised loops by the vectoriser.</p>
<p><strong>0x10000:</strong>
Generate “prefetch” instructions instead of the default prefetch
instructions.</p>
<p><strong>0x20000:</strong>
Generate prefetches for loads with any stride, rather than just for
loads with stride 1 or 2.</p>
<p><strong>0x40000:</strong>
Disable the complex_add_loop optimisation.</p>
<p><strong>0x80000:</strong>
Don’t peel vectorised loops that contain non-stride-1 loads.</p>
<p><strong>0x100000:</strong>
Mark an array that has been parallelized as aligned if its initial
non-parallel address is aligned.</p>
<p><strong>0x200000:</strong>
Don’t vectorize loops that have a lexically forward anti-flow
dependence with (&lt;) direction.</p>
<p><strong>0x400000:</strong>
In llvect, when checking whether a load and store with different addresses
conflict, if ‘hlconflict’ returns ‘SAME’ we normally change that to ‘CONFLICT’,
because the NMEs are not updated by loop unrolling, so ‘SAME’ is imprecise.
This flag disables that behavior.</p>
<p><strong>0x800000:</strong>
Don’t vectorise loops that contain a store to an array element whose
address is not a linear function of the loop index with a compile-time
constant stride.</p>
<p><strong>0x1000000</strong>
Vectorize loops with a constant small loop count if possible.</p>
<p><strong>0x2000000</strong>
Don’t generate scalar non-temporal stores.</p>
<p><strong>0x4000000</strong>
No induction analysis in the presence of indirect array refs; also checked
in induc.c to inhibit all induc optimizations on loops that been vectorized.</p>
<p><strong>0x8000000</strong>
Use ‘movlpd’ and ‘movhpd’ to load and store real*8 stride-2 pairs.</p>
<p><strong>0x10000000</strong>
Use multiple registers to accumulate a vectorised reduction, i.e. use
a different register to accumulate the reduction in each copy of the
unrolled vector loop body.  By default the same register is used to
accumulate the reduction in all copies of the unrolled vector loop body.</p>
<p><strong>0x20000000</strong>
Double the default number of vector loop unrolls for AMD processors &gt;=
greyhound.</p>
<p><strong>0x40000000</strong>
Don’t vectorise or unroll a loop that contains conditional multiple blocks.</p>
<p class="last"><strong>0x80000000</strong>
Allow vectorizing multiple blocks and 64-bit selects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">40:</span></code></dt>
<dd>High-level vectorizer:  loop-splitting heuristic; number of array loads/stores
allowed before loop is split.  Default is 20.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">41:</span></code></dt>
<dd>High-level vectorizer:  loop-splitting heuristic; number of floating point
operations allowed before loop is split.  Double precision ops count 2,
single precision ops count 1.  Default is 40.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">42:</span></code></dt>
<dd><p class="first">High-level vectorizer behavior modification.</p>
<p><strong>0x01</strong>
(Obsolete) Inhibit loop distribution and interchange.</p>
<p><strong>0x02</strong>
Inhibit breaking cycles of anti-dependences in the Sparc compilers.</p>
<p><strong>0x04</strong>
Permit external calls in vectorized loops.</p>
<p><strong>0x08</strong>
Inhibit array expansion.</p>
<p><strong>0x10</strong>
Disable loop blocking (tiling)</p>
<p><strong>0x20</strong>
Disable unroll and jam</p>
<p><strong>0x40</strong>
Disable outer loop distribution</p>
<p><strong>0x80</strong>
ENABLE  inner loop distribution (NOTICE sense difference here)</p>
<p><strong>0x100</strong>
Disable loop interchange</p>
<p><strong>0x200</strong>
Perform scalar unroll &amp; jam on loop</p>
<p><strong>0x400</strong>
Disable reduction marking in hlv</p>
<p><strong>0x800</strong>
Disable scalar replacement in hlv</p>
<p><strong>0x1000</strong>
Don’t enter hlv_vectorize() for a particular routine</p>
<p><strong>0x2000</strong>
Go ahead and perform outer loop distribution on single-nested loops</p>
<p><strong>0x4000</strong>
Don’t generate strip loop around loop-distributed code</p>
<p><strong>0x8000</strong>
Limit vectorization on functions based upon heuristics</p>
<p><strong>0x10000</strong>
Allow loop distribution as the only loop transformation</p>
<p><strong>0x20000</strong>
Enable loop fusion.</p>
<p><strong>0x40000</strong>
Allow loop fusion with calls</p>
<p><strong>0x80000</strong>
Disable loop fusion of noninner loops.</p>
<p><strong>0x100000</strong>
Disable scalar unroll and jam</p>
<p><strong>0x200000</strong>
Disable loop-carried redundancy elimination</p>
<p><strong>0x400000</strong>
Loop-carried redundancy elimination: disallow reassociation</p>
<p><strong>0x800000</strong>
Loop-carried redundancy elimination: disallow reassociation</p>
<p><strong>0x1000000</strong>
For testing: LRE temps do not get CCSYM flag set</p>
<p><strong>0x2000000</strong>
LRE: treat array refs as expressions, so a[k] and a[k-1] will be recognized as LREs</p>
<p><strong>0x4000000</strong>
LRE: allow modifications in the loop, so a[k]= will not eliminate a[k]+b[k]
and a[k-1]+b[k-1] from being considered as LREs</p>
<p><strong>0x8000000</strong>
LRE: build balanced tree of operands when rebuilding expressions
should only be used with reassociation</p>
<p><strong>0x10000000</strong>
LRE: run vanilla LRE before vectorizer; default is after vectorizer</p>
<p><strong>0x20000000</strong>
LRE: run LRE with X heuristic before vectorizer; also runs full LRE after vectorizer</p>
<p><strong>0x40000000</strong>
LRE: allow indirection</p>
<p class="last"><strong>0x80000000</strong>
Enable loop fusion when loop contains array dummy argument read/write
(default not allowed).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">43:</span></code></dt>
<dd>(860) Minimum loop count for an innermost loop to be parallelized if it
contains a reduction.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">44:</span></code></dt>
<dd><ol class="first last arabic simple" start="860">
<li>Minimum loop count for an innermost loop to be parallelized.</li>
</ol>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">45:</span></code></dt>
<dd>The ‘machine number’ to use for the datatype table.
The default is machine zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">46:</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">47:</span></code></dt>
<dd><p class="first">reserved</p>
<p><strong>0x100</strong>
Disable shmem_get inlining.</p>
<p><strong>0x200</strong>
Disable inline_small_matmul.</p>
<p><strong>0x1000</strong>
Disable dead code and scalar optimization phase.</p>
<p><strong>0x2000</strong>
Disable optimization of gather/scatter/copy/overlap-shift communication</p>
<p><strong>0x4000</strong>
Disable optimization of hcstart</p>
<p><strong>0x8000</strong>
Disable optimization of allobnds</p>
<p><strong>0x10000</strong>
Disable optimization of localize-bounds and section</p>
<p><strong>0x20000</strong>
Disable optimization of get_scalar</p>
<p><strong>0x40000</strong>
Disable optimization of copy communication</p>
<p><strong>0x80000</strong>
Disable optimization of gather/scatter communication</p>
<p><strong>0x100000</strong>
Disable optimization of overlap-shift communication</p>
<p><strong>0x200000</strong>
Enable automatic loop parallelization</p>
<p><strong>0x400000</strong>
inline pgf90_sect calls</p>
<p><strong>0x800000</strong>
Disable using the lhs of an assignment as the result of
a call to a use function.</p>
<p><strong>0x1000000</strong>
in fe90/outconv, do set the global-size for descriptors even if not global
and not passed as arguments</p>
<p><strong>0x2000000</strong>
in fe90/lowersym, do initialize pointer/sdsc for compiler-generated
temp pointer arrays</p>
<p><strong>0x4000000</strong>
Do fuse foralls even if the RHS is a constant zero;
by default, we don’t fuse these, because we can efficiently turn them into mzero calls</p>
<p><strong>0x8000000</strong>
Emit call to pghpf_associated for the ASSOCIATED intrinsic.</p>
<p><strong>0x10000000</strong>
Do not call our streamlined/dgemm-like matmul run-time routines.</p>
<p><strong>0x20000000</strong>
Disable the optimization of reshape</p>
<p><strong>0x40000000</strong>
Do not attempt to dial down the opt level in the f90 frontend</p>
<p class="last"><strong>0x80000000</strong>
reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">48:</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">49:</span></code></dt>
<dd><p class="first">Behavior modification.</p>
<p><strong>0x1</strong>
Inhibit transformation passes – directive processing is done.</p>
<p><strong>0x2</strong>
Inhibit forall conversion.</p>
<p><strong>0x4</strong>
reserved</p>
<p><strong>0x8</strong>
Inhibit discarding parentheses.</p>
<p><strong>0x10</strong>
Don’t include PARAMETER variables when AST expression simplification is
performed.</p>
<p><strong>0x20</strong>
Inhibit communication analyzer and optimizer.</p>
<p><strong>0x40</strong>
Allow CM fortran’s intrinsics.</p>
<p><strong>0x80</strong>
f77 output (pgftn extensions not allowed; Cray POINTERS allowed).</p>
<p><strong>0x100</strong>
Target’s pointers are 64-bits.</p>
<p><strong>0x200</strong>
Normally double precision is twice real; this makes it the same as real.
Similarly for double complex.</p>
<p><strong>0x400</strong>
reserved</p>
<p><strong>0x800</strong>
reserved</p>
<p><strong>0x1000</strong>
Emit function &amp; line number information for runtime error handling and for
communication profiling.</p>
<p><strong>0x2000</strong>
reserved</p>
<p><strong>0x4000</strong>
Source profiling.</p>
<p><strong>0x8000</strong>
Cray POINTERs not allowed in the output.
Valid only if the output is f77 (-x 49 0x80).</p>
<p><strong>0x10000</strong>
reserved</p>
<p><strong>0x20000</strong>
Disable invariant communication call hoisting.</p>
<p><strong>0x40000</strong>
C90 target.</p>
<p><strong>0x80000</strong>
reserved</p>
<p><strong>0x100000</strong>
Don’t pass character constants as arguments to pgf90_loc (e.g., when
the platform is HP).</p>
<p><strong>0x200000</strong>
Inhibit inlining on following loop.</p>
<p><strong>0x400000</strong>
F90 output – kinded constants, pass some intrinsics through.</p>
<p><strong>0x800000</strong>
Native REAL is REAL8 and CMPLX is CMPLX16.
Map double precision constants (0.0d0) to real constant format (0.0e0).</p>
<p><strong>0x1000000</strong>
T3D/T3E target.</p>
<p><strong>0x2000000</strong>
reserved</p>
<p><strong>0x4000000</strong>
reserved</p>
<p><strong>0x8000000</strong>
reserved</p>
<p><strong>0x10000000</strong>
For POINTERs in commons, place their associated variables near the
beginning of the common.  This is non/-f90/-f95/-f2003 behavior but was
our original behavior.</p>
<p><strong>0x20000000</strong>
In lowerilm, don’t use PLD and PST for load/store of pointer variables</p>
<p><strong>0x40000000</strong>
Return the value of complex functions the same as C (e.g. be XLF compatible)).XB 0x80000000
Native INTEGER is INTEGER*8 and LOGICAL is LOGICAL*8.</p>
<p class="last"><strong>0x80000000</strong>
reserved</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">50:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
i860/apx under DOS (default is under UNIX)</p>
<p><strong>0x02:</strong>
native Fortran</p>
<p><strong>0x04:</strong>
Only put out # linenum or #line linenum when the line number changes,
rather than the default which is when the line number sequence is broken.
Good for debugging.</p>
<p><strong>0x10:</strong>
For Fortran, generate ‘verbose’ .ilm files.</p>
<p><strong>0x20:</strong>
Inhibit any specific DOS end-of-line checks.</p>
<p><strong>0x40:</strong>
Enable unconditional_branches() (Fortran): look for conditional branches
with constant conditions;  remove the branch, remove unreachable code as well.</p>
<p><strong>0x100:</strong>
Don’t generate pgdbg_stub reference, used for generating shared libraries</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">51:</span></code></dt>
<dd><p class="first">In Fortran, determines host specific output options for TINY/HUGE.</p>
<p><strong>0x01:</strong>
Defines smallest integer*1 as -HUGE(integer*1).</p>
<p><strong>0x02:</strong>
Defines smallest integer*2 as -HUGE(integer*2).</p>
<p><strong>0x04:</strong>
Defines smallest integer*4 as -HUGE(integer*4).
In two’s complement arithmetic, 0x80000000 is -2147483648,
whereas 0x7fffffff is +2147483647; some compilers reserve the value 0x80000000,
so we have to use 0x80000001 as the smallest integer (this is used
for MAXVAL initialization).</p>
<p><strong>0x08:</strong>
Defines smallest integer*8 as -HUGE(integer*8).</p>
<p><strong>0x10:</strong>
Tells the compiler to use a hexadecimal double-word constant to represent
TINY(1.0d0); the normal value for TINY(1.0e0) is 1.175494351E-38
(represented by 0x00800000 in IEEE floating point), and
TINY(1.0d0) is 2.22507385850720138E-308
(represented by 0x0010000000000000 in IEEE).
However, the IBM xlf compiler (and perhaps others) will round a value of
2.22507385850720138E-308 to zero; it will accept the
z’0010000000000000’ syntax and will then use this and print it as the
correct value (go figure).</p>
<p><strong>0x20:</strong>
Disallow REAL/DOUBLE PRECISION/COMPLEX in typeless pgi predefined
functions AND, OR, EQV, NEQV, COMPL, and SHIFT.</p>
<p><strong>0x40:</strong>
Keeps ‘TINY’ and ‘HUGE’ even without F90 output.</p>
<p class="last"><strong>0x80</strong>
When generating code for reductions, don’t generate quad-precision
accumulators for double precision arguments.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">52:</span></code></dt>
<dd><p class="first">Host dependent:</p>
<p><strong>0x01:</strong>
Fortran: Complex in Common blocks must be aligned to double-word boundaries.</p>
<p><strong>0x02:</strong>
AVAILABLE</p>
<p><strong>0x04:</strong>
Fortran: do linearize arrays.
(used to be don’t linearize, but we reversed the sense of the bit).</p>
<p><strong>0x08:</strong>
Do use the old method of filling in .A0000 variables for adjustable
array bounds temps.</p>
<p><strong>0x10:</strong>
reserved</p>
<p><strong>0x20</strong>
reserved</p>
<p><strong>0x40</strong>
Generate unified .mod module output file.</p>
<p class="last"><strong>0x80</strong>
Front-end generates the linkage names for module subrprograms (still
experimental)</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">53:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Require pointer target analysis or interprocedural pointer disambiguation
to be enabled when testing nme loop safeness (optutil.c, is_nme_loop_safe).</p>
<p><strong>0x02:</strong>
Enable intraprocedural pointer target analysis.</p>
<p><strong>0x04:</strong>
Remove points-to information before schedule().</p>
<p><strong>0x08:</strong>
Build the LP_PLOADS (loop pointer loads) structure when doing flow analysis
on loops, allowing more pointer target analysis on loops.</p>
<p><strong>0x10000</strong>
Disable checking
the ptr refs information collected in flow for determining
if there are any pointer conflicts with respect to the ansi alias
rules.</p>
<p><strong>0x20000</strong>
Enable creating DEFS for calls whose uses will be loads of variables
that can be modified by calls.</p>
<p><strong>0x40000</strong>
is_sym_parsect_safe() - only consider private variables safe in parallel
sections; inhibit more aggressive checks.</p>
<p><strong>0x80000</strong>
Enable ipa pointer alias analysis</p>
<p><strong>0x100000</strong>
Enable ipa structure reaggregation optimization</p>
<p><strong>0x200000</strong>
Don’t use cgr_modifies() (optutil.c:is_static_call_safe()).</p>
<p><strong>0x400000</strong>
Disable propagation of certain IPA pointer information from actual arguments
to ..inline temporaries when a call-site is inlined.</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">54:</span></code></dt>
<dd><p class="first">More Flang behavior modification</p>
<p><strong>0x01:</strong>
Enable full Fortran 2003 allocatable attribute regularization</p>
<p><strong>0x02:</strong>
don’t assume assumed-shape arrays are stride 1</p>
<p><strong>0x04:</strong>
No 2003 allocatable assignment semantics for allocatable components</p>
<p><strong>0x08:</strong>
Allocate automatic arrays on the stack instead of the heap by using
an alloca-like method (affects the frontend)</p>
<p><strong>0x10:</strong>
Fortran Back-End only:
Where possible, Implement the alloca-like method by inlining alloca;
otherwise, call our ‘builtin’ alloca routine (affects the backend).
Note that XBIT(54,0x08) must be set.</p>
<p><strong>0x10:</strong>
Fortran Front-End only:
Use pre-F2008 STOP command semantics; do not return integer values
from STOP commands as the program exit status.</p>
<p><strong>0x20:</strong>
Assume that dummy arguments declared EXTERNAL are Fortran routines
that were compiled with Flang.</p>
<p><strong>0x40:</strong>
Enable contiguity pointer checks on pointer assignments and on actual arguments
inside callees.</p>
<p><strong>0x80:</strong>
Enable contiguity pointer checks at call-sites.</p>
<p><strong>0x100:</strong>
Use an alternate contiguity pointer check inline that checks whether the
pointer target’s descriptor flags have __SEQUENTIAL_SECTION set and
whether the object’s data type length match the descriptor’s data type
length. This check is experimental and intended for pointer
assignments and actual arguments inside callees. This check cannot currently
be generated at a call-sites. The XBIT(54, 0x40) must also be enabled. If
XBIT(54, 0x80) is enabled, then we perform the contiguity check at
call-sites using a library routine. Note: In the case of an optional argument,
the inline check will also check whether the argument is present.</p>
<p class="last"><strong>0x200:</strong>
When checking contiguity (using XBIT(54,0x40), XBIT(54,0x80), XBIT(54,0x100)),
do not flag null pointer targets as noncontiguous.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">55:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
AVAILABLE</p>
<p><strong>0x02:</strong>
reserved</p>
<p><strong>0x04:</strong>
AVAILABLE</p>
<p><strong>0x80:</strong>
Don’t call update_shape_info() when assumed-shape array is marked target.</p>
<p><strong>0x100:</strong>
Try to reduce array copies in argument passing</p>
<p><strong>0x200:</strong>
AVAILABLE</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">56:</span></code></dt>
<dd><p class="first">Algebraic transformation; llvect overflow</p>
<p><strong>0x01</strong>
unused</p>
<p><strong>0x02</strong>
Eable the floating-point factoring transformation.</p>
<p><strong>0x04</strong>
Eable the integer factoring transformation.</p>
<p><strong>0x08</strong>
Disallow prefetchnta auto-generation in llvect.c</p>
<p><strong>0x20</strong>
Disable putting term to the end of each group in factoring_tm()
when breaking them into 2 groups to keep them in the same order as
before as much as possible in algetrans.c.</p>
<p><strong>0x40</strong>
This x-flag is set by the command-line option -Mvect=simd:128.  It
restricts vectorisation to a vector length of 128 bits even if the
target processor supports larger vector lengths.</p>
<p><strong>0x80</strong>
Enable multiple outer loop unroll_and_jam.</p>
<p><strong>0x100</strong>
This x-flag is set by the command-line option -Mvect=simd:256.  It
asserts that the target processor supports SIMD instructions with a
vector length of at least 256 bits and restricts vectorisation to 256
bits even if the target processor supports larger vector lengths.</p>
<p><strong>0x200</strong>
Do not replace a scalar expression of the form (+-(a * b) +- c) or
(c +- (a * b)) by a scalar FMA instruction if the product (a * b) has
more than one use.</p>
<p><strong>0x400</strong>
Do not replace a vectorised expression of the form
(+-(a(i) * b(i)) +- c(i)) or (c(i) +- (a(i) * b(i))) by a vector FMA
instruction if the product (a(i) * b(i)) has more than one use.</p>
<p><strong>0x800</strong>
This x-flag is set by the command-line option -Mvect=simd:512.  It
asserts that the target processor supports SIMD instructions with a
vector length of at least 512 bits and restricts vectorisation to 512
bits even if the target processor supports larger vector lengths.</p>
<p class="last"><strong>0x80000000</strong>
If a user-written prefetch inhibits vectorization, do not attempt to replace
its address expression with the address of a matching array reference.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">57:</span></code></dt>
<dd><p class="first">Fortran behavior modification</p>
<p><strong>0x01</strong>
Replace “$” with “_” in symbols occurring within the debug output file.</p>
<p><strong>0x02</strong>
Disallow integer*8/logical*8.</p>
<p><strong>0x04</strong>
Disallow real*16</p>
<p><strong>0x08</strong>
Disallow complex*32.</p>
<p><strong>0x10</strong>
Map REAL*16 and REAL(16) to REAL*8,
and map COMPLEX*32 and COMPLEX(16) to COMPLEX*16.
Map kinded real constants (0.0_16) to appropriate kinded constants (0.0_8)
as appropriate.
Give a warning in each case.</p>
<p><strong>0x20</strong>
For F90, export all symbols from front end to back end, as with -debug,
without creating -debug file.</p>
<p><strong>0x40</strong>
For source to source compiler with F90 output, dollar signs and underscores are
(by default)
disallowed.  Setting this switch allows them (with a warning).</p>
<p><strong>0x80</strong>
When using base/offset (instead of cray pointers), for formal arguments,
don’t use a $bs array, instead use the original variable as the formal argument.
This prevents problems of having a local derived type that is unaligned with
respect to the dummy argument.</p>
<p><strong>0x100</strong>
For native compilers, renumber lines to be sequential as generated.</p>
<p><strong>0x200</strong>
Print “DOUBLE COMPLEX” as “COMPLEX*16” (for Sun’s F90 compiler).</p>
<p><strong>0x400</strong>
Set INHERIT bit for dummy arrays with TARGET attribute that don’t have
explicit distributions.</p>
<p><strong>0x800</strong>
Print -128_1 as (-127_1-1_1), and similarly for _2, _4, _8 types.
This is for some compilers that treat -128_1 as negative 128_1, which overflows.</p>
<p><strong>0x1000</strong>
Print integer*8 with _8 suffix, even if not ‘f90output’.</p>
<p><strong>0x2000</strong>
remove unused variables from source to source output</p>
<p><strong>0x4000</strong>
don’t allow an ac-do-variable to be in limit expression of an implied-do-loop</p>
<p><strong>0x8000</strong>
Don’t replace references to the pghpf_ commons with other values (constants,
static addresses, etc.); e.g., the value of an ‘absent’ argument was
represented by &amp;pghpf_0_; now, it’s just 0.</p>
<p><strong>0x10000</strong>
Don’t generate pghpf_copy_in/copy_out calls for assumed-shape arguments.
Instead, use the descriptors as passed in directly.
For Fortran.</p>
<p><strong>0x20000</strong>
Don’t generate pghpf_ptr_in/ptr_out calls for pointer arguments.
Use the pointer and descriptor as passed in directly.
For Fortran.</p>
<p><strong>0x40000</strong>
For F90, generate pghpf_template/pghpf_instance calls in host subprograms for
all globals and host arrays that MIGHT be used in the subprogram.</p>
<p><strong>0x80000</strong>
Only for F90, pass pointer actual to pointer dummies as the pointer itself,
eliminate the pghpf_ptr_in/pghpf_ptr_out calls in the callee.</p>
<p><strong>0x100000</strong>
For F90,
when passing a continuous section to a subroutine,
don’t call pghpf_sect, instead call _template and build a new template.
This allows the template creation routine call to float out of a loop.</p>
<p><strong>0x200000</strong>
For F90, when passing a section to a subroutine, pass the address of the
first element of the section, not the starting address of the array.
Requires building the right section descriptor.</p>
<p><strong>0x400000</strong>
For F90, don’t try to share section descriptors for arrays,
build a new section descriptor for each array.</p>
<p><strong>0x800000</strong>
Set PDALN field for arrays in module common blocks.</p>
<p><strong>0x1000000</strong>
Do not apply any PDALN (pad &amp; align) values to common block members.</p>
<p><strong>0x2000000</strong>
Don’t perform additional padding beyond PDALN for module common blocks.</p>
<p><strong>0x4000000</strong>
Special code for Rice CAF support.
Recognize pgi_get_descriptor and pgi_set_descriptor functions.</p>
<p><strong>0x8000000</strong>
Do not call lighter-weight alloc/dealloc functions for automatic
arrays, (… hope to expand this list to include compiler-created
allocatable temps …).</p>
<p><strong>0x10000000</strong>
For 32-bit, do not check the PDALN field of module-created commons to
to set their default alignment 16-byte; PDALN is set by module.c (fe90)
and checked in f90’s assem.c</p>
<p><strong>0x20000000</strong>
Do not inline PRESENT.</p>
<p><strong>0x40000000</strong>
in outconv, generate value-arguments to pgf90_template[123]v routines
even for 64-bit compilers</p>
<p class="last"><strong>0x80000000</strong>
Do not make the default for the allocate size argument a 64-bit integer
(64-bit targets only).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">58:</span></code></dt>
<dd><p class="first">Fortran behavior modification</p>
<p><strong>0x01:</strong>
Cray-style POINTERs allowed, but the pointer objects may not
be character (e.g., Cray’s f77 compilers).
Valid only if the output is f77 (-x 49 0x80).</p>
<p><strong>0x02:</strong>
caller mapping, if remapping occurs, caller would have explicit interface.</p>
<p><strong>0x04:</strong>
SERIAL_ONLY directive: the program unit will only be called from
serial regions.</p>
<p><strong>0x08:</strong>
PARALLEL_ONLY directive: the program unit can only be called from
parallel regions.</p>
<p><strong>0x10:</strong>
PARALLEL_AND_SERIAL directive: the program unit can be called from both
parallel and serial regions.</p>
<p><strong>0x20:</strong>
no copy_in and copy_out inside callee.</p>
<p><strong>0x40:</strong>
reserved</p>
<p><strong>0x80:</strong>
Generate shared-memory communications.</p>
<p><strong>0x100:</strong>
Enables CRAFT features.</p>
<p><strong>0x200:</strong>
Create character constants for FORMATs.</p>
<p><strong>0x400:</strong>
ON HOME clause of INDEPENDENT loops cannot be overridden.</p>
<p><strong>0x800:</strong>
is f77 (-x 49 0x80).</p>
<p><strong>0x1000:</strong>
Set if this is an F90 compiler; only extrinsic F90/SERIAL allowed.</p>
<p><strong>0x2000:</strong>
Default extrinsic model is LOCAL</p>
<p><strong>0x4000:</strong>
Default extrinsic model is SERIAL</p>
<p><strong>0x8000:</strong>
Default extrinsic language is F77</p>
<p><strong>0x10000:</strong>
Pass F90 pointer variables through to the back end, I think.</p>
<p><strong>0x20000:</strong>
This is used for the Fortran compiler;
the Fortran compiler allocates temporary arrays (such as for WHERE statements)
to the full size of the aligned array, so the temporary array will be
distributed and aligned to that array.
The Fortran 90 compiler should not do that, and this flag disables that;
when set, temporary array sizes will come from the array shape.</p>
<p><strong>0x40000:</strong>
Cray-style POINTERs allowed, but the pointer objects may not
be derived type (e.g., Cray’s f77 compilers).
Valid only if the output is f77 (-x 49 0x80).</p>
<p><strong>0x80000:</strong>
Fortran - for the compiler-created module commons,
do not prepend an underscore.</p>
<p><strong>0x100000:</strong>
Compiler owned module.</p>
<p><strong>0x200000:</strong>
Revert to previous behavior of including module name in link name of bind(C) routine.</p>
<p><strong>0x400000:</strong>
Don’t make a copy of assumed-shape array arguments if the callee has it marked
as target.</p>
<p><strong>0x800000:</strong>
Don’t attempt to call the descriptor-less read/write I/O function of an array.</p>
<p><strong>0x1000000:</strong>
Disable the use of rhs constant bound for forall loop:-
When converting array assignment to forall if lhs bound is not constant,
check array on rhs if it has constant bound and use to make forall
loop bound.</p>
<p><strong>0x2000000:</strong>
AVAILABLE</p>
<p><strong>0x4000000:</strong>
AVAILABLE</p>
<p><strong>0x8000000:</strong>
For Fortran, don’t expand pointer references with multiply by section stride
and add section offset in each dimension (pointer_squeezer) in fe90;
do perform this in f90 back end</p>
<p><strong>0x10000000:</strong>
used for ??? (outconv.c:convert_output())</p>
<p><strong>0x20000000:</strong>
For Fortran, don’t replace alloc calls with calloc calls
when allocating derived type objecs containing a pointer member.</p>
<p><strong>0x40000000:</strong>
For F90 native, don’t add multiply-by-section-stride
and add-section-offset
requires modified runtime to fold these into the linear offset
and linear stride</p>
<p class="last"><strong>0x80000000:</strong>
When checking if a pointer lhs in a  forall has a scatter dependency, revert
to the old/conservative method where any array used in the lhs’ subscripts
causes a conflict.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">59:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Loop-scope pragmas and directives applied to loops affect all nested loops.</p>
<p><strong>0x02:</strong>
Ignore all pragmas and directives (no message is generated).</p>
<p><strong>0x04:</strong>
Allow the ‘mem’ pragmas/directives.</p>
<p><strong>0x08:</strong>
Allow block statements in the scope of OpenMP and OpenACC directives.</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">60:</span></code></dt>
<dd><p class="first">Used to affect code generation when -debug is used.
Turning all these on will produce code under -debug that
is ‘nearly’ identical to that without -debug.  Especially
valuable for the higher optimization levels.</p>
<p><strong>0x01:</strong>
fill delay slot of delay branch.</p>
<p class="last"><strong>0x02</strong>
do not fill delay slot of delay branch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">61:</span></code></dt>
<dd><p class="first">Used to affect general delay slot filling for sparc.</p>
<p><strong>0x01:</strong>
(DON’T) fill unconditional delay slots (IL_JMP,…)</p>
<p><strong>0x02:</strong>
(DON’T) fill delay slots for ISUBI, BIGTI ..,0  combos</p>
<p><strong>0x04:</strong>
General delay???</p>
<p><strong>0x08:</strong>
used in cgasm.c</p>
<p><strong>0x10:</strong>
used in cgasm.c</p>
<p><strong>0x20:</strong>
used in cgasm.c</p>
<p><strong>0x40:</strong>
used in cgasm.c</p>
<p class="last"><strong>0x80:</strong>
used in cgasm.c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">62</span></code></dt>
<dd><p class="first">General code gen mods</p>
<p><strong>0x01</strong>
Targets of branches can execute multiple instr instead of just 1.</p>
<p><strong>0x02</strong>
Change ICJMPZ into ICMPZ1…ICJMPZ1.</p>
<p><strong>0x04</strong>
Inhibit MAX/MIN optimization whereby the results of the MAX/MIN
are stored directly within ili template.</p>
<p class="last"><strong>0x08:</strong>
Generate position-independent code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">63</span></code></dt>
<dd>Used to pass opt level to CUDA back end code generator.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">64</span></code></dt>
<dd><p class="first">Controls code straightener;
the lower 8 bits are used as a branch probability percentage
(must be between 50 and 100) to be treated as high percentage;
if it is below 50, a compiled-in default is used, and &gt;100 is treated as 100
(essentially disabling straightening).</p>
<p class="last">The rest of the word is used as the minimum block size to try to
straighten out, that is, the block size which is more profitable to
leave in place (perhaps to predicate) that to avoid branching over.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">65</span></code></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">66</span></code></dt>
<dd><p class="first">Used by DSP function expansion, ipa, etc.</p>
<p><strong>0x01:</strong>
Enable expansion of long long intrinsics by dspfunc</p>
<p><strong>0x02:</strong>
Remove constant pointer arguments made redundant via IPA.</p>
<p><strong>0x04:</strong>
Test bit for IPA</p>
<p><strong>0x08:</strong>
Externalize locals or global statics that are used as precise unique
pointer targets, to allow those arguments to be removed.</p>
<p><strong>0x10:</strong>
Remove constant integer arguments made redundant via IPA.</p>
<p><strong>0x20:</strong>
Optimize which arguments get removed:
for st100, don’t remove all pointer arguments, only those in excess of three.</p>
<p><strong>0x40:</strong>
IPA: automatic assign variables to SDA area</p>
<p><strong>0x80:</strong>
IPA: automatic assign variables to TDA area</p>
<p><strong>0x100:</strong>
Internal use only: for DSP user intrinsics, generate table
of instructions that might be matched.</p>
<p><strong>0x200:</strong>
For user-defined intrinsics, prefix __ to name, convert to lower case,
like the DMD intrinsics.</p>
<p><strong>0x400:</strong>
Disable Scalar Replacement optimization (no chains will be generated and
no code generation for accelerator region)</p>
<p><strong>0x1000:</strong>
Use ‘old’ integer array dependence test</p>
<p><strong>0x2000:</strong>
IPA: propagate qalignment to dummy pointers</p>
<p><strong>0x4000:</strong>
Recognize #pragma ipa</p>
<p><strong>0x8000:</strong>
Recognize #pragma ipofile, and halt compile just after parser (used
to create ipofiles for library routines)</p>
<p><strong>0x10000:</strong>
Propagate information about function calls, whether function modifies
globals/statics, etc.</p>
<p><strong>0x20000:</strong>
Propagate user assignments of globals to SDA/TDA.</p>
<p><strong>0x40000:</strong>
reserved</p>
<p><strong>0x80000:</strong>
Use old method in dspfunc to determine whether to assign an intrinsic
argument to a temp variable</p>
<p><strong>0x100000</strong>
For IPA argument removal, don’t actually remove the argument</p>
<p><strong>0x200000</strong>
ST100: For user-defined intrinsic creation, be silent.
X86: when running with #pragma ipofile, prepend a character to the ipofile name.</p>
<p><strong>0x400000</strong>
Instead insert check code to check that the removed argument actually
receives the value that IPA propagates; use with -x 66 0x100000</p>
<p><strong>0x800000</strong>
Don’t rename functions that have arguments removed</p>
<p><strong>0x1000000</strong>
Simple Fortran 90 pointer disambiguation</p>
<p><strong>0x2000000</strong>
allow .xrodata/.yrodata = bank assignment for CONST data</p>
<p><strong>0x4000000</strong>
Fortran 90 assumed-shape dummy argument shape-propagation</p>
<p><strong>0x8000000</strong>
allow RODATA to be placed in SDA/TDA</p>
<p><strong>0x10000000</strong>
Don’t mangle function names</p>
<p><strong>0x20000000</strong>
Use small IPA export protocol.</p>
<p><strong>0x40000000</strong>
datadep.c, disable Fortran based-array conflict addition for unknown base vars</p>
<p class="last"><strong>0x80000000</strong>
Use the ‘optimized’ datatype for a called function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">67:</span></code></dt>
<dd><p class="first">Branch optimizations.</p>
<p><strong>0x01</strong>
Eliminates serially nested redundant conditionals.</p>
<p><strong>0x02</strong>
Performs structure transposition optimization.</p>
<p><strong>0x04</strong>
Performs loop peeling and loop index splitting optimizations.</p>
<p><strong>0x08</strong>
Performs more branch elimination optimization.</p>
<p><strong>0x10</strong>
Disable peephole redundant instruction elimination.</p>
<p><strong>0x20</strong>
Performs structure transposition optimization unconditionally.</p>
<p><strong>0x40</strong>
Performs loop invariant imul strength reduction optimization.</p>
<p><strong>0x80</strong>
Replaces movsd with movlpd in certain loops.</p>
<p><strong>0x100</strong>
Turn off invarif_merge invariant if analysis</p>
<p><strong>0x200</strong>
Performs conditional loop invariant hoisting.</p>
<p class="last"><strong>0x400</strong>
struct transposition - when transpose_struct_ili() recurses for an
AADD, pass the AADD as the parent of its left operands instead
of the AADD’s parent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">68:</span></code></dt>
<dd><p class="first">Multiple language implementation-defined behavior modifications.</p>
<p><strong>0x01</strong>
Assume large arrays: implies that the array bounds information
will be stored as 64-bit integers and subscripts expressions
are 64-bit; also, the macro BIGOBJ must be defined.</p>
<p><strong>0x02</strong>
For large arrays, make the return data type of size, lbound, and
ubound integer*8; the usual return type is default integer.</p>
<p><strong>0x04</strong>
Disable assignment of type descriptor to an allocatable/pointer descriptor.
By default, we will assign a type descriptor to an allocatable/pointer
descriptor for all allocatable/pointer derived type objects. This is required
to support F2003 features. However, if F2003 features are never used
then this XBIT could be used to eliminate an extra assignment when we set
up the allocatable/pointer descriptor. This XBIT will also disable creation
of type descriptors for base types.</p>
<p><strong>0x08</strong>
Automatically put non system and non constant global and static variables
that are not TLS in the TLS or ETLS if the ETLS switch is set.</p>
<p><strong>0x10</strong>
Use ETLS. As a result, it puts threadprivates in ETLS at the ETLS_OMP
level, and it modify the 68,0x08 switch privatization by putting the symbols
auto-privatized at the ETLS_TASK level.</p>
<p><strong>0x20</strong>
Fortran character length for 64-bit target is integer*8 by default.</p>
<p><strong>0x40</strong>
Use TLS to implemement OpenMP threadprivates instead of TP vectors. Has no
effect if the ETLS switch is set.</p>
<p class="last"><strong>0x80</strong>
Allow non-standard F2003 type bound procedure calls of the form z = x%foo
(i.e., assume missing parenthesis as an empty arg list).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">69:</span></code></dt>
<dd><p class="first">SMP implementation-defined behavior modifications.</p>
<p><strong>0x01:</strong>
Don’t recognize OpenMP directives (-Mnoopenmp).</p>
<p><strong>0x02:</strong>
Don’t recognize SGI directives (-Mnosgimp).</p>
<p><strong>0x04:</strong>
For block-static parallel do/for, make the thread’s loop count a multiple
of a value sufficient to keep the alignment of arrays the same as their
alignment when serial.</p>
<p><strong>0x08:</strong>
Default schedule is dynamic (the normal default is static).</p>
<p><strong>0x10:</strong>
Default schedule is guided.</p>
<p><strong>0x20:</strong>
Default schedule is runtime.</p>
<p><strong>0x40:</strong>
P &amp; V functions specifically for unnamed critical sections.</p>
<p><strong>0x80:</strong>
RESERVED for threadprivate-tls work.</p>
<p><strong>0x100:</strong>
Cache align &amp; pad semaphore variables.</p>
<p><strong>0x200:</strong>
Allocate threadprivate data in parallel, i.e., a thread’s copy
will hopefully be local to the thread (call _mp_cdeclp()).</p>
<p><strong>0x400:</strong>
Use the ‘fair’ schedule as the default static schedule for parallel
do loops in pgf90.</p>
<p><strong>0x800:</strong>
linux 64 C++ : revert to .rodata sections, instead of linkonce.r sections for
jump tables in weak(templated) functions</p>
<p><strong>0x1000:</strong>
Disable new OpenMP atomic and reduction implementation.
Currently new OpenMP atomic is enabled with LLVM target only.</p>
<p><strong>0x2000:</strong>
Available</p>
<p><strong>0x4000:</strong>
Available</p>
<p><strong>0x8000:</strong>
Available</p>
<p><strong>0x10000:</strong>
Add trace points for the mp/omp constructs.</p>
<p><strong>0x20000:</strong>
Unconditionally generate prtcnt.</p>
<p><strong>0x40000:</strong>
Execute tasks immediately</p>
<p><strong>0x80000:</strong>
In the outliner used for KPMC openmp regions, when filling the argument</p>
<p class="last"><strong>0x100000:</strong>
Enable nodepchk for simd construct/clause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">70-79:</span></code></dt>
<dd>RESERVED FOR ALTERNATE CODE GENERATION</dd>
<dt><code class="docutils literal notranslate"><span class="pre">70:</span></code></dt>
<dd><p class="first">Used to effect alternate code generation</p>
<p><strong>0x01:</strong>
Generate zero stride check when non-constant stride is used
in the basepointer optimization (opt &gt;= 3)</p>
<p><strong>0x02:</strong>
Check subscripts.</p>
<p><strong>0x04:</strong>
Check null pointers (f90).</p>
<p><strong>0x08</strong>
Linearize arrays, and remove distributed members.</p>
<p><strong>0x10</strong>
Linearize arrays, do not remove distributed members.</p>
<p><strong>0x20</strong>
reserved</p>
<p><strong>0x40</strong>
Don’t call redundant subscript removal - removes common subscript expressions to
temps, floats out of loops, etc.</p>
<p><strong>0x80</strong>
For ST100 -small, generate two versions of each function, one in -gp32, one in
-gp16 (unless disabled for some other reason).</p>
<p><strong>0x100</strong>
For ST100: Disable the H/W Loop check to determine if -small will generate two
versions of the same function. By default, if a H/W loop uses a GP32 only HW
loop (which is anything other than 2) then we only generate this function in
GP32. Enabling this XBIT causes -small to always generate a GP16 and a GP32
version.</p>
<p><strong>0x200</strong>
in redundant subscript removal - also remove redundancies in basic blocks</p>
<p><strong>0x400</strong>
for PGF90, call sectfloat, float section descriptor calls out of loops</p>
<p><strong>0x800</strong>
for PGF90, in sectfloat, floating section descriptor calls out of loops,
also look at non-DO loops</p>
<p><strong>0x1000</strong>
in flow.c, allow constant propagation of HCCSYM symbols</p>
<p><strong>0x2000</strong>
in optimize.c, for PGF90, set -x 70 0x1000 around the call to flow()</p>
<p><strong>0x4000</strong>
in optimize.c, remove empty loops</p>
<p><strong>0x8000</strong>
Generate ‘unified binary’, that is, AMD and Intel binaries in one</p>
<p><strong>0x10000</strong>
Generate ‘self-debugging’ binary, that is, one with -g and no opt, with
with regular options</p>
<p><strong>0x20000</strong>
When generating multiple versions of a function, generate each into a
different .text section.</p>
<p><strong>0x40000</strong>
Use the old unified-binary-version selection method</p>
<p><strong>0x80000</strong>
When generating unified binary, generate two copies of version 1.
(for debugging)</p>
<p><strong>0x100000</strong>
When generating unified binary, generate two copies of version 2.
(for debugging)</p>
<p><strong>0x200000</strong>
When inlining code for F90 sum-like reduction intrinsics,
don’t use a temp if the argument is ‘simple-enough’ to evaluate in-line,
and the DIM argument is one.</p>
<p><strong>0x400000</strong>
When inlining code for F90 sum-like reduction intrinsics,
don’t use a temp if the argument is ‘simple-enough’ to evaluate in-line,
regardless of the DIM argument.</p>
<p><strong>0x1000000</strong>
Don’t expand reductions with expression arguments and DIM=1 inline.</p>
<p><strong>0x2000000</strong>
Don’t bother to fill in the runtime pointer field of the section descriptor,
unless debug set set.</p>
<p><strong>0x4000000</strong>
for F90, in exp_ftn.c, always subtract zbase*size from array base
even if zbase or size is not a constant.
for F90, in func.c, don’t expand complex dot_product inline</p>
<p><strong>0x8000000</strong>
in fe90/redundss.c, don’t remove subscripts from non-pointer arrays</p>
<p><strong>0x10000000</strong>
For unified binary, disable culling</p>
<p><strong>0x40000000</strong>
Enable complex operation; add, subtract, multiply, etc., as a single complex
operation instead operating on 2 parts.</p>
<p class="last"><strong>0x80000000</strong>
WIN DLL target where pgf90 generates indirections for its own
commons which are shared between the run-time and the generated
code; pointers are generated by the compiler and are filled in
upon program startup.
For the MS-method of DLL (the default for hammer as of 6.0), these
commons are simply imported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">71:</span></code></dt>
<dd><p class="first">Used to affect candidate list creation.</p>
<p><strong>0x01:</strong>
Make ili containing frcp appear to have standard latency + 1.</p>
<p><strong>0x02:</strong>
Make ili containing frcp appear to have standard latency + 2.</p>
<p><strong>0x04:</strong>
Make ili containing frcp appear to have standard latency + 4.</p>
<p><strong>0x08:</strong>
Make ili containing frcp appear to have standard latency + 8.</p>
<p class="last"><strong>0x10</strong>
Create breadth first candidate list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">72:</span></code></dt>
<dd><p class="first">Used to affect Scheduling of ili for link predecessors.</p>
<p><strong>0x01:</strong>
Make ili containing frcp appear to have standard latency + 1.
(On the i860, it is frcp; on the SuperSparc it is fpop result).
Enable the dag scheduler for X86_64 &amp; X86_32.</p>
<p><strong>0x02:</strong>
Make ili containing frcp appear to have standard latency + 2.
(X86_64 &amp; X86_32) EM64T heuristic</p>
<p><strong>0x04:</strong>
Make ili containing frcp appear to have standard latency + 4.
(X86_64 &amp; X86_32) EM64T heuristic</p>
<p><strong>0x08:</strong>
Make ili containing frcp appear to have standard latency + 8.</p>
<p class="last"><strong>0x10000:</strong>
(X86_64 &amp; X86_32) Don’t check for profitability.  Presumably,
this flag will be used to rule out performance regressions
due to throttling the scheduler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">73:</span></code></dt>
<dd><p class="first">Used to affect Scheduling of ili for non-link predecessors.</p>
<p><strong>0x01:</strong>
Make ili containing frcp appear to have standard latency + 1.</p>
<p><strong>0x02:</strong>
Make ili containing frcp appear to have standard latency + 2.</p>
<p><strong>0x04:</strong>
Make ili containing frcp appear to have standard latency + 4.</p>
<p class="last"><strong>0x08:</strong>
Make ili containing frcp appear to have standard latency + 8.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">74:</span></code></dt>
<dd><p class="first">Fadd and Fmul handling.</p>
<p><strong>0x01:</strong>
Make stores off of these fadd,dadd,fmul and dmul operations delay
by one more cycle in single-operation mode.  This should allow
another fadd or fmul to begin earlier.</p>
<p class="last"><strong>0x02:</strong>
Allow dualops that take outputs from the fadder and feed the data
into the fmul through a register and not a direct data path.
This caused a problem in DYNA?? and is useful for 33MHz chips.
mi2tpa instruction.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">75:</span></code></dt>
<dd><p class="first">Used for pipelined load selection</p>
<p class="last"><strong>0x01:</strong>
Change the first ldinc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">76:</span></code></dt>
<dd><p class="first">Used to affect scheduling technique</p>
<p><strong>0x01</strong>
Do not use the default scheduling scheme for the Sparc.
Currently (12/27/93), the default is XBIT(83,2) (i.e. psched_ili()).</p>
<p><strong>0x02</strong>
Software Pipeline the instructions.</p>
<p><strong>0x04</strong>
Change LDword to LDSP when possible.</p>
<p class="last"><strong>0x08</strong>
Schedule next ili after last ili scheduled instead of as early as
possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">77:</span></code></dt>
<dd><p class="first">Used to affect preemption and spilling.</p>
<p><strong>0x1:</strong>
Don’t spill constants, just reload.</p>
<p><strong>0x2:</strong>
Turn on expermimental spilling.</p>
<p class="last"><strong>0x4:</strong>
(ST100 only) In a block containing an extended asm statement, any
argument registers (r0-3, p0-2) that are in the asm statement’s
clobber list are removed from the scratch register list.  N.B.: At the
time of writing (11/19/02) this has not been implemented.  Instead an
alternative way of handling clobbered argument registers has been
implemented, namely by preempting them if they are in use, which is
enclosed in the condition “if ( ! XBIT(77,4))”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">78:</span></code></dt>
<dd><p class="first">Used to affect spilling of registers:</p>
<p><strong>0xf:</strong>
Number of ir registers to spill == 0xf (default is 3).</p>
<p><strong>0xf0:</strong>
Number of sp registers to spill == (0xf0 &gt;&gt; 4) (default is 3).</p>
<p><strong>0xf00:</strong>
Number of dp registers to spill == (0xf00 &gt;&gt; 8) (default is 3).</p>
<p class="last"><strong>0xf000:</strong>
used in cgregmgr.c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">79:</span></code></dt>
<dd><p class="first">Used to CSE of a DP load.  This is hardwired at a distance of
16 linear ili.  If you want to CSE always, then just supply a
value of 255.  If you never want to CSE a DP load, then
supply a value of 0.</p>
<p><strong>0x01:</strong>
used in cglinear.c</p>
<p><strong>0x02:</strong>
used in cglinear.c</p>
<p><strong>0x04:</strong>
used in cglinear.c</p>
<p><strong>0x08:</strong>
used in cglinear.c</p>
<p><strong>0x10:</strong>
used in cglinear.c</p>
<p><strong>0x20:</strong>
used in cglinear.c</p>
<p><strong>0x40:</strong>
used in cglinear.c</p>
<p class="last"><strong>0x80:</strong>
used in cglinear.c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">80:</span></code></dt>
<dd><p class="first">Sparc/X86 Versions
First byte reserved for the sparc; second byte reserved for the X86.</p>
<p><strong>0x01:</strong>
Version 8 (has smul, umul, sdiv, udiv instructions + version 7)</p>
<p><strong>0x02:</strong>
Version 7 (has sqrt instr.)</p>
<p><strong>0x04:</strong>
Version 9</p>
<p><strong>0x100:</strong>
P6-only</p>
<p><strong>0x200:</strong>
P6-optimized but doesn’t use P6-only code unless 0x100 set</p>
<p><strong>0x400:</strong>
Following unconditional branch, align code on 16-byte boundary</p>
<p><strong>0x800:</strong>
Don’t generate store-load sequence to round floats before conversion to int.</p>
<p><strong>0x1000:</strong>
Interleave f.p. operations using FXCH; a P5-specific optimization</p>
<p><strong>0x2000:</strong>
Don’t eliminate floating pt. spilling; even right after a fp load from mem.</p>
<p><strong>0x4000:</strong>
Don’t pre-allocate argument space, always push arguments onto stack</p>
<p><strong>0x8000:</strong>
Issue the ‘CLD’ instruction (clears the direction flag, DF) when generating
the rep-movestring instruction sequence.</p>
<p><strong>0x10000:</strong>
Don’t use the standard prolog; use our own variety</p>
<p><strong>0x20000:</strong>
perform a runtime check to assure internal floating point stack consistency;
at the beginning of each routine and after all calls (not QJSR or CCSYM)</p>
<p><strong>0x40000:</strong>
don’t put in argument checking code for sin, cos, and tan</p>
<p><strong>0x80000:</strong>
use .byte instead of fcom and fcmov instructions (for old x86 assemblers)</p>
<p><strong>0x100000:</strong>
disable GH tuning for scalar conversion merge dependencies.</p>
<p><strong>0x200000:</strong>
disable GH tuning to eliminate merge dependencies on movhpd, movlhpx, movhlpx loads.</p>
<p><strong>0x400000:</strong>
AVAILABLE
use cvttsd2si instruction. (Pentium IV specific. Uses opcode in assembly.)</p>
<p><strong>0x800000:</strong>
scalar sse code generation</p>
<p><strong>0x1000000:</strong>
sse4/mni/core2</p>
<p><strong>0x2000000:</strong>
gh</p>
<p><strong>0x4000000:</strong>
sse3/Prescott (pni).</p>
<p><strong>0x8000000:</strong>
AMD x86-32 (hammer-32).</p>
<p><strong>0x10000000:</strong>
AMD x86-64 (hammer).</p>
<p><strong>0x20000000:</strong>
AMD Athlon XP.</p>
<p><strong>0x40000000:</strong>
Willamette (wni)</p>
<p class="last"><strong>0x80000000:</strong>
AMD Athlon.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">81:</span></code></dt>
<dd><p class="first">Sparc chip</p>
<p><strong>0x01:</strong>
Regular Sparc Chip.  This is the default (MT_S)</p>
<p><strong>0x02:</strong>
SuperSparc Chip (MT_SS)</p>
<p><strong>0x03</strong>
HyperSparc Chip (MT_HS)</p>
<p><strong>0x04</strong>
UltraSparc Chip (MT_US)</p>
<p><strong>0x05</strong>
ST100 Chip (MT_STGP32)</p>
<p><strong>0x06</strong>
ST100 Chip (MT_STVLIW)</p>
<p class="last"><strong>0x07</strong>
ST100 Chip (MT_STGP16)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">82:</span></code></dt>
<dd>i860 and Sparc CSE of loads in SW pipelined loops.
If set, then the value set to determines when a load is CSE’d in a software
pipelined loop.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">83:</span></code></dt>
<dd><p class="first">Scheduling technique of Sparc compiler.</p>
<p><strong>0x01</strong>
Use scheduling such that ili are laid down in order determined by candidate list.</p>
<p><strong>0x02</strong>
Use scheduling that uses cyc/subcyc in general but not for register allocation.</p>
<p><strong>0x04</strong>
Use scheduling that uses cyc/subcyc in everwhere even for register allocation.</p>
<p class="last"><strong>0x08</strong>
Schedule next ili after last ili scheduled instead of as early as possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">84:</span></code></dt>
<dd><p class="first">Register allocation scheme of Sparc compiler.</p>
<p><strong>0x01</strong>
Try to release reg exactly on subcycle available.</p>
<p><strong>0x02</strong>
Try to substitute freed up DP reg on cycle needed for new reg.</p>
<p class="last"><strong>0x04</strong>
Suppress optimization of an AADD by not swapping operands.
(cgoptim.c, peep_ar_res)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">85:</span></code></dt>
<dd><p class="first">Affect linearization process:</p>
<p><strong>0x01:</strong>
Do not CSE QJSRs.</p>
<p><strong>0x02:</strong>
used in cglinear.c</p>
<p><strong>0x08:</strong>
Originally this invoked the old version of PRE (partial redundancy
elimination), i.e. function ‘cg_pre()’, but that call has been
commented out since it has been superseded by the new version of PRE,
i.e. function ‘pre_lilis()’.  We should remove all references to this
flag in the compiler.</p>
<p><strong>0x10:</strong>
do value hashing on distributed expressions in PRE.</p>
<p><strong>0x20:</strong>
disable hashing of loads missing data flow info in traditional extended block scope.</p>
<p><strong>0x40:</strong>
signal in PRE phase, desired to be set/unset only by PRE.</p>
<p><strong>0x80:</strong>
disable pattern-match forward propagation in PRE.</p>
<p><strong>0x100:</strong>
do value hashing of loads missing data flow info in tree-region-style extended blocks.</p>
<p><strong>0x200:</strong>
enable most aggressive PRE.</p>
<p><strong>0x400:</strong>
disable the tracking of point register pressure for innermost loops.</p>
<p><strong>0x800</strong>
disable heuristic to avoid force stores.</p>
<p class="last"><strong>0x1000</strong>
Enable ‘peephole0’ phase for x8632/hammer CG;
initially this eliminates or reduces redundant %esp/%rsp updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">86:</span></code></dt>
<dd><p class="first">Reserved for VLIW/DSP compiler usage.</p>
<p><strong>0x1</strong>
Force VLIW/scalar code gen heuristic</p>
<p><strong>0x2</strong>
Allow generation of VLIW code for non-loop regions.</p>
<p class="last"><strong>0x4</strong>
Disable generation of VLIW code for inter-loop regions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">87:</span></code></dt>
<dd><p class="first">Code generation options for DSPs</p>
<p><strong>0x1</strong>
16-bit code generation mode</p>
<p><strong>0x2</strong>
GP32-bit code generation  w/ scheduling  (Default on ST100)</p>
<p><strong>0x4</strong>
VLIW-bit code generation  w/ scheduling</p>
<p><strong>0x8</strong>
reserved</p>
<p><strong>0x10</strong>
reserved</p>
<p><strong>0x20</strong>
reserved</p>
<p><strong>0x40</strong>
reserved</p>
<p><strong>0x80</strong>
reserved</p>
<p><strong>0xNNXX</strong>
NN indicates the memory latency in cycles for the ST100.
Default is 6 on ST100.</p>
<p class="last"><strong>0x100000</strong>
This is used in direct.c to imply that the mode flags flg.x[87] &amp; 0xff
should be inherited; that is, not changed.
Generally this is set for loop directives, not set for global/routine directives</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">88:</span></code></dt>
<dd><p class="first">Predication optimizations</p>
<p><strong>0x01</strong>
Simple control-flow flattening (use predication rather than jumps)</p>
<p><strong>0x02</strong>
Advanced control-flow flattening using APT information.</p>
<p><strong>0x04</strong>
More aggressive predication scheme.</p>
<p><strong>0x08</strong>
Re-compute SLIW legality after predication.</p>
<p class="last"><strong>0x10</strong>
Allow guarded procedure calls.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">89:</span></code></dt>
<dd><p class="first">Advanced optimizations for dsp chips and IPA-related stuff:</p>
<p><strong>0x01</strong>
Enable inlining of DSP functions.</p>
<p><strong>0x02</strong>
Enable IPA analysis.</p>
<p><strong>0x04</strong>
Enable 2nd inlining pass of DSP functions.</p>
<p><strong>0x08</strong>
Stop immediately after IPA analysis (don’t generate assembly file).</p>
<p><strong>0x10</strong>
In IPA collection phase, output all function names, even if not used.</p>
<p><strong>0x20</strong>
Enable ‘fake IPA collection’ mode, whereby IPA information is saved
only for the given functions into a specified .ipo file;
this is used to create IPA info for library functions for which we
have no source.</p>
<p><strong>0x40</strong>
Enable IPA inheritance (This is set for the IPA recompile).</p>
<p><strong>0x80</strong>
Used internally to disable future IPA inheritance; used in case of
errors when inheriting (such as stale .ipa file),
or when the IPA collection is stale.</p>
<p><strong>0x100</strong>
Do IPA pointer disambiguation in cgutil.c/nm_conflict</p>
<p><strong>0x200</strong>
Do IPA pointer disambiguation in cgutil.c/st_sta_ld_conflict</p>
<p><strong>0x400</strong>
Do IPA vestigial function elimination.</p>
<p><strong>0x800</strong>
Do IPA constant propagation.</p>
<p><strong>0x1000</strong>
Do IPA bank assignment.</p>
<p><strong>0x2000</strong>
Do automatic fast/slow mode selection.</p>
<p><strong>0x4000</strong>
Test IPA frequency feedback.</p>
<p><strong>0x8000</strong>
Do IPA driven inlining.</p>
<p><strong>0x10000</strong>
Enable IPA frequency feedback.</p>
<p><strong>0x20000</strong>
Do IPA-driven global register allocation (safe to allocate global to register).</p>
<p><strong>0x40000</strong>
Enable array-of-struct transpose to struct-of-array</p>
<p><strong>0x80000</strong>
For DSP function expansion, use the ‘second’ set of functions.</p>
<p><strong>0x100000</strong>
Enable outliner.</p>
<p><strong>0x200000</strong>
Read .lai file to produce .dsp file.</p>
<p><strong>0x400000</strong>
Read .dsp file for user-defined dsp functions.</p>
<p><strong>0x800000</strong>
Propagate user-assignments of globals to X/Y banks.</p>
<p><strong>0x1000000</strong>
Slim profiler mode.</p>
<p><strong>0x2000000</strong>
Disable extended basic-block creation (more accurate line profiles).</p>
<p><strong>0x4000000</strong>
Do actual replacement of loops in outlining.</p>
<p><strong>0x8000000</strong>
Used for testing of ‘dsplai’ converter.</p>
<p><strong>0x10000000</strong>
Enables IPA constant-range propagation and IF removal</p>
<p><strong>0x20000000</strong>
Enables enhanced safe pointer optimizations using target analysis</p>
<p><strong>0x40000000</strong>
For dsplai, generate .prn file</p>
<p class="last"><strong>0x80000000</strong>
Compress the .ipo file (using lz)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">90:</span></code></dt>
<dd><p class="first">Used to affect candidate list creation.</p>
<p><strong>0x01:</strong>
Make ili containing ptr load appear to have standard latency + 1.
(On the SuperSparc, it is all loads.)</p>
<p><strong>0x02:</strong>
Make ili containing ptr load appear to have standard latency + 2.</p>
<p><strong>0x04:</strong>
Make ili containing ptr load appear to have standard latency + 4.</p>
<p><strong>0x08:</strong>
Make ili containing ptr load appear to have standard latency + 8.</p>
<p><strong>0x10:</strong>
used in cgcand.c</p>
<p class="last"><strong>0x20:</strong>
used in machreg.c for st100</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">91:</span></code></dt>
<dd><p class="first">Used to enable H/Q bug workarounds for ST1xx</p>
<p><strong>0x01:</strong>
Handle CB-15</p>
<p class="last"><strong>0x08:</strong>
Handle CB-4 &amp; CB-10</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">92:</span></code></dt>
<dd><p class="first">CG optimizations.</p>
<p><strong>0x1:</strong>
Do analysis on the candidate list to determine what schema to
use (currently only breadth-first or depth-first selection.</p>
<p><strong>0x2:</strong>
On ST100, disable speculative scheduling.  On hammer and x8632, move
the tail block to the end of the sequence.</p>
<p><strong>0x4</strong>
in sched-dag.c:selectinst(), check for prefetch instructions</p>
<p><strong>0x8:</strong>
Old behavior of sched-dag.c:isRM().</p>
<p><strong>0x10:</strong>
Generate fisst level of LAI output (up to, not including, virtual
registers).</p>
<p><strong>0x20:</strong>
Generate LAI virtual registers (should probably only be used with
92,0x10).</p>
<p><strong>0x80:</strong>
used in cgoptim.c</p>
<p><strong>0x100:</strong>
Omit non LAI-friendly directives (e.g. the .word before a function
for debug info)</p>
<p><strong>0x1000:</strong>
used in cgcand.c</p>
<p><strong>0x2000:</strong>
used in cgcand.c</p>
<p><strong>0x4000:</strong>
used in cglinear.c</p>
<p><strong>0x8000:</strong>
used in cgregmgr.c</p>
<p><strong>0x10000:</strong>
usedin cgsched.c</p>
<p><strong>0x20000:</strong>
used in cgregmgr.c</p>
<p class="last"><strong>0x40000:</strong>
Disable propagate and eliminate sign extensions. Used in cgoptim2.c.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">93:</span></code></dt>
<dd><p class="first">VJS XFLAG for ST100 CG alpha/beta opts.  DO NOT TOUCH unless you’re VJS.</p>
<p><strong>0x01:</strong>
Allow for X Y banked loads.</p>
<p><strong>0x02:</strong>
Allow for new scheduling (MT_STGP32) mode for PL loops at -O3.
This will put it thru ssched_ili32a</p>
<p><strong>0x04:</strong>
Set up 0 load latencies for DR loads inside loops.</p>
<p><strong>0x08:</strong>
Output ‘nop’s into Superscalar assembly code stream even when not needed.
NOP will be inserted upon any empty subcycle.</p>
<p><strong>0x10:</strong>
Set up 0 load latencies for DR outside of loops.</p>
<p><strong>0x20:</strong>
Try scheduling at all opt levels.  Do not drop down to -O2.</p>
<p><strong>0x40:</strong>
Set up 0 store latencies for DR register assigns from the DU unit
and stored.</p>
<p class="last"><strong>0x80</strong>
Change result availability for latest ILI.
On 4/25/01, AIMV and IAMV were changed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">94:</span></code></dt>
<dd><p class="first">Used for new CG pass.</p>
<p class="last"><strong>0x1</strong>
Enable new pass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">95:</span></code></dt>
<dd><p class="first">Used to alter inner resource checking bounds for sparc.</p>
<p><strong>0x1</strong>
Have each ili schedule exactly one cycle after last scheduled ili.
Increments between microps is one full cycle.</p>
<p><strong>0x2</strong>
Each ili microp must schedule within two cycles after last scheduled microp
within the ili but ili must start exactly one cycle after last scheduled ili.
Increments between microps is one subcycle.</p>
<p><strong>0x4</strong>
Each ili microp must schedule within one cycle after last scheduled microp.
ILI can start anytime after early start time.  Increments between microps
is one full cycle.</p>
<p><strong>0x8</strong>
Each ili microp must schedule within one cycles after last scheduled microp.
ILI can start anytime after early start time.  Increments between microps
is one subcycle.</p>
<p><strong>0x10</strong>
Each ili microp must schedule within two cycles after last scheduled microp.
ILI can start anytime after early start time.  Increments between microps
is one subcycle.</p>
<p><strong>0x20</strong>
Each ili microp must schedule within three cycles after last scheduled microp.
ILI can start anytime after early start time.  Increments between microps
is one subcycle.</p>
<p><strong>0x40</strong>
Do not allow a cascade from an alu into the shifter within the same group.</p>
<p class="last"><strong>0x80</strong>
Only split a condition code if it is set as a cascade into an alu.
Otherwise branch can be performed within the same group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">96:</span></code></dt>
<dd><p class="first">Used for scheduling multiple blocks.</p>
<p><strong>0x01:</strong>
Schedule inner loops that form a region with multiple blocks.
Attempt to SW pipeline these loops.</p>
<p class="last"><strong>0x02:</strong>
Generate the multi-column loop even if ‘iteration count’ &lt; ‘swpipe loop columns’.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">97:</span></code></dt>
<dd><p class="first">Used for guards</p>
<p><strong>0x01:</strong>
Force cg to guard ambiguous fp loads following fp stores.
LDINC/STINC only.</p>
<p><strong>0x02:</strong>
Force cg to assume all stores within a SW pipelined loops do not hit cache.</p>
<p class="last"><strong>0x04:</strong>
Force cg to ignore the fact when stores that are marked to miss cache (ILT_MCACHE).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">98:</span></code></dt>
<dd><p class="first">Used for alternate memory accesses.</p>
<p><strong>0x01:</strong>
Force cg to use pipelined stores for fp autoinc stores.</p>
<p class="last"><strong>0x02:</strong>
Force cg to assume all double memory references are aligned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">99:</span></code></dt>
<dd><p class="first">Used for alternate cg IL handling.</p>
<p><strong>0x01:</strong>
Force cg to choose dual-inst at -opt 4</p>
<p><strong>0x02:</strong>
Force cg to choose non-dual-inst at -opt 4</p>
<p><strong>0x04:</strong>
Let cg choose dual-inst at -opt 4</p>
<p><strong>0x08:</strong>
Let cg process .pgi file for alternate cg stuff (pgvision).</p>
<p><strong>0x10:</strong>
Let cg process loop level pragmas for innermost blocks only.</p>
<p><strong>0x20:</strong>
used in cgutil.c</p>
<p><strong>0x40</strong>
used in cgutil.c</p>
<p class="last"><strong>0x80</strong>
used in cgutil.c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">100:</span></code></dt>
<dd>If nonzero, break blocks.
break block if # ilm words for an ili block exceeds
(2 ** (val % 31))</dd>
<dt><code class="docutils literal notranslate"><span class="pre">101:</span></code></dt>
<dd>ST Processor stepping information.  See “stepping.h”</dd>
<dt><code class="docutils literal notranslate"><span class="pre">102:</span></code></dt>
<dd><p class="first">Used to affect cg register handling.</p>
<p><strong>0x01:</strong>
Allow the ARDF of a scratch reg to be freed of the NOUSE flag and put back in list.</p>
<p class="last"><strong>0x02:</strong>
Handle special case of assigning to a DP reg out of an SP that is the same as that
of the DP and whose usecnt is &gt; 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">103:</span></code></dt>
<dd><p class="first">Used to affect cg.</p>
<p><strong>0x01:</strong>
Use alternate FRCP/DRCP ili that leave larger holes.</p>
<p><strong>0x02:</strong>
UNUSED</p>
<p><strong>0x04:</strong>
inhibit IL_ZFSUBFMP code generation.</p>
<p class="last"><strong>0x08:</strong>
change IL_FMLOW to IL_PFMLOW for dualop code code generation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">104:</span></code></dt>
<dd><p class="first">Used to affect names conflict checking (CONFLICT and nm_conflict).</p>
<p><strong>0x01:</strong>
Inhibit check for unequal member names checking.  Just return conflict.</p>
<p><strong>0x02:</strong>
Modify SAFE checking so that distance is always 6 for safe names.</p>
<p><strong>0x04:</strong>
inhibit NME_INLARR() inline array checking.</p>
<p><strong>0x08:</strong>
preform additional checks of inliner-created cray pointees with other
inlined-created cray pointees and user arrays (hlconflict()).</p>
<p><strong>0x10:</strong>
Perform further looking at member symbols that are marked as noconflict.
This is particularly used to determine that regular user symbols can’t
conflict with section descriptor members.</p>
<p><strong>0x20:</strong>
in conflict, Fortran symbols marked as CCSYM will not conflict with a pointer NT_IND
reference; this is unsafe, since even CCSYM symbols may be pointer targets</p>
<p class="last"><strong>0x40:</strong>
Assume a conflict between an ‘unknown’ NME and an NME for a symbol of nonbasic type
(like struct, union, array).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">105:</span></code></dt>
<dd>Used to specify maximum unroll factor in unroll &amp; jam transformation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">106:</span></code></dt>
<dd>Used to specify scalar unroll factor in unroll &amp; jam transformation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">107:</span></code></dt>
<dd>Used to specify loop threshold for entering vectorization</dd>
<dt><code class="docutils literal notranslate"><span class="pre">108:</span></code></dt>
<dd>Used to specify stripmine size for scalar expansion (STRIPSIZE in hlvect.h)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">109:</span></code></dt>
<dd>Used to specify ili count threshold  in br_flatten (ST100)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">110:</span></code></dt>
<dd>Used to affect latency for ‘alu_latency’ sparc resource.
Value is # of cycles + 1 of latency (note: 0 will not work).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">111:</span></code></dt>
<dd>Used to affect latency for ‘fpu_latency’ sparc resource.
Value is # of cycles + 1 of latency (note: 0 will not work).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">112:</span></code></dt>
<dd>Used to affect latency for ‘fdiv_latency’ sparc resource.
Value is # of cycles + 1 of latency (note: 0 will not work).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">113:</span></code></dt>
<dd>Used to affect latency for ‘fld_latency’ sparc resource.
Value is # of cycles + 1 of latency (note: 0 will not work).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">114:</span></code></dt>
<dd>Used to affect latency for ‘ld_latency’ sparc resource.
Value is # of cycles + 1 of latency (note: 0 will not work).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">115:</span></code></dt>
<dd>n from -Minline=levels:n
how many levels of inlining to do</dd>
<dt><code class="docutils literal notranslate"><span class="pre">116:</span></code></dt>
<dd>Used as a value between 0 and 100 to determine whether a function
should execute in fast mode (gp32 for ST100) or slow mode.
Sort the functions by the amount of execution time spent in each on a profiling run.
From fastest to slowest, compute cumulative amount of time spent in this and
more time-consuming functions.
For each function, compute the percent of that cumulative time relative to the total
time of the profiling run.
If this percent is less than the value of the x flag, run in fast mode.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">117:</span></code></dt>
<dd><p class="first">Reserved for C++.</p>
<p><strong>0x01:</strong>
turn off extra C++ debug information when EDG produces C code (–c)</p>
<p><strong>0x02:</strong>
turn on output of mangled names in  C++ debug information: for dolphin inc</p>
<p><strong>0x04:</strong>
Put out TAG_formal_parameter instead of TAG_unspecified_parameters for the this
parameter</p>
<p><strong>0x08</strong>
Turn off the translation of the EDG generated call to  _mp_lcpu3() to
IM_LCPUS3. This is an MP optimization.</p>
<p><strong>0x10</strong>
Turn off a new optimization for –one_instantiation_pre_object
where we don’t read the file scope information for every new template</p>
<p><strong>0x20</strong>
Extract only C++ functions with the inline keyword.
The default is to allow all functions to be inlinable.</p>
<p><strong>0x40</strong>
Turn off the on gnu style inlining in which we mark all non static
member functions as inlinable, even those that are declared outside the
class.</p>
<p><strong>0x80</strong>
turn on ADDRTKN flag setting according to EDG collected information on variable.</p>
<p><strong>0x100</strong>
AVAILABLE
(Formerly indicated setjmp/longjmp style exceptions, which are no
longer supported.)</p>
<p><strong>0x200</strong>
C++ exceptions are enabled.  (Formerly indicated zero-cost exceptions, as
opposed to setjmp/longjmp exceptions.  But zero-cost exceptions are
now the only style of exceptions that are supported.)</p>
<p><strong>0x400</strong>
Disable GSCOPE optimization retarget.  (Does not appear to be used anywhere.)</p>
<p><strong>0x800</strong>
When using the auto-reinliner, treat flg.autoinline as having value 1</p>
<p><strong>0x1000</strong>
Enable the auto-reinliner, that is, inline during the extract phase of
auto-inline.  This allows multiple levels of auto-inlining with a single
inliner pass, since the inlining will have been done during the extract.</p>
<p><strong>0x2000</strong>
Do not generate instrumented profile calls (e.g., prof_ruent, etc.) inside templated functions.</p>
<p><strong>0x4000</strong>
Enable restart for levels-driven bottom-up auto-inlining from the leaves.</p>
<p><strong>0x8000</strong>
AVAILABLE
(Formerly indicated that exceptions had been disabled, but 117,0x200 now
covers that case.)</p>
<p class="last"><strong>0x10000</strong>
Enable bottom-up inlining for -Minline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">118:</span></code></dt>
<dd><p class="first">Reserved for C++.</p>
<p><strong>0x01:</strong>
Force .ctor sections instead of .init sections, as an temporary step for
x86 C++. Hammer C++ already uses .ctor sections.  Win64 does not.</p>
<p><strong>0x02:</strong>
pgc++ is the nvcc host compiler : remove gnu __builtin for  –c</p>
<p class="last"><strong>0x04:</strong>
emit gnu compatible DW.ref sections when -fpic is set.  We don’t turn
this on right now because libpgc.so contains a c++ file, and would
give a gxx_personality undefine .</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">119:</span></code></dt>
<dd><p class="first">Assembler - (NOTE: overflow at 129)</p>
<p><strong>0x01:</strong>
sym+off not allowed in .val for debug (coff)</p>
<p><strong>0x02:</strong>
unix-style (mcount()) profiling (augments -profile); see -x 119 0x40000.</p>
<p><strong>0x04:</strong>
align functions to 32 bytes, rather than 8 bytes.</p>
<p><strong>0x08:</strong>
emit unreferenced data-initialized statics (C).</p>
<p><strong>0x10:</strong>
For i860, misc directive hacks to generate a.out assembly language acceptable
for input to gas i860 assembler (should be an astype) [ temp ].
For i386, (old) linux compatibility mode:
the value placed in the .align directive is used as a power of 2 (number of
low-order zero bits);
fp instructions which pop the stack are suffixed with ‘p’;
.s comment character is ‘#’;’include_next’ is recognized as a synonym for ‘include’.</p>
<p><strong>0x20:</strong>
Place strings in read-only section (C).</p>
<p><strong>0x40:</strong>
Allow repeat counts in data-initializing directives.</p>
<p><strong>0x80:</strong>
efficient SP &amp; DP constants generated in-line.</p>
<p><strong>0x100:</strong>
Compiler-created variables allocated in vcache.</p>
<p><strong>0x200:</strong>
all SP &amp; DP constants generated in-line.</p>
<p><strong>0x400:</strong>
Generate ..sys local symbol (i860).
Generate call to __pgimain() (x86-nt, pgc, pgc++).</p>
<p><strong>0x800:</strong>
Don’t emit definition of __mp_fsr (i860).</p>
<p><strong>0x1000:</strong>
Add leading underscore to external names.</p>
<p><strong>0x2000:</strong>
x86 precision control: -pc 32</p>
<p><strong>0x4000:</strong>
x86 precision control: -pc 64</p>
<p><strong>0x8000:</strong>
x86 precision control: -pc 80</p>
<p><strong>0x10000:</strong>
x86 fp instructions without operands which pop the stack are suffixed with ‘p’.</p>
<p><strong>0x20000:</strong>
x86 ELF .section directive - don’t enclose the name of the section
in quotes (‘”’)</p>
<p><strong>0x40000:</strong>
x86 - Same as mcount profiling, but libcount() is called rather than mcount
(used by SSD to instrument library functions).</p>
<p><strong>0x80000:</strong>
x86 - .lcomm &amp; .comm directives require values to indicate alignment.</p>
<p><strong>0x100000</strong>
Don’t require 8-byte alignment for long long, unsigned long long, integer*8,
and logical*8 data; instead, use 4-byte (int) alignment.
-nodalign affects both double precision and 64-bit integer
data.</p>
<p><strong>0x200000</strong>
Assembly comment character is ‘#’.</p>
<p><strong>0x400000</strong>
No .version directive.</p>
<p><strong>0x800000</strong>
x86 - use .local, .comm directive sequence instead of .lcomm.;  add value
to .comm directive to indicate alignment.</p>
<p><strong>0x1000000</strong>
x86 fortran - Don’t add any trailing underscores</p>
<p><strong>0x2000000</strong>
x86 fortran - add a second trailing underscore if name contains an underscore</p>
<p><strong>0x4000000 :</strong>
Do not append &#64;#bytes to function references for MS standard call
(weird g77 compatibility mode)</p>
<p><strong>0x8000000</strong>
Align stack in prolog of main routine, rather than crt1</p>
<p><strong>0x10000000</strong>
Cache align data sections, e.g., the stack, common blocks.</p>
<p><strong>0x20000000</strong>
Align outermost loops on a 4-byte boundary (pmn. changed from 16)</p>
<p><strong>0x40000000</strong>
Align innermost loops on a 4-byte boundary (pmn. changed from 16)</p>
<p class="last"><strong>0x80000000</strong>
Generate profiliing calls for all loads and stores on x86</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">120:</span></code></dt>
<dd><p class="first">Coff debug information</p>
<p><strong>0x01:</strong>
generate additional symbolic information for pgftn.</p>
<p><strong>0x02:</strong>
???</p>
<p><strong>0x04:</strong>
turn off translation of prototyped function info: P_FUNC is needed to
produce correct debug info for overloaded functions, but may create user
errors.</p>
<p><strong>0x08:</strong>
turn off generation of BASED array stab debug information if stab_sym is
N_LSYM.</p>
<p><strong>0x10:</strong>
For the sparc, stab debug information uses stab 2.0 for the data type entries,
allowing debugging on PGI’s Sun OS 4.x compilers with sunpro’s debugger.
For the x86, generate gnu-style stab debug information.</p>
<p><strong>0x20:</strong>
generate stabs in ELF or COFF object files.</p>
<p><strong>0x40:</strong>
generate C++ debug information for all symbols.  Do not delete according to
the “referenced” flag.</p>
<p><strong>0x80:</strong>
generate dwarf in COFF object files.</p>
<p><strong>0x100</strong>
Print DWARF comments</p>
<p><strong>0x200</strong>
Generate dwarf2 (X86)</p>
<p><strong>0x400</strong>
Do not generate dwarf2 call frame (ST100).
Do not generate xdata/pdata (WIN64).</p>
<p><strong>0x800</strong>
Do not allocate unreferenced variables when generating dwarf1 or dwarf2.</p>
<p><strong>0x1000</strong>
Generate debug lite.</p>
<p><strong>0x2000</strong>
Inhibit dwarf2 generation for fortran block data.</p>
<p><strong>0x4000</strong>
Set the dwarf version to 3.
Emit 4-byte quantity for DW_FORM_ref_addr regardless of the size of
and address on the target machine.</p>
<p><strong>0x8000</strong>
For the DT_AT_upper_bound of a VLA, generate the address of the
compiler-created temp which is assigned the upper bound.  This is
actually incorrect, but needed as a work-around for pgdbg reporting
‘not compiled with -g’ when the correct info is present.
When pgdbg is fixed, remove the use of the XBIT.</p>
<p><strong>0x10000</strong>
Inhibit emission of DW_TAG_imported_declaration DIEs for each used module.</p>
<p><strong>0x20000</strong>
Generate a popsection/previous.</p>
<p><strong>0x40000</strong>
Do not extract the file name from the first line, a # line directive, of a
file when it’s the output of the preprocessor.  If the name is extracted,
it  will be used as the name of the file to be debugged.</p>
<p><strong>0x80000</strong>
Obtain OpenMP thread id using DWARF3 compliant operations (as opposed to using DWARF3 extension DW_OP_PGI_OMP_THREAD_NUM).</p>
<p><strong>0x100000:</strong>
Do not generate attribute DW_AT_MIPS_linkage_name (C++/F90).</p>
<p><strong>0x200000:</strong>
Do not generate .pgi_trace section.</p>
<p><strong>0x400000:</strong>
Do not generate the addressing hacks for common blocks and statically
allocated locals on Mac OS X.</p>
<p><strong>0x800000:</strong>
Do not emit artificial dwarf entries for compiler-created arguments to function/subroutine.</p>
<p><strong>0x1000000</strong>
Set the dwarf version to 4.</p>
<p><strong>0x2000000</strong>
Set the dwarf version to 5.</p>
<p><strong>0x4000000:</strong>
Do not generate include file tables.</p>
<p><strong>0x8000000h</strong>
AVAILABLE</p>
<p><strong>0x10000000:</strong>
Generating eh_frame.</p>
<p><strong>0x20000000:</strong>
Generating eh_frame with .cfi directives: requires 120,0x10000000 to be on</p>
<p><strong>0x40000000</strong>
AVAILABLE</p>
<p class="last"><strong>0x80000000:</strong>
no license check in executable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">121:</span></code></dt>
<dd><p class="first">Linkage modifications</p>
<p><strong>0x01:</strong>
don’t set up frame (only if not debug, alloca(), and varargs)</p>
<p><strong>0x02:</strong>
additional restriction for -x 121 1, no (*p)()</p>
<p><strong>0x04:</strong>
Replace normal calls (JSR all platform and QJSR for ST100) with far calls (JSRFAR).</p>
<p><strong>0x08:</strong>
in use</p>
<p><strong>0x100:</strong>
Do not generate calls to __builtin_stinit() on Windows (when allocating stack)</p>
<p><strong>0x200:</strong>
Use __chkstk instead of __builtin_stinit() on Windows (when allocating stack)</p>
<p><strong>0x400:</strong>
Generate ABI-neutral IL_RETURN for aggregate data types
The expander does generic argument and return value bindings.</p>
<p><strong>0x800:</strong>
Generate ABI-neutral calls (GJSR/GJSRA) – eventually, this will be default
with CUDA &amp; OpenACC</p>
<p><strong>0x10000 :</strong>
WINNT/WIN95 calling conventions are the default for pgf77, pgf90.</p>
<p><strong>0x20000 :</strong>
pgcc, pgCC - for MSCALL defined names, also emit the undecorated entry name.</p>
<p><strong>0x40000 :</strong>
WIN CREF calling conventions for pgf77, pgf90.</p>
<p><strong>0x80000 :</strong>
WIN NOMIXED_STRLENs for pgf77, pgf90 (augments mscall or cref).</p>
<p><strong>0x100000 :</strong>
x86 - return small structs in registers (eax or eax+edx).</p>
<p><strong>0x200000 :</strong>
WIN - use lowercase names for fortran external names.</p>
<p><strong>0x400000 :</strong>
x86 C - return float complex the same as gcc (in registers eax+edx).</p>
<p class="last"><strong>0x8000000 :</strong>
call a check-stack-overflow function to check the per-thread stack size
and perhaps a function’s stack size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">122-127:</span></code></dt>
<dd>RESERVED FOR NON-STANDARD/IMPLEMENTATION-DEFINED BEHAVIOR MODIFICATIONS</dd>
<dt><code class="docutils literal notranslate"><span class="pre">122:</span></code></dt>
<dd><p class="first">C implementation-defined behavior modifications.</p>
<p><strong>0x01:</strong>
Perform a narrowing operation from an int value by sign extending.</p>
<p><strong>0x02:</strong>
implied by -Xs:
K&amp;R</p>
<p><strong>0x04:</strong>
long long, unsigned long long</p>
<p><strong>0x08:</strong>
treat extern and static data as volatile</p>
<p><strong>0x10:</strong>
treat plain char as unsigned char; the default is signed char.</p>
<p><strong>0x20:</strong>
treat long as int and unsigned long as unsigned int.</p>
<p><strong>0x40:</strong>
Allow the GNU-defined __signed__ keyword as a synonym for signed (unless
in strict ansi mode).</p>
<p><strong>0x80:</strong>
Use alternate builtin functions for arithmetic operations (e.g., integer divide).</p>
<p><strong>0x100:</strong>
ST100 - Disable enhanced jump table method for switch statements.</p>
<p><strong>0x200:</strong>
ST100 - Disable non-conservative approach in all enhanced switch statements (applies to enhanced jump table method and constant time method).</p>
<p><strong>0x400:</strong>
ST100 - Disable enhanced inline jump table method for switch statements (a.k.a. the constant time method).</p>
<p><strong>0x800:</strong>
ST100 - Disable copya elimination enhancement in constant time switch method.</p>
<p><strong>0x1000:</strong>
ST100 - Disable use of multiple guards in constant time switch method.</p>
<p><strong>0x2000:</strong>
nonST100 - For a use of a store ILM, don’t attempt to refer to the
result as a load of the left-hand side; instead, refer to the result
as a cse of the right-hand side.  Someday, will want uses of store ILMs
to be consistent across targets.</p>
<p><strong>0x4000:</strong>
allow narrow int arguments in a prototyped function declaration to be
compatible with int arguments in an old-style function definition.</p>
<p><strong>0x8000:</strong>
for “bug compatibility”, revert to alignment used in previous releases
for certain structures containing long integers and int bit fields that
cross 2-byte boundaries.</p>
<p><strong>0x10000:</strong>
Output C macro definitions as they are encountered.</p>
<p><strong>0x20000:</strong>
Output C #include definitions as they are encountered</p>
<p><strong>0x40000:</strong>
Output C macro definitions for predefined macros.</p>
<p><strong>0x80000:</strong>
When outputting macro definitions, do NOT include the definitions.</p>
<p><strong>0x100000:</strong>
Emit warnings when invoking prototype-less functions.</p>
<p><strong>0x200000:</strong>
Drop limit on the maximum length of a line generated after preprocessing
(‘cpp’ mode).</p>
<p><strong>0x400000:</strong>
C11</p>
<p><strong>0x800000:</strong>
AVAILABLE</p>
<p><strong>0x1000000:</strong>
AVAILABLE</p>
<p><strong>0x2000000:</strong>
AVAILABLE</p>
<p><strong>0x4000000:</strong>
AVAILABLE</p>
<p><strong>0x8000000:</strong>
AVAILABLE</p>
<p><strong>0x10000000:</strong>
AVAILABLE</p>
<p><strong>0x20000000:</strong>
AVAILABLE</p>
<p><strong>0x40000000:</strong>
AVAILABLE</p>
<p class="last"><strong>0x80000000:</strong>
temporary, 03/25/2010 (I hope) - at the center of fixing 16741, ST_UNKNOWNs
are created immediately for formal arguments; however, this has the effect
of ‘hiding’ previously declared variables which semant has to deal with.
Just in case a regression occurs in the field, this XBIT says don’t create
ST_UNKNOWNs (yes, f16741 will then fail).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">123:</span></code></dt>
<dd><p class="first">C implementation-defined behavior modifications (cont).</p>
<p><strong>0x01:</strong>
preprocessor passes comments thru (also implies -es); driver option -C</p>
<p><strong>0x02:</strong>
preprocessor generates makefile information to stdout; driver option -M</p>
<p><strong>0x04:</strong>
preprocessor allows C++ style comments; driver option -B</p>
<p><strong>0x08:</strong>
preprocessor generates makefile information to &lt;program.d&gt;; driver option -MD</p>
<p><strong>0x10:</strong>
implied by -Xa:
att cc compatibility; default value of __STDC__ is 0
and XBIT(123,0x100) is set.</p>
<p><strong>0x20:</strong>
preprocessor does not separate tokens with spaces.</p>
<p><strong>0x40:</strong>
preprocessor performs macro replacement within character constants and strings</p>
<p><strong>0x80:</strong>
implied by -Xt:
k&amp;r compatibility plus transitional msgs.</p>
<p><strong>0x100:</strong>
implied by -Xc (C):
strict Ansi conformance (C); default value of __STDC__ is 1 and
XBIT(123,0x10) is not set.
For fortran, don’t emit the #line directives,</p>
<p><strong>0x200:</strong>
preprocessor suppresses whitespace between tokens that are OUTSIDE of
macro bodies.  Whitespace is still added between tokens that are
in macro bodies.</p>
<p><strong>0x400:</strong>
Don’t alter optimizations when generating debugging information.
For example, if this bit is set, inhibit generating the lexical block
debugging information by semant.</p>
<p><strong>0x800</strong>
Don’t collapse whitespace (‘cpp’ mode)</p>
<p><strong>0x1000</strong>
C preprocessor - allow gcc’s preprocessor extensions: #include_next,
#warning, arg … (vararg function macros), CPATH, C_INCLUDE_PATH, etc.</p>
<p><strong>0x2000</strong>
C preprocessor - expand macros within #pragma lines</p>
<p><strong>0x4000:</strong>
preprocessor ignores system files (&lt;a.h&gt;) when generating makefile information
either to stdout (123 2) or file.d (123 8); only quoted files are handled.</p>
<p><strong>0x8000:</strong>
Do not check the first preprocessing token after #pragma to determine
if macro replacement is to be performed for the #pragma line; normally,
macro replace will occur in the line if the token “omp”, “acc”, or “pgi”.</p>
<p><strong>0x10000:</strong>
F90: print out .mod files needed to compile this file to stdout</p>
<p><strong>0x20000:</strong>
F90: print out .mod files needed to compile this file to filename.m</p>
<p><strong>0x40000:</strong>
PVF build dependencies.</p>
<p><strong>0x80000:</strong>
Keep blank lines … for -Mcpp switch</p>
<p><strong>0x100000:</strong>
When preprocesing,  $ is not allowed in an identifier.</p>
<p><strong>0x200000:</strong>
When preprocessing assembly file, unrecognized # directives are just text.</p>
<p><strong>0x400000:</strong>
Don’t check definition of __STDC__</p>
<p><strong>0x800000:</strong>
Don’t attempt to distinguish include files as system header files</p>
<p><strong>0x1000000</strong>
Don’t issue messages for extra tokens for line directives, as produced by gcc preprocessor.</p>
<p><strong>0x2000000</strong>
Don’t terminate the expansion of the _Pragma preprocessor operator with
a newline (i.e., the old behavior)</p>
<p><strong>0x4000000</strong>
Use the legacy Fortran preprocessor (fpp), and not the ANSI-C99 preprocessor.</p>
<p><strong>0x8000000</strong>
Preprocessor puts out dependence lines to gbl.cppfil instead of file.d or stdout</p>
<p><strong>0x10000000</strong>
Unused.</p>
<p><strong>0x20000000</strong>
preprocessor generates makefile information to stdout; driver option -MT</p>
<p><strong>0x40000000</strong>
preprocessor generates makefile information to stdout; driver option -MQ</p>
<p class="last"><strong>0x80000000</strong>
C9X</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">124:</span></code></dt>
<dd><p class="first">F77 implementation-defined behavior modifications.</p>
<p><strong>0x01:</strong>
Perform a narrowing operation from an int value by sign extending.</p>
<p><strong>0x02:</strong>
pack common blocks and structures (not impl.)</p>
<p><strong>0x04:</strong>
treat unit ‘*’ as stdin if read, stdout if write</p>
<p><strong>0x08:</strong>
treat REAL as DOUBLEPRECISION and COMPLEX as DOUBLECOMPLEX
(also applies to real/complex constants)</p>
<p><strong>0x10:</strong>
treat INTEGER as INTEGER*8 and LOGICAL as LOGICAL*8</p>
<p><strong>0x20:</strong>
treat the intrinsics REAL and CMPLX as DBLE and DCMPLX (obsolete in Fortran).</p>
<p><strong>0x40:</strong>
treat backslash as an ordinary character (no escape sequences)</p>
<p><strong>0x80:</strong>
don’t marked data initialized locals as SAVEd (not impl.)</p>
<p><strong>0x100:</strong>
enable cexe$ lines</p>
<p><strong>0x200:</strong>
inhibit expanding x**c, 1&lt;=c&lt;=__MAXPOW (10), to a sequence of multiplies</p>
<p><strong>0x400:</strong>
64 bits of precision for integer*8 and logical*8 operations.</p>
<p><strong>0x800:</strong>
Perform hardcoded register allocation in CG</p>
<p><strong>0x1000:</strong>
Emit references to unreferenced EXTERNALs.
This flag implies that global directives will be issued; for an actual
reference, -x 124 0x4000, must also be present.</p>
<p><strong>0x2000:</strong>
AVAILABLE</p>
<p><strong>0x4000</strong>
Emit an actual reference to unreferenced EXTERNALs; -x 124 0x1000 must also
be present.</p>
<p><strong>0x8000</strong>
Null-terminate character literals.</p>
<p><strong>0x10000</strong>
The preprocessor behaves like cpp; for example, a function-like macro is
expanded whenever the name appears irrespective of the presence of actual
arguments.</p>
<p><strong>0x20000</strong>
Change the level of the “has not been explicitly declared” error (#38)
from severe to warning (f77, f90).</p>
<p><strong>0x40000</strong>
Inhibit transforming x**c into x**i, where c is the integer i expressed as
a real or double constant.</p>
<p><strong>0x80000</strong>
Expand the list of real intrinsics to be treated as double to include
float, TBD.</p>
<p><strong>0x100000</strong>
Preprocessor - skip over fortran comments (e.g., don’t expand macros
in comments, etc.).</p>
<p class="last"><strong>0x200000</strong>
Preprocessor - ‘pgi’ is no longer defined by default (f15141); define
pgi iff -Mx,124,0x200000 is set (just in case)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">125:</span></code></dt>
<dd><p class="first">F77 implementation-defined behavior modifications (cont).</p>
<p><strong>0x01:</strong>
treat an i/o statement as a critical section.</p>
<p><strong>0x02:</strong>
byte-swapped unformatted i/o</p>
<p><strong>0x04:</strong>
Treat all EUC characters as a single column position for Hollerith,
source line length.</p>
<p><strong>0x08:</strong>
When testing logical values, treat zero as false and non-zero as true
instead of odd and even, respectively.</p>
<p><strong>0x10:</strong>
Print error messages in Kanji.</p>
<p><strong>0x20:</strong>
Allocatable commons are allocated just once (can use precise names
entries).</p>
<p><strong>0x40:</strong>
Use Cray’s ‘no conflict’ semantics for references via pointers; expander
generates precise NMEs for references of pointer-based objects.</p>
<p><strong>0x80:</strong>
Allow implicit statements after specification statements.</p>
<p><strong>0x100:</strong>
The bounds of pointer-based arrays are precise; normally, it’s assumed that
the last dimension is not valid even if it’s a constant.</p>
<p><strong>0x200:</strong>
Assume varargs callee (hammer)</p>
<p><strong>0x400:</strong>
For f90 array pointers, don’t attempt to multiply the subscript by the
section stride and add in the section offset (don’t set ptrexpand).</p>
<p><strong>0x800:</strong>
Don’t replace calling …str_cpy1 with a  ‘block move’.</p>
<p><strong>0x1000:</strong>
When replacing …str_cpy2 with a ‘block move’ and the rhs is a shorter
constant, create a new constant completely paded with blanks. Normally,
the new constant is a multiple of 8 (64-bit ) or 4 (32-bit).</p>
<p><strong>0x2000</strong>
For F90, use TY_PTR for f90 pointers instead of Cray pointer integer types</p>
<p><strong>0x4000</strong>
When expanding a subscript expression for non-pointer arrays, do not attempt
to move the first subscript when constant into the zbase computation.</p>
<p><strong>0x8000</strong>
When expanding a subscript expression for pointer arrays, do not attempt
to move the first subscript when constant into the zbase computation.</p>
<p><strong>0x10000</strong>
I was experimenting with a different way to expand array subscripts,
and that’s controlled here.</p>
<p><strong>0x20000</strong>
Use 64-bit subscripting (ALSO for C)</p>
<p><strong>0x40000</strong>
Pass string lengths as ‘int’ (not as the target’s size_t)</p>
<p><strong>0x80000</strong>
-Mcontiguous (fortran front-end and back-end)</p>
<p class="last"><strong>0x100000</strong>
-Mnovariadic_macros (-Mvariadic_macros is the default and is used to augment the -c89 switch when we need to turn them back on )</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">126:</span></code></dt>
<dd>FTN keyword extensions</dd>
<dt><code class="docutils literal notranslate"><span class="pre">127:</span></code></dt>
<dd><p class="first">C keyword extensions</p>
<p><strong>0x01:</strong>
asm</p>
<p><strong>0x02:</strong>
volatile (backend handling)</p>
<p><strong>0x04:</strong>
gcc keywords - __attribute__, … (see semant.c)</p>
<p><strong>0x08:</strong>
ghs keywords - __inline, … (see semant.c)</p>
<p><strong>0x10:</strong>
gcc compatible asm (see semant.c); incompatible with 127,1</p>
<p class="last"><strong>0x20:</strong>
disable built-in __m128, __m128d, __m128i, __m256, __m256d, __m256i  data types</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">128:</span></code></dt>
<dd><p class="first">LAI/LAO extensions</p>
<p><strong>0x01:</strong>
Enable basic LAI output by inhibiting harmful directives.</p>
<p><strong>0x02:</strong>
Enable Virtual Register output.</p>
<p><strong>0x04:</strong>
Inhibit push/pop sequence; emit .sliw - .ends; emit .leave</p>
<p><strong>0x08:</strong>
Enable .livein/.liveout directives.</p>
<p><strong>0x10:</strong>
Enable .proto and .loopinfo directives.</p>
<p class="last"><strong>0x20:</strong>
Enable LAO defect workarounds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">129:</span></code></dt>
<dd><p class="first">Assembler - (NOTE: overflow from 119:)</p>
<p><strong>0x01:</strong>
don’t put out profiling line entry calls for lineno:0</p>
<p><strong>0x02:</strong>
x86/assem.c  Set sse flush to zero mode.</p>
<p><strong>0x04:</strong>
x86/assem.c  Set sse denorms are zero mode.</p>
<p><strong>0x08:</strong>
x86/assem.c  Align smaller than  size_of(int) auto vars on int boundary.</p>
<p><strong>0x10:</strong>
Generate %rip-relative addressing on WIN64.</p>
<p><strong>0x20:</strong>
Unified binary - generate test/jump in reverse order in stub</p>
<p><strong>0x40:</strong>
Unified binary - generate stub between the two versions, not after both</p>
<p><strong>0x80:</strong>
x86 - .lcomm (not .comm) directives require values to indicate alignment.</p>
<p><strong>0x100:</strong>
Allow 16-byte misaligned memory operands in vector arithmetic instructions
and maximize the usage of memory operands in vector arithmetic instructions.</p>
<p><strong>0x200:</strong>
No special startup/initialization for main().</p>
<p><strong>0x400:</strong>
x86/assem.c  Don’t set sse denorms to zero mode
We need this negative flag because the -tp type sometimes sets the mode</p>
<p><strong>0x800:</strong>
hammer  - -Mprof=instrument:functions – same as -Mprof=func, but
call instent64/instret64</p>
<p><strong>0x1000:</strong>
Disable 32-byte stack alignment.  Note that this only applies to AVX
targets, since 32-byte stack alignment is not used for non-AVX targets.</p>
<p><strong>0x2000:</strong>
The stack is kept 16-byte aligned for 32-bit Linux per the OSX abi.
When XBIT(129,0x2000) is set, allow legacy callers in which case we can
only emit unaligned 16-byte moves.</p>
<p><strong>0x4000:</strong>
x86/assem.c: don’t set sse denorms to zero mode
This is used with -Mnodaz; for x86 processors, the default is target CPU
specific, this overrides the CPU-specific default.</p>
<p><strong>0x8000:</strong></p>
<p><strong>0x10000:</strong>
Use .align 8 at the function entry (hammer).</p>
<p><strong>0x20000:</strong>
Don’t align the function entry (hammer).</p>
<p><strong>0x40000:</strong></p>
<p><strong>0x80000:</strong></p>
<p><strong>0x100000:</strong>
Inhibit writing .ident info to assembly file.</p>
<p><strong>0x200000:</strong>
Sun assembler syntax for amd64:
Assembly comment character is ‘/’;
movdq instead of movd.</p>
<p><strong>0x400000:</strong>
Don’t add a second ‘#’ to the comment char (when XBIT(119,0x10) or
XBIT(119,0x200000).</p>
<p><strong>0x800000:</strong>
Including comments for floating point constants has become a compile-time
problem since the cost of converting the fp representation to
ascii can be relatively high.  Do not emit the values of fp constants
in comments unless this XBIT is used.</p>
<p><strong>0x1000000:</strong>
use 16 byte alignment for stack data less than 16 bytes on x64</p>
<p><strong>0x2000000:</strong>
Don’t place constants in a read-only section.
The default is to not protect constants.</p>
<p><strong>0x4000000:</strong></p>
<p><strong>0x8000000:</strong></p>
<p><strong>0x10000000:</strong>
The present of -Msmartalloc=huge; note that the value , in
-Msmartalloc=huge:n  is passed via flg.x[156].</p>
<p><strong>0x20000000:</strong>
mallopt secret</p>
<p><strong>0x40000000:</strong>
Hammer - 64-byte (cache) alignment and padding
for locals (bss) 64 bytes or larger.</p>
<p class="last"><strong>0x80000000:</strong>
ST100 - when placing objects in the small data/bss sections, use
use the minimum alignment rule, i.e., the possible sections are
.s[bss|data][1|2|4]. The default is to only use .sbss1/.sdata1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">130:</span></code></dt>
<dd>VLIW levels.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">131:</span></code></dt>
<dd>Predication levels.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">132:</span></code></dt>
<dd><p class="first">ST100 local register allocation.</p>
<p><strong>0x1:</strong>
Use the static local register allocator (-Mregalloc=static) for GP32
and SLIW code.</p>
<p><strong>0x4:</strong>
Use the optimized local register allocator and re-allocator, also
known as the `holes’ register allocator (HRA), for GP32 and SLIW code.
This is incompatible with -Mregalloc=static, i.e. with XBIT(132,
0x19).  If any of the latter flags are set they take precedence and
the HRA is disabled.</p>
<p><strong>0x8:</strong>
Use -Mregalloc=static only for GP32 code.</p>
<p><strong>0x10:</strong>
Use -Mregalloc=static only for SLIW code.  Currently (11/19/02) this
is not supported.</p>
<p><strong>0x20:</strong>
Use the HRA only for GP32 code.  This may be combined with the use of
-Mregalloc=static for SLIW code, i.e. XBIT(132, 0x10), but not for
GP32 code, i.e. XBIT(132, 9).  If either of the latter flags are set
they take precedence and the HRA is disabled.</p>
<p class="last"><strong>0x40:</strong>
Use the HRA only for SLIW code.  This may be combined with the use of
-Mregalloc=static for GP32 code, i.e. XBIT(132, 8), but not for SLIW
code, i.e. XBIT(132, 0x11).  If either of the latter flags are set
they take precedence and the HRA is disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">133:</span></code></dt>
<dd>A number n where 0 &gt;= n  &amp;&amp; n &lt;= 40.  This gives the density threshold
for SLIW scheduling on the ST100.  Thus, if one uses ‘20’ for the value,
the density would be 20.0/10.0, or 2.0 instructions/bundle.  The
threshold is open, so in the case of a 2.0 inst/bundle threshold, there must
be more than 2.0 inst/bundle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">134:</span></code></dt>
<dd>Hammer/X8632 CG reg stall values
The GP stall limit is the bottom nibble; the next nibble is the
smm stall limit (see cgopt2rg.c)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">135:</span></code></dt>
<dd><p class="first">Hammer CG.  (NOTE: continued at 164)</p>
<p><strong>0x1:</strong>
-mcmodel=medium</p>
<p><strong>0x2:</strong>
DOCUMENT</p>
<p><strong>0x4:</strong>
DOCUMENT</p>
<p><strong>0x8:</strong>
DOCUMENT</p>
<p><strong>0x10:</strong>
DOCUMENT</p>
<p><strong>0x20:</strong>
DOCUMENT</p>
<p><strong>0x40:</strong>
DOCUMENT</p>
<p><strong>0x80:</strong>
skip move exit code</p>
<p><strong>0x100</strong>
use PUSH/POP for callee-save GP regs in entry/exit code</p>
<p><strong>0x200</strong>
cgoptim2.c:cg_global_opts() - such as -Mdse</p>
<p><strong>0x400</strong>
use PUSH/POP for callee-save GP regs in entry/exit code</p>
<p><strong>0x800:</strong>
no .p2align for labels of non-innermost loops (see xflag 155 for altering
the .p2align values).</p>
<p><strong>0x1000:</strong>
AVAILABLE</p>
<p><strong>0x2000:</strong>
.align 16 before loop; no .align after jmp
<strong>0x4000:</strong>
.align 8 before loop; no .align after jmp
<strong>0x8000:</strong>
no align before loop; no .align after jmp</p>
<p><strong>0x10000:</strong>
no align after jmp</p>
<p><strong>0x20000:</strong>
allow coalescing of register-to-register moves of different sizes.</p>
<p><strong>0x40000:</strong>
disable two byte return for branch-to-ret scenario</p>
<p><strong>0x80000:</strong>
DOCUMENT</p>
<p><strong>0x100000:</strong>
Force OPT1 regalloc method</p>
<p><strong>0x400000:</strong>
Enable 32B loop alignment for GH.  (!)</p>
<p><strong>0x800000:</strong>
Enable ‘tregion’ CSE.</p>
<p><strong>0x1000000:</strong>
DOCUMENT</p>
<p><strong>0x2000000:</strong>
DOCUMENT</p>
<p><strong>0x4000000:</strong>
DOCUMENT</p>
<p><strong>0x8000000:</strong>
DOCUMENT</p>
<p><strong>0x10000000:</strong>
DOCUMENT</p>
<p><strong>0x20000000:</strong>
DOCUMENT</p>
<p><strong>0x40000000:</strong>
enables experimental enhancements to CSE elimination.  See also
-Mx,145, 146 and 147.</p>
<p class="last"><strong>0x80000000:</strong>
enables Steve Christiansen’s experimental enhancement to CSE
elimination.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">136:</span></code></dt>
<dd><p class="first">Branch prediction and optimizations</p>
<p><strong>0x1:</strong>
Enable static branch prediction</p>
<p><strong>0x2:</strong></p>
<p><strong>0x4:</strong></p>
<p><strong>0x8:</strong></p>
<p><strong>0x10:</strong>
Enable return heuristic</p>
<p><strong>0x20:</strong>
Enable call heuristic</p>
<p><strong>0x40:</strong>
Enable guard heuristic</p>
<p><strong>0x80:</strong>
Enable opcode heuristic</p>
<p><strong>0x100:</strong>
Enable pointer compare heuristic</p>
<p><strong>0x200:</strong>
Enable loop heuristic</p>
<p><strong>0x400:</strong>
Disable exit heuristic</p>
<p><strong>0x800:</strong>
Disable eh (exception handling) heuristic</p>
<p><strong>0x2000:</strong>
A compilation-time efficient block position implementation.</p>
<p><strong>0x4000:</strong>
Use edge frequencies to guide merging sequences in the block position final
phase.</p>
<p><strong>0x10000:</strong>
Region-based (allowing small hammack regions, instead of pure trace-based)
code layout.</p>
<p><strong>0x40000:</strong>
Skip dynamic code layout if the number of edges without matched edge counts
is over a threshold.</p>
<p class="last"><strong>0x80000:</strong>
Experiment with code layout with C++ –zc_eh.  The brpred.c blkcnt threshold
is set to MAX_BLOCKS rather than 500.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">137:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Enable CUDA C++ and Fortran parsing.</p>
<p><strong>0x02:</strong>
Enable CUDA Fortran emulation.</p>
<p><strong>0x04:</strong>
CUDA Fortran old/new calls to global routines.</p>
<p><strong>0x08:</strong>
Disable CUDA Fortran parallel task creation for emulation.</p>
<p><strong>0x10:</strong>
Enable CUDA Fortran automatic USE of cudadevice.mod in device routines.</p>
<p><strong>0x20:</strong>
Enable inlining of pgf90_lba and pgf90_uba even if not in device code.</p>
<p><strong>0x40:</strong>
Put the device array descriptor into constant memory.  Perf optimization.</p>
<p><strong>0x100:</strong>
Enable CUDA X86 back end code generation.</p>
<p><strong>0x200:</strong>
allow automatic shared arrays</p>
<p><strong>0x400:</strong>
Don’t use optimized CUDA X86 back end</p>
<p><strong>0x800:</strong>
Do use optimized CUDA X86 back end, even at opt 0 or 1</p>
<p><strong>0x1000:</strong>
Temporarily, use kernel optimization in F90</p>
<p><strong>0x2000:</strong>
Imply MANAGED for all ALLOCATABLE objects in F90</p>
<p><strong>0x4000:</strong>
Don’t put managed variable array descriptors in constant memory</p>
<p><strong>0x8000:</strong>
Allow character strings in CUDA Fortran</p>
<p><strong>0x10000:</strong>
Allow some formatted print statements in CUDA Fortran, EXPERIMENTAL</p>
<p><strong>0x20000:</strong>
Don’t allow statements between the DO loops of a cuf kernels do construct</p>
<p><strong>0x40000:</strong>
reserved</p>
<p><strong>0x80000:</strong>
reserved</p>
<p><strong>0x100000:</strong>
reserved</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">138:</span></code></dt>
<dd>vect prefetch limit</dd>
<dt><code class="docutils literal notranslate"><span class="pre">139:</span></code></dt>
<dd>single precision SSE size limit</dd>
<dt><code class="docutils literal notranslate"><span class="pre">140:</span></code></dt>
<dd>single precision SSE size limit</dd>
<dt><code class="docutils literal notranslate"><span class="pre">141:</span></code></dt>
<dd>iteration count passed to llvect</dd>
<dt><code class="docutils literal notranslate"><span class="pre">142:</span></code></dt>
<dd>vect prefetch distance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">143:</span></code></dt>
<dd>iteration limit for use of non-temporal stores</dd>
<dt><code class="docutils literal notranslate"><span class="pre">144:</span></code></dt>
<dd>Limit on number of non-temporal stores to use per loop
(currently 1 for amd and 2 for intel targets).</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">145:</span></code></p>
<blockquote>
<div><p><strong>0x1:</strong>
Enable static and inline unreferenced functions removal (LX-only for now).</p>
<p>(Temporary, for hammer only): if -Mx,135,0x40000000 is specified and
(opt &gt;= 2), then a non-zero value for -Mx,145 gives the maximum live
range for constant CSEs.  By default their maximum live range is
calculated in the same way as for other types of CSE.</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">146:</span></code></dt>
<dd>(Temporary, for hammer only): a tuning parameter for CSE elimination
at (opt &gt;= 2).  If either flg.x[146] or flg.x[147] is non-zero the
maximum CSE live range is given by (flg.x[146] + (flg.x[147] *
n_nodes_ilitree( ili ))), otherwise it is 170.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">147:</span></code></dt>
<dd>(Temporary, for hammer only): a tuning parameter for CSE elimination
at (opt &gt;= 2).  If either flg.x[146] or flg.x[147] is non-zero the
maximum CSE live range is given by (flg.x[146] + (flg.x[147] *
n_nodes_ilitree( ili ))), otherwise it is 170.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">148:</span></code></dt>
<dd><p class="first">Options for controlling collection and use of data for PFO.</p>
<p><strong>0x1:</strong>
Enable collection of information</p>
<p><strong>0x2:</strong>
Disable collection of edge information</p>
<p><strong>0x4:</strong>
Disable collection of value information</p>
<p><strong>0x8:</strong>
Use Min-MST form of edge instrumentation</p>
<p><strong>0x10:</strong>
Output BIH numbers instead of FG numbers for (src, dst) of EFCs.</p>
<p><strong>0x20:</strong>
The PFI_LONG members of the PFO structure are aligned on 8-byte boundaries
(32-bit targets only).</p>
<p><strong>0x1000:</strong>
Enable use of PF data</p>
<p><strong>0x2000:</strong>
Enable old edge propagation.</p>
<p><strong>0x4000:</strong>
Disable new edge propagation.</p>
<p><strong>0x8000:</strong>
Enable simple forward edge propagation without dealing with inlined functions and loops.</p>
<p><strong>0x10000:</strong>
Disable basic block reordering based on profile data</p>
<p><strong>0x20000:</strong>
Disable optimizations of code involving semi-invariant values</p>
<p><strong>0x40000:</strong>
PFO-guided switch expansion to peel off hot cases.</p>
<p><strong>0x80000:</strong>
Disable profile feedback guidance of register allocation.</p>
<p><strong>0x100000:</strong>
Disable pgInstrumentValues() and pgInstrumentLoops().</p>
<p><strong>0x200000:</strong>
Disable the call to pgInstrumentEdges().</p>
<p><strong>0x400000:</strong>
Invoke PFO_Edges() again from optimize() under PFO.</p>
<p><strong>0x800000:</strong>
Enable the new method of computing BIH_BLKCNT values.</p>
<p><strong>0x1000000:</strong>
Disable the invocation of branch_prediction from latepredict().</p>
<p><strong>0x2000000:</strong>
Force block position even in the presence of missing or inconsistent edge counts.</p>
<p><strong>0x4000000:</strong>
Indirect call profiling.</p>
<p><strong>0x8000000:</strong>
Disable the fixup of ILM tags in edge count propagation.</p>
<p><strong>0x10000000:</strong>
Enable partial edge propagation in inlinee even if inliner’s profile data is missing.</p>
<p><strong>0x20000000:</strong>
Disable the shutdown of certain optimizations for cold loops.</p>
<p class="last"><strong>0x40000000:</strong>
Disable the code layout heuristic to favor a lexical order in the case of
a tie on execution frequency.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">149:</span></code></dt>
<dd><p class="first">For hammer and x8632 only, a non-zero value
<em>n</em>
invokes the generation of alternative loop code without peeling.  Its
precise meaning depends on the value of
<em>n</em>:</p>
<p>(1) If
<em>n</em>
&gt; 1 it means: if
<em>(cnt &lt;= n)</em>,
where
<em>cnt</em>
is the loop count, then execute loop code that does not have any
iterations peeled, otherwise execute the loop code that is generated
by default, which may or may not be peeled.</p>
<p>Alternative code is only generated for a loop that has a non-constant
count and is peeled by default.  Otherwise only one version of the
loop is generated, which is not peeled if
<em>(cnt &lt;= n)</em>,
and which is peeled or not according to the default heuristics if
<em>(cnt &gt; n)</em>.</p>
<p class="last">(2) If
<em>n</em>
== 1 the meaning is the same as above, but the critical value
<em>n</em>
is calculated by the compiler using a cost-benefit analysis to
estimate the minimum loop count for which peeling is profitable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">150:</span></code></dt>
<dd><p class="first">For hammer and x8632 only, a non-zero value
<em>n</em>
invokes the generation of alternative loop code with non-temporal
stores.  Its precise meaning depends on the value of
<em>n</em>:</p>
<p>(1) If
<em>n</em>
&gt; 1 it means: if
<em>(cnt &lt;= n)</em>,
where
<em>cnt</em>
is the loop count, then execute loop code that does not perform
non-temporal stores, otherwise execute loop code that performs
non-temporal stores if possible.  In the latter case the maximum
number of non-temporal stores is determined in the usual way, namely
it is given by the value of x[144] if it is non-zero, otherwise it is
1, 2 or 4 depending on the target.</p>
<p>Alternative loop code is only generated if a loop has a non-constant
count and the compiler
<em>can</em>
generate non-temporal stores in it.  Otherwise only one version of the
loop is generated, which does not have non-temporal stores if
<em>(cnt &lt;= n)</em>,
and which has them if possible if
<em>(cnt &gt; n)</em>.</p>
<p>This option overrides -Mx,39,0x200, which means “use non-temporal
stores if possible”.</p>
<p>(2) If
<em>n</em>
== 1 it means: if a loop has a
<em>non-constant</em>
count and the compiler can generate non-temporal stores in it, then
generate two versions of the loop, one with and one without
non-temporal stores.  The latter is executed if
<em>(cnt &lt;= N)</em>,
where
<em>N</em>
equals
<code class="docutils literal notranslate"><span class="pre">(flg.x[143]</span> <span class="pre">?</span> <span class="pre">flg.x[143]</span> <span class="pre">:</span> <span class="pre">200000)/B</span></code>.
<em>B</em>
is the approximate total number of bytes loaded and stored in one
iteration of the loop, so the value of
<em>N</em>
is loop-dependent.</p>
<p class="last">If a loop has a
<em>constant</em>
count then the default heuristic is still used to decide whether to
generate non-temporal stores, namely they are only generated if
<code class="docutils literal notranslate"><span class="pre">(cnt\*B</span> <span class="pre">&gt;=</span> <span class="pre">(flg.x[143]</span> <span class="pre">?</span> <span class="pre">flg.x[143]</span> <span class="pre">:</span> <span class="pre">200000))</span></code>.
By default the compiler does not generate non-temporal stores for
loops with a non-constant count.  Thus, -Mx,150,1 employs alternative
code generation to apply the same (or a very similar) condition for
using non-temporal stores to all loops, regardless of whether their
loop count is constant.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">151:</span></code></dt>
<dd><p class="first">(Temporary, for hammer and x8632 only): provides parameters and flags
for controlling and tuning alternative code generation.  See file
hammer/src/llvect.c for full details.</p>
<p class="last"><strong>0x4000000:</strong>
Enable peel and shuffle transformation which is not enabled by default for non-GH.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">152:</span></code></dt>
<dd>Provides a parameter
<em>n</em>
for loop splitting.  If loop splitting is enabled and
<em>n</em>
&gt; 0, then split the loop after every n’th statement where possible.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">153:</span></code></dt>
<dd>Provides a parameter
<em>n</em>
for .p2align emission after a JMP instruction.  If
<em>n</em>
!= 0, it overrides .align directive emission driven by xflag 135.
<em>n</em>
=2^
<em>x</em>
+
<em>z</em>
with
<em>z</em>
&lt;2^
<em>x</em>
, we emit .p2align
<em>x</em>
,,
<em>z</em>
directive.
For example, -Mx,153,25 implies (25 = 2^4+9) .p2align 4,,9 directives.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">154:</span></code></dt>
<dd>Similar to xflag 153 but .p2align directives are generated in fornt of loop start.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">155:</span></code></dt>
<dd><p class="first">Change the default values for .p2align emitted for labels of non-innermost
loops.  The form of .p2align is</p>
<div class="line-block">
<div class="line">.p2align     m,,n</div>
</div>
<p class="last">where, m is the number of low order bits of the address which are zero, and
n is the maximum number of bytes that can be used to align the address.
The default values for m and n are 4 and 7, respectively.
Use, if nonzero, the value of the lower nibble of flg.x[155] as n.
Use, if nonzero, the value of the next nibble of flg.x[155] as m.
of flg.x[155]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">156:</span></code></dt>
<dd>The value n in -Msmartalloc=huge:n</dd>
<dt><code class="docutils literal notranslate"><span class="pre">157:</span></code></dt>
<dd>Number of unrolls (# of loop bodies) of a loop with non-constant
iteration count and multiple blocks.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">158:</span></code></dt>
<dd>An upper bound to control the scale of code generation phase global data flow analysis. The value is
(number_of_flow_graph_nodes * number_of_definitions * number_of_locations).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">159:</span></code></dt>
<dd>The value is:
(number_of_definitions for ALL_GLOBAL_LOCS * number_of_global_locations).
Above this threashold, global locations are not tracked in the code generation phase global data flow.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">160:</span></code></dt>
<dd><p class="first">Used in intense.c for computing intensity</p>
<p><strong>0x01:</strong>
Display load/store information per loop</p>
<p class="last"><strong>0x02:</strong>
Display verifier messages.  This flag will go away when verifier errors are rare.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">161:</span></code></dt>
<dd><p class="first">Used in ccffinfo to turn on informational messages</p>
<p><strong>0x01:</strong>
Inliner messages</p>
<p><strong>0x02:</strong>
Loop optimization messages</p>
<p><strong>0x04:</strong>
LRE messages</p>
<p><strong>0x08:</strong>
Intensity messages</p>
<p><strong>0x10:</strong>
IPA messages</p>
<p><strong>0x20:</strong>
Fusion messages</p>
<p><strong>0x40:</strong>
Vectorizer messages</p>
<p><strong>0x80:</strong>
OpenMP messages</p>
<p><strong>0x100:</strong>
Optimizer messages</p>
<p><strong>0x200:</strong>
Prefetch messages</p>
<p><strong>0x400:</strong>
Fortran-specific messages</p>
<p><strong>0x800:</strong>
Parallelization messages</p>
<p><strong>0x1000:</strong>
reserved</p>
<p><strong>0x2000:</strong>
PFO messages</p>
<p><strong>0x4000:</strong>
Accelerator messages</p>
<p><strong>0x8000:</strong>
Unified binary messages</p>
<p><strong>0x10000:</strong>
Additional information, usually used only for regression testing</p>
<p><strong>0x20000:</strong>
PCAST messages</p>
<p class="last"><strong>0x100000:</strong>
Use short tags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">162:</span></code></dt>
<dd>Used in ccffinfo to turn on neg-informational messages.
It uses the same bit mapping as above, for those that have negative information.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">163:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Enable accelerator pragma/directive recognition</p>
<p><strong>0x02:</strong>
Just do the analysis, don’t generate the code</p>
<p><strong>0x04:</strong>
Do the analysis and generate the code, but don’t call the CUDA compiler</p>
<p><strong>0x08:</strong>
Do the analysis and generate the code and save the .gpu files</p>
<p><strong>0x10:</strong>
Save all the GPU files</p>
<p><strong>0x20:</strong>
don’t cache even with user cache directives</p>
<p><strong>0x40:</strong>
Generate __fmul_rn instead of ‘*’ instructions, to avoid coalescing multiply and add into FMA instructions, which gives different roundoff.</p>
<p><strong>0x80:</strong>
Disable double precision.</p>
<p><strong>0x100:</strong>
Enable shared-memory caching</p>
<p><strong>0x200:</strong>
Use fast math library</p>
<p><strong>0x400:</strong>
use 24-bit multiplies for subscripting</p>
<p><strong>0x800:</strong>
Generate ‘emulation mode’ code</p>
<p><strong>0x1000:</strong>
Generate strip-mined code on the host when private arrays are used.</p>
<p><strong>0x2000:</strong>
Original behavior: live-out induction variable marks a loop a invalid;
now we usually just make it sequential on the device</p>
<p><strong>0x4000:</strong>
When compiling for a host version of the accelerator as well.</p>
<p><strong>0x8000:</strong>
For debugging, set unknown bounds of an array to 1:100</p>
<p><strong>0x10000:</strong>
test caching</p>
<p><strong>0x20000:</strong>
Save all the GPU files and load the modules from the .gpu files instead of
inlining the GPU code.</p>
<p><strong>0x40000:</strong>
Keep .ptx file.</p>
<p><strong>0x80000:</strong>
Keep .bin file.</p>
<p><strong>0x100000:</strong>
Used only for testing</p>
<p><strong>0x200000:</strong>
Enable output from pgnvd</p>
<p><strong>0x400000:</strong>
Generate -ptxas -v output</p>
<p><strong>0x800000:</strong>
debug GPU code</p>
<p><strong>0x1000000:</strong>
Disable linear CG optimizations</p>
<p><strong>0x2000000:</strong>
Disable linear CG unrolling</p>
<p><strong>0x4000000:</strong>
for testing: insert call to __Test in the constructor</p>
<p><strong>0x8000000:</strong>
Disable dead-code after unrolling</p>
<p><strong>0x10000000:</strong>
for testing: change cudaRegisterFatBinary call to pgiRegisterFatBinary</p>
<p><strong>0x20000000:</strong>
Override default, unroll loops with calls</p>
<p><strong>0x40000000:</strong>
default is wait, don’t wait for each kernel to finish</p>
<p><strong>0x80000000:</strong>
always wait for each kernel to finish</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">164:</span></code></dt>
<dd><p class="first">Hammer llvect and CG.  (NOTE: continued from 135)</p>
<p><strong>0x1:</strong>
pragma save_all_gp_regs: At the entry and exit of a function, in
addition to saving and restoring the used callee-saved GP and XMM
registers (which is the normal action) also save and restore all
non-callee-saved GP registers, except for any that are used to return
the function result.</p>
<p><strong>0x2:</strong>
pragma save_all_regs: At the entry and exit of a function, in addition
to saving and restoring the used callee-saved GP and XMM registers
(which is the normal action) also save and restore all
non-callee-saved GP and XMM registers, except for any that are used to
return the function result.</p>
<p><strong>0x4:</strong>
pragma save_used_gp_regs: At the entry and exit of a function, in
addition to saving and restoring the used callee-saved GP and XMM
registers (which is the normal action) also save and restore used
non-callee-saved GP registers, except for any that are used to return
the function result.</p>
<p><strong>0x8:</strong>
pragma save_used_regs: At the entry and exit of a function, in
addition to saving and restoring the used callee-saved GP and XMM
registers (which is the normal action) also save and restore used
non-callee-saved GP and XMM registers, except for any that are used to
return the function result.</p>
<p><strong>0x10:</strong>
Disable the new method for reducing block pressures so that they
are within limits.</p>
<p><strong>0x20:</strong>
Disable the new method for reducing loop pressures so that they
are within limits.</p>
<p><strong>0x40:</strong>
Disable the new method for selecting register candidates to eliminate
in order to reduce loop pressures to within limit.</p>
<p><strong>0x80:</strong>
Disable the improvements to the estimation of block execution frequencies.</p>
<p><strong>0x100:</strong>
Enable an experimental register allocator optimisation that attempts
to restore eliminated register candidates at the end of the ‘limit
resources’ phase.</p>
<p><strong>0x200:</strong>
Disable an enhancement to the ‘optimize_imul()’ function.</p>
<p><strong>0x400:</strong>
Disable a KIMV peephole optimisation.</p>
<p><strong>0x800:</strong>
Disable store re-scheduling, i.e. the cggenai.c optimisation of moving
a store LILI forwards if it avoids the pre-emption of a load.</p>
<p><strong>0x1000:</strong>
Enable partial redundancy elimination on the linear ILIs.</p>
<p><strong>0x2000:</strong>
Enable copy propagation</p>
<p><strong>0x4000:</strong>
Do not perform CSE on QJSR ILIs.</p>
<p><strong>0x8000:</strong>
Disable the optimisation that inserts an xorps or xorpd instruction
before cvtsi2ss, cvtsd2ss and cvtss2sd instructions whose dest != src
in order to break merge dependences on the ‘dest’ register.</p>
<p><strong>0x10000:</strong>
Used by the f90 front end: enable float code in sfloat() in an
accelerator region.</p>
<p><strong>0x20000:</strong>
Do not allow partial redundancy elimination to add new blocks after
the lexically-last block in a function.</p>
<p><strong>0x40000:</strong>
Use the old heuristics for performing partial redundancy elimination.</p>
<p><strong>0x80000:</strong>
For AVX-512, enable the generation of calls to 64-byte-wide versions
of the vector fastmath intrinsic functions, which take zmm register
operands and return zmm register results.  Without this x-flag such
calls are replaced by two calls to the ymm version of the intrinsic.
Currently the latter behaviour is enabled by default because zmm
versions of the fastmath intrinsics are not available yet.</p>
<p><strong>0x100000:</strong>
For AVX, do not insert any ‘vzeroupper’ instructions.</p>
<p><strong>0x200000:</strong>
For AVX, only insert ‘vzeroupper’ instructions before calls to run-time
library functions, not before ‘ret’ instructions or calls to user-defined
functions as is done by default.</p>
<p><strong>0x400000:</strong>
Disable the vectorisation of loops containing ILIs that operate on the
new representation of complex data-types.</p>
<p><strong>0x800000:</strong>
Use the new math naming scheme (not yet default), i.e.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__f&lt;type&gt;&lt;data type&gt;_&lt;name&gt;_&lt;vectlen&gt;&lt;mask&gt;
&lt;type&gt;      : f - fastmath (default)
              r - relaxed math (-Mfprelaxed ...)
              p - precise math (-Kieee)
&lt;data type&gt; : s - single precision
              d - double precision
              c - single precision complex
              z - double precision complex
&lt;name&gt;      : exp, log, log10, pow, powi, powk, sin, cos, tan, asin, acos,
              atan, sinh, cosh, tanh, atan2,
&lt;vectlen&gt;   : 1 (scalar), 2, 4, 8, 16
&lt;mask&gt;      : m or null
</pre></div>
</div>
<p>Currently, the new method only applies to exp, log, pow, &amp; atan on 64-bit
linux</p>
<p><strong>0x1000000:</strong>
For AVX, replace 32-byte aligned load and store instructions by their
unaligned equivalents.  This is a ‘quick fix’ that was added to avoid
32-byte alignment errors in AVX code, but these errors have now been
fixed so this quick fix should not be necessary.</p>
<p><strong>0x2000000:</strong>
For AVX, generate ‘vzeroupper’ instructions even if -Mvect=simd:128
is used.  By default ‘vzeroupper’ instructions are not generated for
-Mvect=simd:128.</p>
<p><strong>0x4000000:</strong>
Disable the generation of non-destructive syntax, i.e. (dest != src2),
for AVX packed merge-type instructions.</p>
<p><strong>0x8000000:</strong>
Disable the following optimisations to the generation of prefetch
instructions in vectorised and unrolled loops:
(i) increasing the default prefetch distance if necessary to ensure
that none of the prefetched data is required in the current iteration;
(ii) issuing 2 prefetch instructions per array reference instead of one
if the vector loop processes 128 bytes of data per iteration; and
(iii) spreading out the prefetches across the first half of the loop
body instead of generating them all at the start of the loop body.</p>
<p><strong>0x10000000:</strong>
Disable the improvements to the LILI peephole optimisations for
integer constant folding and address code generation.</p>
<p><strong>0x20000000:</strong>
Halve the unroll factor that is used for AVX 256-bit vectorised loops
(or to be more precise, inhibit the doubling of the unroll factor that
is normally performed for such loops), provided that it is legal to do
so, i.e. provided the loop still processes at least 32 bytes of data
per vector iteration.</p>
<p><strong>0x40000000:</strong>
Disable the generation of scalar FMA instructions.  (This only affects
bulldozer code generation, since currently these instructions are only
generated on bulldozer.)</p>
<p class="last"><strong>0x80000000:</strong>
Disable the vectorisation of loops that contain any of the following:
(i) a reference to the loop induction variable as a primary in a
non-address expression, e.g.: for ( i = 0; i &lt; 10; i++ ) a[i] = i;
(ii) a FLOAT, DFLOAT or DFLOATK ILI, i.e. an integer*4 to real*4,
integer*4 to real*8 or integer*8 to real*8 type conversion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">165:</span></code></dt>
<dd>Used temporarily in accelerator compiler to set thread-block size.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">166:</span></code></dt>
<dd>Used for testing in the accelerator compiler to test selection criteria.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">167:</span></code></dt>
<dd>Used for testing in the accelerator compiler to control automatic
insertion of accelerator regions.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">168:</span></code></dt>
<dd>For C/C++, control maximum size of auto-inlined function.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">169:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
For C/C++, we now normally remove compiler-created symbols from the symbol table
hash lists after each function; this disables that.</p>
<p><strong>0x02:</strong>
TEMPORARY for 9.0-2… promote member inlined functions to extern weak
symbols (as with member templated functions)</p>
<p><strong>0x04:</strong>
for C++ only. Can use with -Wc,–zc_eh_no_opt : do not remove zc_eh regions marked no_throw.  –zc_eh_no_opt is the equivalent switch for pgcpp1.</p>
<p><strong>0x08:</strong>
for C++ only. Turn off removal of all the regions in a function if all
landing pads are zero.</p>
<p><strong>0x10:</strong>
Turn off the special processiong of lambdas in accellerated regions to
copy them in on the data clause</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">170:</span></code></dt>
<dd>Used temporarily for debugging loop fusion</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">171:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Override FEATURE_SCALAR_SSE in x86 settings, set to zero</p>
<p><strong>0x02:</strong>
Override FEATURE_SSE in x86 settings, set to zero</p>
<p><strong>0x04:</strong>
Override FEATURE_SSE2 in x86 settings, set to zero</p>
<p><strong>0x08:</strong>
Override FEATURE_SSE3 in x86 settings, set to zero</p>
<p><strong>0x10:</strong>
Override FEATURE_SSE41 in x86 settings, set to zero</p>
<p><strong>0x20:</strong>
Override FEATURE_SSE42 in x86 settings, set to zero</p>
<p><strong>0x40:</strong>
Override FEATURE_SSE4A in x86 settings, set to zero</p>
<p><strong>0x80:</strong>
Override FEATURE_SSE5 in x86 settings, set to zero</p>
<p><strong>0x100:</strong>
Override FEATURE_MNI in x86 settings, set to zero</p>
<p><strong>0x200:</strong>
Override FEATURE_DAZ in x86 settings, set to zero</p>
<p><strong>0x400:</strong>
Override FEATURE_PREFER_MOVLPD in x86 settings, set to zero</p>
<p><strong>0x800:</strong>
Override FEATURE_USE_INC in x86 settings, set to zero</p>
<p><strong>0x1000:</strong>
Override FEATURE_USE_MOVAPD in x86 settings, set to zero</p>
<p><strong>0x2000:</strong>
Override FEATURE_MERGE_DEPENDENT in x86 settings, set to zero</p>
<p><strong>0x4000:</strong>
Override FEATURE_SCALAR_NONTEMP in x86 settings, set to zero</p>
<p><strong>0x8000:</strong>
Override FEATURE_SSEIMAX in x86 settings, set to zero</p>
<p><strong>0x10000:</strong>
Override FEATURE_MISALIGNEDSSE in x86 settings, set to zero</p>
<p><strong>0x20000:</strong>
Override FEATURE_LD_MOVUPD in x86 settings, set to zero</p>
<p><strong>0x40000:</strong>
Override FEATURE_ST_MOVUPD in x86 settings, set to zero</p>
<p><strong>0x80000:</strong>
Override FEATURE_UNROLL_16 in x86 settings, set to zero</p>
<p><strong>0x100000:</strong>
Override FEATURE_DOUBLE_UNROLL in x86 settings, set to zero</p>
<p><strong>0x200000:</strong>
Override FEATURE_PEEL_SHUFFLE in x86 settings, set to zero</p>
<p><strong>0x400000:</strong>
Override FEATURE_PREFETCHNTA in x86 settings, set to zero</p>
<p><strong>0x800000:</strong>
Override FEATURE_PDSHUF in x86 settings, set to zero</p>
<p><strong>0x1000000:</strong>
Override FEATURE_SSEPMAX in x86 settings, set to zero</p>
<p><strong>0x2000000:</strong>
Override FEATURE_GHLIBS in x86 settings, set to zero</p>
<p><strong>0x4000000:</strong>
Override FEATURE_SSEMISALN in x86 settings, set to zero</p>
<p><strong>0x8000000:</strong>
Override FEATURE_ABM in x86 settings, set to zero</p>
<p><strong>0x10000000:</strong>
Override FEATURE_AVX in x86 settings, set to zero</p>
<p><strong>0x20000000:</strong>
Override FEATURE_LRBNI in x86 settings, set to zero</p>
<p><strong>0x40000000:</strong>
Override FEATURE_FMA4 in x86 settings, set to zero</p>
<p><strong>0x80000000:</strong>
Override FEATURE_XOP in x86 settings, set to zero</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">172:</span></code></dt>
<dd>This uses the same bits as xflag 171, but overrides to set to 1; reset overrides set.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">173:</span></code></dt>
<dd>(Temporary, for hammer only): a tuning parameter for common subexpression
elimination (CSE).  If flg.x[173] is non-zero then the maximum range
over which a CSE can be applied on 64-bit targets at (opt &gt;= 2) is
flg.x[173], otherwise it is 170.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">174:</span></code></dt>
<dd>Another throttle for auto-inliner for C/C++.
This sets the maximum function size into which to auto-inline.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">175:</span></code></dt>
<dd>Set max-reg-count for NVIDIA assembler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">176:</span></code></dt>
<dd><p class="first">Accelerator flags</p>
<p><strong>0x01:</strong>
Formerly: For NVIDIA, use the CUDA 2.3 toolkit and all that implies; no longer supported.</p>
<p><strong>0x02:</strong>
For NVIDIA, use the CUDA 3.0 toolkit</p>
<p><strong>0x04:</strong>
For NVIDIA, use the CUDA 3.1 toolkit</p>
<p><strong>0x08:</strong>
For NVIDIA, use the CUDA 3.2 toolkit</p>
<p><strong>0x10:</strong>
Use 32-bit mode on 64-bit systems</p>
<p><strong>0x20:</strong>
Use the more general upload/download routines to allow asynchronous uploads</p>
<p><strong>0x40:</strong>
Inverted: Don’t use updated general upload/download routines; this should become the default.</p>
<p><strong>0x80:</strong>
Don’t try to minimize expression insertions, use redundancy elimination instead</p>
<p><strong>0x100</strong>
Generate only compute capability that we specify on the command line.</p>
<p><strong>0x200</strong>
Generate compute capability 1.0.</p>
<p><strong>0x400</strong>
Generate compute capability 1.1.</p>
<p><strong>0x800</strong>
Generate compute capability 1.2.</p>
<p><strong>0x1000</strong>
Generate compute capability 1.3.</p>
<p><strong>0x2000</strong>
Generate compute capability 2.0.</p>
<p><strong>0x4000</strong>
output block numbers in .gpu file</p>
<p><strong>0x8000</strong>
Testing a new planner</p>
<p><strong>0x10000</strong>
do generate cache memory loads, but don’t use the cache memory in the expressions.
This is for debugging bad cache memory references.</p>
<p><strong>0x20000</strong>
Disable loop test replacement</p>
<p><strong>0x40000</strong>
don’t regularize the compare operations (which changes a&lt;b ==&gt; b&gt;a, and so forth).</p>
<p><strong>0x80000</strong>
use the old loop unroller</p>
<p><strong>0x100000</strong>
Mark induction variables live only if they are used.</p>
<p><strong>0x200000</strong>
enable expression reassociation</p>
<p><strong>0x400000</strong>
do generate register loads, but don’t use the register in the expressions.
This is for debugging bad cache memory references.</p>
<p><strong>0x800000</strong>
For testing, generate common blocks as a single block of bytes</p>
<p><strong>0x1000000</strong>
when reassociating, invert the loop order</p>
<p><strong>0x2000000</strong>
add induction increment at top of loop; default is at the bottom</p>
<p><strong>0x4000000</strong>
disable some expression floating</p>
<p><strong>0x8000000</strong>
used in accel.c to do lifetime analysis on whole accelerator region</p>
<p><strong>0x10000000</strong>
use fdiv_rn instead of divide</p>
<p><strong>0x20000000</strong>
Disable scalar kernels</p>
<p><strong>0x40000000</strong>
use new paramset struct</p>
<p class="last"><strong>0x80000000</strong>
Old method for placing fast-path tests, which tends to put them farther out
but allows for fewer fast-path tests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">177:</span></code></dt>
<dd><p class="first">More accelerator optimizer flags</p>
<p><strong>0x01</strong>
Enable initial forward substitution</p>
<p><strong>0x02</strong>
Enable initial expression reassociation</p>
<p><strong>0x04</strong>
Enable induction variable substitution</p>
<p><strong>0x08</strong>
Enable loop unrolling</p>
<p><strong>0x10</strong>
Enable forward substitution after unrolling</p>
<p><strong>0x20</strong>
Enable reassociation after substitution</p>
<p><strong>0x40</strong>
Enable final forward substitution</p>
<p><strong>0x80</strong>
Enable available expression replacement</p>
<p><strong>0x100</strong>
Enable distribution of multiplication over addition when reassociating expressions.</p>
<p><strong>0x200</strong>
Only float available expressions out of inner loops, or loops which
contain unrolled code.</p>
<p><strong>0x400</strong>
Do remove partially available expressions that are cheap, even
try to float them out of a loop.</p>
<p><strong>0x800</strong>
For distribution, only distribute multiplication over addition even when it’s not a constant times addition of a constant plus another value.</p>
<p><strong>0x1000</strong>
Do generate fastpath even if there aren’t enough fastpath tests to warrant it.</p>
<p><strong>0x2000</strong>
Count the maximum number of live variables we have in the program.</p>
<p><strong>0x4000</strong>
Don’t regularize comparisons (in accelerator mode), put threadIdx.x on one side of the compare,
everything else on the other side</p>
<p><strong>0x8000</strong>
Regularize comparisons (in cuda fortran mode), put threadIdx.x on one side of the compare,
everything else on the other side</p>
<p><strong>0x10000</strong>
Don’t make induction variables be protected symbols.</p>
<p><strong>0x20000</strong>
Do find positive, zero, negative expressions.</p>
<p><strong>0x40000</strong>
Don’t replace positive, zero, negative comparisons with constant, when possible</p>
<p><strong>0x80000</strong>
If unswitching</p>
<p><strong>0x100000</strong>
Disable trivial PLOOP optimizations</p>
<p><strong>0x200000</strong>
Don’t insert syncthreads calls for vector synchronization; this limits vector length == 32 for vector/nonparallel loops</p>
<p><strong>0x400000</strong>
Disable scalar kernels</p>
<p><strong>0x800000</strong>
testing fastpath</p>
<p><strong>0x1000000</strong>
Don’t create FSINCOS to eliminate redundant sin/cos operations</p>
<p><strong>0x2000000</strong>
Late basic-block-local redundancy elimination</p>
<p><strong>0x4000000</strong>
Enable generate of ‘fast-path’</p>
<p><strong>0x8000000</strong>
Don’t create a ‘temp’ for an address computation</p>
<p><strong>0x10000000</strong>
Don’t multiply by the constant tile size, use the blockdim variable</p>
<p><strong>0x20000000</strong>
Fastpath for arefs</p>
<p><strong>0x40000000</strong>
disable ‘protected’ sequential loops, which puts the strip counters in shared memory</p>
<p class="last"><strong>0x80000000</strong>
Split cache loads into register loads followed by cache stores</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">178:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Override FEATURE_FMA3 in x86 settings, set to zero</p>
<p><strong>0x02:</strong>
Override FEATURE_MULTI_ACCUM in x86 settings, set to zero</p>
<p><strong>0x04:</strong>
Override FEATURE_SIMD128 in x86 settings, set to zero</p>
<p><strong>0x08:</strong>
Override FEATURE_NOPREFETCH in x86 settings, set to zero</p>
<p><strong>0x10:</strong>
Override FEATURE_ALIGNLOOP4 in x86 settings, set to zero</p>
<p><strong>0x20:</strong>
Override FEATURE_ALIGNLOOP8 in x86 settings, set to zero</p>
<p><strong>0x40:</strong>
Override FEATURE_ALIGNLOOP16 in x86 settings, set to zero</p>
<p><strong>0x80:</strong>
Override FEATURE_ALIGNLOOP32 in x86 settings, set to zero</p>
<p><strong>0x100:</strong>
Override FEATURE_LD_VMOVUPD in x86 settings, set to zero</p>
<p><strong>0x200:</strong>
Override FEATURE_ST_VMOVUPD in x86 settings, set to zero</p>
<p><strong>0x400:</strong>
Override FEATURE_AVX2 in x86 settings, set to zero</p>
<p><strong>0x800:</strong>
Override FEATURE_AVX512F in x86 settings, set to zero</p>
<p><strong>0x1000:</strong>
Override ACC_FEATURE_OCLOFFSET in accel settings, set to zero</p>
<p><strong>0x2000:</strong>
Override FEATURE_AVX512VL in x86 settings, set to zero</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">179:</span></code></dt>
<dd>This uses the same bits as xflag 178, but overrides to set to 1; reset overrides set.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">180:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Use OpenCL compiler to build accelerator output</p>
<p><strong>0x02:</strong>
one of -acc=required or -acc=norequired was set</p>
<p><strong>0x04:</strong>
-acc=required</p>
<p><strong>0x08:</strong>
for Fermi cards (compute capability 2.0), disable L1 caching</p>
<p><strong>0x10:</strong>
Reclaimed flag: now used to Disable flush-to-zero mode.</p>
<p><strong>0x20:</strong>
Enable passing array sections to reflected arguments.</p>
<p><strong>0x40:</strong>
Print user variable names in the .gpu file.</p>
<p><strong>0x80:</strong>
Enable flush-to-zero mode.</p>
<p><strong>0x100:</strong>
Extract device routines to an accelerator inline library
(for development purposes so far)</p>
<p><strong>0x200:</strong>
Use old multiple paramset/launch routines instead of single routine to launch kernels</p>
<p><strong>0x400:</strong>
Enable OpenACC parsing</p>
<p><strong>0x800:</strong>
Save the fatbinary file.</p>
<p><strong>0x1000:</strong>
Don’t parse REFLECTED directive</p>
<p><strong>0x2000:</strong>
Don’t parse MIRROR directive</p>
<p><strong>0x4000:</strong>
Don’t parse LOCAL directive</p>
<p><strong>0x8000:</strong>
Don’t parse COPY/COPYIN/COPYOUT directive</p>
<p><strong>0x10000:</strong>
For OpenCL, use any device.</p>
<p><strong>0x20000:</strong>
Don’t pass unused arguments.</p>
<p><strong>0x40000:</strong>
Don’t remove late redundant operations in a basic block.</p>
<p><strong>0x80000:</strong>
For debugging generated code.</p>
<p><strong>0x100000:</strong>
Insert implicit copyin/copyout of the whole array for any REFLECTED arrays used.</p>
<p><strong>0x200000:</strong>
Insert implicit copyin/copyout of the whole array for any MIRROR arrays used.</p>
<p><strong>0x400000:</strong>
Insert implicit copyin/copyout of the whole array for any LOCAL arrays used.</p>
<p><strong>0x800000:</strong>
Insert implicit copyin/copyout of the whole array for any COPY/COPYIN/COPYOUT arrays used.</p>
<p><strong>0x1000000:</strong>
Don’t generate unrolled reduction code for accelerator reductions</p>
<p><strong>0x2000000:</strong>
don’t add __threadfence_block() calls after each synchronous update in unrolled reduction code</p>
<p><strong>0x4000000:</strong>
Use dataon/off/up/down instead of upload/download/alloc/etc.</p>
<p><strong>0x8000000:</strong>
Don’t generate acclin temps for TY_PTR data (workaround for another problem)</p>
<p><strong>0x10000000:</strong>
Insert implicit update device of all reflected arrays at the implicit data region top,
and update host at the bottom.</p>
<p><strong>0x20000000:</strong>
add -verbose to pgocld call</p>
<p><strong>0x40000000:</strong>
for compute capability 2.0+, enable L1+L2 caching</p>
<p><strong>0x80000000:</strong>
Don’t change IL_AADD to IL_IADD or IL_KADD before acclinopt does its work; improves redundancy elimination</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">181:</span></code></dt>
<dd><p class="first">Enables the 3D ‘mgrid’ tiling, i.e., tile at most the outer two loops in a
loop nest of depth 3:</p>
<div class="last line-block">
<div class="line">The lower halfword of -x 181 must be non-zero and is the tilesize.</div>
<div class="line">If the upper halfword of -x 181 is non-zero, the outer loop is</div>
<div class="line">tiled and this value is its tilesize; the outer loop is not</div>
<div class="line">tiled if it’s a parallel loop.</div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">182:</span></code></dt>
<dd>OpenCL modifications</dd>
<dt><code class="docutils literal notranslate"><span class="pre">183:</span></code></dt>
<dd><p class="first">LLVM modifications</p>
<p><strong>0x01:</strong>
Do not attempt to replace calls to our run-time for certain ‘builtins’ with
llvm instructions</p>
<p><strong>0x02:</strong>
Replace VLDU/VSTU of vect3 dtypes with bcopy calls - temporary front-end
work-around for bugs in llc with unaligned vect3 references.</p>
<p><strong>0x04:</strong>
Print the data layout for intended target.</p>
<p><strong>0x08:</strong>
Copy-in all formal arguments into the function’s stack – appears that
llc has a problem with generating dwarf location expressions for arguments
which are passed on the stack</p>
<p><strong>0x10:</strong>
(Fortran only) Enable LLVM inlining by not marking all routines with the LLVM attribute ‘noinline’.</p>
<p><strong>0x20:</strong>
Disable cse load optimization and dead instr removal in LLVM bridge</p>
<p><strong>0x40:</strong>
Enable scheduling of llvm instructions for interesting blocks. This opt is only performed
if cse load optimization is enabled.</p>
<p><strong>0x80:</strong>
Enable experimental enhanced conflict detection in LLVM bridge</p>
<p><strong>0x100:</strong>
Enable scheduling of llvm instructions for all blocks. This opt is only performed
if cse load optimization is enabled and scheduling is enabled.</p>
<p><strong>0x200:</strong>
Use ILI_ALT when available.</p>
<p><strong>0x400:</strong>
Enable block level optimization (peep-hole)</p>
<p><strong>0x800:</strong>
Dump some extra information as comments of LLMV instructions, available only in DEBUG mode</p>
<p><strong>0x1000:</strong>
Temporary flag used by compiler back end, enable stb processing if set.  Should be removed
once stb processing is working.</p>
<p><strong>0x2000:</strong>
Disable openmp parallel region outlined function through kmpc_fork_call.</p>
<p><strong>0x4000:</strong>
Disable workaround to mark x86 dp vector math calls as not varargs for Fortran</p>
<p><strong>0x8000:</strong>
Disable reciprocal multiply undo</p>
<p><strong>0x10000:</strong>
Enable the use of Newton’s approximation for square root</p>
<p><strong>0x20000:</strong>
Disable generation of TBAA metadata in LLVM output</p>
<p><strong>0x40000:</strong>
Disable GEP folding</p>
<p><strong>0x80000:</strong>
For references to uplevel PAR variables in the outlined functions for OpenMP
regions, emit indirect (NT_IND) nmes. Otherwise (the default), use NT_VAR;
with NT_VAR, we have ‘precise’ info for flow anaysis, subscripting, etc.,
i.e., this is the same as NT_IND vs NT_VAR for cray pointers).</p>
<p><strong>0x100000:</strong>
Use intermediate temp variables in the call to __kmpc_for_…_init routines</p>
<p><strong>0x200000:</strong>
Turn off ENHANCED_CSE_OPT in cgmain for LLVM</p>
<p><strong>0x400000:</strong>
Disable promotion of INTEGER*2 in called function on X86-64</p>
<p><strong>0x800000:</strong>
Allow loop distribution on POWER even when routine is outlined</p>
<p><strong>0x1000000:</strong>
Allow new fast math power vector routines when real base elements are different
size from integer power elements</p>
<p><strong>0x2000000:</strong>
Switch definition of “long double” on Power from “double double” to __float128</p>
<p><strong>0x4000000:</strong>
Disable generation of !llvm.loop metadata</p>
<p><strong>0x8000000:</strong>
(C/C++ only) Disable the LLVM inliner by marking all routines with the LLVM attribute ‘noinline’.</p>
<p><strong>0x10000000:</strong>
Enable arithmetic widening on address arithmetic.</p>
<p><strong>0x20000000:</strong>
Put constants in non read-only memories.</p>
<p class="last"><strong>0x40000000:</strong>
Emit DWARF name for Fortran COMMON blocks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">184:</span></code></dt>
<dd><p class="first">ARM modifications</p>
<p><strong>0x01:</strong>
Generate the equivalent of ‘float-abi=hard’ where fp values are passed
according to the vfp register conventions.</p>
<p class="last"><strong>0x02:</strong>
Specify in datalayout for ARM target that 8-bits/16-bits are native types for the target</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">185:</span></code></dt>
<dd><p class="first">Accelerator OpenCL output flags</p>
<p><strong>0x01:</strong>
Accelerator OpenCL output for NVIDIA</p>
<p><strong>0x02:</strong>
Accelerator OpenCL output for Platform 2012</p>
<p><strong>0x04:</strong>
Accelerator OpenCL output for ATI</p>
<p><strong>0x08:</strong>
Accelerator OpenCL output for X86</p>
<p><strong>0x10:</strong>
Accelerator OpenCL output for Generic target (anything)</p>
<p><strong>0x20:</strong>
Accelerator OpenCL output for Generic host</p>
<p class="last"><strong>0x40:</strong>
Accelerator OpenCL output for Generic GPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">186:</span></code></dt>
<dd><p class="first">More Accelerator flags</p>
<p><strong>0x01:</strong>
For NVIDIA, use the CUDA 4.0 toolkit</p>
<p><strong>0x02:</strong>
For NVIDIA, use the CUDA 4.1 toolkit</p>
<p><strong>0x04:</strong>
For NVIDIA, use the CUDA 4.1 or 4.2 toolkit with old CG</p>
<p><strong>0x10:</strong>
Failure mitigation mode is on by default; this turns it off</p>
<p><strong>0x20:</strong>
Disentangle data regions from compute regions
Every compute region must re-determine whether the data is present</p>
<p><strong>0x80:</strong>
Enable warning messages with users attempt to use PGI Accelerator Directives
that are being deprecated.</p>
<p><strong>0x1000:</strong>
Remove extra ‘protected’ symbol assignments that are only used in the same basic block.</p>
<p><strong>0x2000:</strong>
Forward substitution only for integer symbols.</p>
<p><strong>0x4000:</strong>
debug use</p>
<p><strong>0x8000:</strong>
for IEEE NOTxx comparisons, instead of generating the if(!(a&gt;b)), generate if(a&lt;=b).</p>
<p><strong>0x10000:</strong>
Generate smallest compute capability 1.x that is supported.</p>
<p><strong>0x20000:</strong>
Generate smallest compute capability 2.x that is supported.</p>
<p><strong>0x40000:</strong>
Array subscript range test in generated device code.</p>
<p><strong>0x80000:</strong>
Enable OpenACC interpretation of directives</p>
<p><strong>0x100000:</strong>
ACCSTRICT: Strict compliance with OpenACC syntax; issue warnings for any
non-OpenACC accelerator directive</p>
<p><strong>0x200000:</strong>
ACCVERYSTRICT: Stricter compliance with OpenACC syntax; issue errors for any
non-OpenACC accelerator directive</p>
<p><strong>0x400000:</strong>
Reorganize array calculations like we’re doing subscript range tests,
but don’t insert the array checks.</p>
<p><strong>0x800000:</strong>
Combine redundant conditionals</p>
<p><strong>0x1000000:</strong>
Allow non-tightly nested vector/worker loops</p>
<p><strong>0x2000000:</strong>
enable or disable fmaopt</p>
<p><strong>0x4000000:</strong>
Remove unreachable code</p>
<p><strong>0x8000000:</strong>
change the way conditionals are generated testing for cache loads</p>
<p><strong>0x10000000:</strong>
Insert threadfence_block for cache-line sharing before the syncthreads call</p>
<p><strong>0x20000000:</strong>
Implicit ‘present’ on all data clauses</p>
<p><strong>0x40000000:</strong>
Add data region enter/exit calls.</p>
<p class="last"><strong>0x80000000:</strong>
Create local shadows of all argument symbols</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">187:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong>
Enable store-forwarding</p>
<p><strong>0x02:</strong>
Strict kernels gang scheduling; don’t make a loop ‘gang parallel’ if it
was specified as only worker or vector.</p>
<p><strong>0x10:</strong>
convert 1/sqrt(x) to rsqrt(x) (single and double)</p>
<p><strong>0x20:</strong>
convert 1/(x*sqrt(x)) to t=rsqrt(x), t*t*t (single and double)</p>
<p><strong>0x40:</strong>
Extend the above two to include y/sqrt(x) and y/(x*sqrt(x))</p>
<p><strong>0x100:</strong>
“Protect” symbols that hold descriptor values</p>
<p><strong>0x200:</strong>
“Protect” symbols that hold descriptor values even in CUDA Fortran</p>
<p><strong>0x400:</strong>
earliest useful placement of a computation</p>
<p><strong>0x800:</strong>
Combine conditionals again after unrolling</p>
<p><strong>0x1000:</strong>
Debug output for comparing outputs.</p>
<p><strong>0x10000:</strong>
Acclinopt: compute earliest computation points at edges.</p>
<p><strong>0x20000:</strong>
Disable finding single-entry/single-exit regions in acclinopt.</p>
<p><strong>0x100000:</strong>
Override default for GPU code: llvm version 3.5</p>
<p><strong>0x200000:</strong>
Override default for GPU code: llvm version 3.6</p>
<p><strong>0x400000:</strong>
Override default for GPU code: llvm version 3.7</p>
<p><strong>0x800000:</strong>
Override default for GPU code: llvm version 3.8</p>
<p><strong>0x1000000:</strong>
Override default for GPU code: llvm version 3.9</p>
<p><strong>0x2000000:</strong>
Override default for GPU code: llvm version 4.0</p>
<p><strong>0x4000000:</strong>
Override default for GPU code: llvm version 5.0</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">188:</span></code></dt>
<dd>The default OpenACC vector length</dd>
<dt><code class="docutils literal notranslate"><span class="pre">189:</span></code></dt>
<dd><p class="first">More Accelerator flags</p>
<p><strong>0x01:</strong>
Generate compute capability 3.0 (Kepler-1)</p>
<p><strong>0x02:</strong>
Generate compute capability 3.5 (Kepler-2)</p>
<p><strong>0x04:</strong>
Generate both compute capability 3.0 and 3.5.</p>
<p><strong>0x08:</strong>
For NVIDIA, use the CUDA 4.2 toolkit</p>
<p><strong>0x10:</strong>
Generate llvm LL file, using llc llvm-ptx compiler</p>
<p><strong>0x20:</strong>
For NVIDIA, use the CUDA 5.0 toolkit</p>
<p><strong>0x40:</strong>
Don’t generate __ldg() refs to INTENT(IN) with compute capability 3.5 and up.</p>
<p><strong>0x80:</strong>
Generate calls to __pgiSetupArgument and __pgiLaunch instead of cudaSetupArgument and cudaLaunch, so we can intercept the calls for debugging.</p>
<p><strong>0x100:</strong>
generate declarations of all struct datatypes, used or not.</p>
<p><strong>0x200</strong>
Generate cache loads by recreating the expression tree instead of using the memref info.</p>
<p><strong>0x400</strong>
Generate AMD Trinity APU code</p>
<p><strong>0x800</strong>
Generate AMD Tahiti GPU code</p>
<p><strong>0x1000</strong>
Debugging: use VALUE for index variable names</p>
<p><strong>0x2000</strong>
Multi-target accelerator code</p>
<p><strong>0x4000</strong>
Use offsets to call OpenCL kernels.</p>
<p><strong>0x8000</strong>
Generate relocatable device code, link at link time.</p>
<p><strong>0x10000</strong>
Add -restrict to the build line.</p>
<p><strong>0x20000</strong>
Add __restrict to pointer arguments to a kernel.</p>
<p><strong>0x40000</strong>
Special code generation mode to call device-specific runtime routines,
with no begin/end calls.</p>
<p><strong>0x80000</strong>
generate __align__ on the common block declaration whether ‘extern’ or not</p>
<p><strong>0x100000</strong>
don’t run the ‘demote’ pass in acclinopt</p>
<p><strong>0x200000</strong>
don’t run the ‘lin_peep’ pass in acclinopt</p>
<p><strong>0x400000</strong>
old way to load register data, for comparison only</p>
<p><strong>0x800000</strong>
Add __restrict to pointer arguments to an accelerator kernel.</p>
<p><strong>0x1000000</strong>
Use modified dataon/dataoff routines with baseoffset argument</p>
<p><strong>0x2000000</strong>
In acclinopt, do demote IL_AADD, IL_KMUL operands; useful for 32-bit targets.</p>
<p><strong>0x4000000</strong>
Disable autoparallelization of loops in acc parallel constructs.</p>
<p><strong>0x8000000</strong>
Disable autoscoping and automatic detection of reductions in loops.</p>
<p><strong>0x10000000</strong>
Implicit ‘present_or_’ on all data clauses</p>
<p><strong>0x20000000</strong>
Don’t implicitly collapse outer parallel loops</p>
<p><strong>0x40000000</strong></p>
<p class="last"><strong>0x80000000</strong>
only two nested gang loops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">190:</span></code></dt>
<dd><p class="first">Extractor/Inliner (overflow).</p>
<p><strong>0x01:</strong>
Don’t perform the optimization of replacing a struct/union formal with
its an actual argument.
When the optimization occurs, the actual argument is not copied into
an inliner-generated temporary.</p>
<p><strong>0x02:</strong>
Set LVAL for dummy variables of a PST and LOC ilms in the extractor;
setting LVAL is no longer the default given the front-ends are now
tracking lval/rval.</p>
<p><strong>0x04:</strong>
Inhibit replacing CONST pointer formals with the actual argument.</p>
<p><strong>0x08:</strong>
Don’t attempt to use the number of switch case to throttle inlining</p>
<p class="last"><strong>0x10:</strong>
Turn on bottom-up autoinlining when IPA inlining is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">191:</span></code></dt>
<dd><p class="first">Temporary flags</p>
<p class="last"><strong>0x01:</strong>
Turn on C++ prototype implementation of the gnu visibility attribute
“hidden”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">192:</span></code></dt>
<dd><p class="first">More Accelerator flags</p>
<p><strong>0x01:</strong>
Accelerator: Move planned strip-mine ploops outwards</p>
<p><strong>0x02:</strong>
Accelerator: Move planned gang loops outwards</p>
<p><strong>0x04:</strong>
Accelerator: Enable user-written planner</p>
<p><strong>0x08:</strong>
Accelerator: save the planner files</p>
<p><strong>0x10:</strong>
Accelerator: Always set blockDim, even if the block dim is constant</p>
<p><strong>0x20:</strong>
Accelerator: use nightly build of the next cuda release</p>
<p><strong>0x40:</strong>
Add const __restrict to pointer arguments to a kernel.</p>
<p><strong>0x80:</strong>
Add const __restrict to pointer arguments to an accelerator kernel.</p>
<p><strong>0x100:</strong>
GPS - gang private shared; inverted: gang private arrays don’t all get put into shared memory</p>
<p><strong>0x200:</strong>
WPS - worker private shared; worker private arrays all get put into shared memory.
This is not yet implemented.</p>
<p><strong>0x400:</strong>
VPS - vector private shared; inverted: vector private arrays do not get put into local memory</p>
<p><strong>0x800:</strong>
Generate a different plan and kernel for each compute capability</p>
<p><strong>0x1000:</strong>
for CUDA output, disable insertion of __ldg() for global memory loads that are read-only</p>
<p><strong>0x2000:</strong>
Defer private array allocation</p>
<p><strong>0x4000:</strong>
Optimize vector0/worker0 sections of code</p>
<p><strong>0x8000:</strong>
Generate AMD Barts GPU code</p>
<p><strong>0x10000:</strong>
Generate AMD Cayman GPU code</p>
<p><strong>0x20000:</strong>
Generate AMD Pitcairn GPU code</p>
<p><strong>0x40000:</strong>
Generate AMD Bonaire GPU code</p>
<p><strong>0x80000:</strong>
Generate AMD Hawaii GPU code</p>
<p><strong>0x100000:</strong>
Special OpenCL code for reductions</p>
<p><strong>0x200000:</strong>
Allow variable-sized private arrays in the cache</p>
<p><strong>0x400000:</strong>
Accelerator: Don’t move planned vector loops outwards</p>
<p><strong>0x800000:</strong>
Treat all kernel launches as asynchronous.</p>
<p><strong>0x1000000:</strong>
Do call mark_array_subscripts in reassociate in acclinopt
so array subscript multiply-by-array-size is not reassociated</p>
<p><strong>0x2000000:</strong>
Implicitly mark all routines as ‘acc routine’</p>
<p><strong>0x4000000:</strong>
Reserved to extend above flag</p>
<p><strong>0x8000000:</strong>
Reserved to extend above flag</p>
<p><strong>0x10000000:</strong>
Reserved to extend above flag</p>
<p><strong>0x20000000:</strong>
enable auto-loop-collapse without collapse directive</p>
<p><strong>0x40000000:</strong>
enable lineinfo generation for accelerator target</p>
<p class="last"><strong>0x80000000:</strong>
Code-sinking: allow non-tightly nested loops to be tiled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">193:</span></code></dt>
<dd>Used to set an unroll size and count limit in acclinopt</dd>
<dt><code class="docutils literal notranslate"><span class="pre">194:</span></code></dt>
<dd><p class="first">More Accelerator flags</p>
<p><strong>0x01:</strong>
Generate AMD Capeverde GPU code</p>
<p><strong>0x02:</strong>
Generate AMD Spectre GPU code</p>
<p><strong>0x04:</strong></p>
<p><strong>0x1000:</strong>
Treat all parallel and kernels regions like ‘acc scalar region’</p>
<p><strong>0x2000:</strong>
Run on accelerator and host, and compare results.</p>
<p><strong>0x4000:</strong>
don’t print out ‘const’ (inverted)</p>
<p><strong>0x8000:</strong>
Default(none) implied on all OpenACC compute regions.</p>
<p><strong>0x10000:</strong>
gang-vector mode, ignore ‘worker’ dimension</p>
<p><strong>0x20000:</strong>
gang-worker mode, ignore ‘vector’ dimension</p>
<p><strong>0x40000:</strong>
Generate alternate code for reductions</p>
<p><strong>0x80000:</strong>
Generate multiple versions for different compute capabilities</p>
<p><strong>0x100000:</strong>
Maxwell compute capability 5.x</p>
<p><strong>0x200000:</strong>
Maxwell compute capability 5.0</p>
<p><strong>0x400000:</strong>
Maxwell compute capability 5.2</p>
<p><strong>0x800000:</strong>
For testing: allow unknown NME types in acc references</p>
<p><strong>0x1000000:</strong>
Allow expressions in vector() and vector_length() clauses</p>
<p><strong>0x2000000:</strong>
A loop with a user annotation of ‘vector’ implicitly scheduled as ‘shortloop’</p>
<p><strong>0x4000000:</strong>
don’t generate vector loop tests or strip loop branches if we know the
trip count is less than the vector length</p>
<p><strong>0x8000000:</strong>
For AMD GPU, keep the OpenCL or SPIR source, don’t compile it.</p>
<p><strong>0x10000000:</strong>
Default(present) implied on all OpenACC compute regions.</p>
<p><strong>0x20000000:</strong>
Allow unknown-sized arrays, essentially assuming they will be present</p>
<p><strong>0x40000000:</strong>
Recognize libm functions even if we don’t know they are libm</p>
<p class="last"><strong>0x80000000:</strong>
For CUDA output, generate –devdebug flag to generate dwarf for cuda C</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">195:</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">196:</span></code></dt>
<dd>Threshhold value for conditional vectorization short circuiting.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">197:</span></code></dt>
<dd>For NVIDIA code generation, the lower 12 bits set the __launch_bounds__ 2nd argument value.
The next 8 bits are masked into the blockIdx value to randomize block assignment.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">198:</span></code></dt>
<dd><p class="first">More Accelerator flags</p>
<p><strong>0x01:</strong>
Accelerator scalar replacement.</p>
<p><strong>0x02:</strong>
Do generate ‘dev only’ Minfo messages even in the release.</p>
<p><strong>0x04:</strong>
Don’t combine list-oriented Minfo messages</p>
<p><strong>0x08:</strong>
acclinopt: check for uninitialized values</p>
<p><strong>0x10:</strong>
when compiling for NVIDIA, set PTXOPT level to zero</p>
<p><strong>0x20:</strong>
when compiling for NVIDIA, set PTXOPT level to one</p>
<p><strong>0x40:</strong>
when compiling for NVIDIA, set PTXOPT level to two</p>
<p><strong>0x7f:</strong>
when compiling for NVIDIA, set PTXOPT level to three</p>
<p><strong>0x100</strong>
Compile with -ta=tesla:managed, use managed memory interface</p>
<p><strong>0x1000:</strong>
acclinopt: check for uninitialized values</p>
<p><strong>0x2000:</strong>
acclinopt: check for uninitialized values and give errors if there are any</p>
<p><strong>0x4000:</strong>
acclinopt: disable the wide load/store global memory optimization</p>
<p><strong>0x8000:</strong>
Use the open source llc GPU back end instead of libnvvm from the CUDA team.</p>
<p><strong>0x10000:</strong>
test multicore planner</p>
<p><strong>0x20000:</strong>
reserved</p>
<p><strong>0x40000:</strong>
Disable the insertion of begin/end labels for lexical scopes. These scope labels
are used to privatize arrays and structs that are local to an accelerator
region. See -Mnoautoprivatize.</p>
<p><strong>0x80000:</strong>
Don’t depend on warp-synchronous execution, insert syncs even with vector(32).</p>
<p><strong>0x100000:</strong>
For -ta=multicore, don’t actually go parallel but do everything else for the multicore code generation.</p>
<p><strong>0x200000:</strong>
For -ta=multicore, call __test_malloc and __test_free instead of malloc and free,
so we can intercept the calls for debugging.</p>
<p><strong>0x400000:</strong>
Compile with -ta=tesla:pin, allocate using pinned memory</p>
<p><strong>0x800000:</strong>
Experimenting with statement unrolling</p>
<p><strong>0x1000000:</strong>
Experimenting with changing placement of synchronizations for calls to vector routines.</p>
<p><strong>0x2000000:</strong>
global vector-32 mode; GPU code uses vector length of 32 for nvidia</p>
<p><strong>0x4000000:</strong>
don’t go into vector-32 mode; GPU code will not restrict to vector length of 32 for
nvidia even with ‘acc routine’ calls</p>
<p><strong>0x8000000:</strong>
Enable -ta=tesla:safecache, allowing variable-sized array section in cache directives.</p>
<p><strong>0x10000000:</strong>
Print out line numbers for all ccff messages.</p>
<p><strong>0x20000000:</strong>
In acclinopt, allow some builtin function calls to be marked redundant.</p>
<p><strong>0x40000000:</strong>
In acclin, disable printing of the lilix index for each statement in cuda C output.
This makes it easier to compare two outputs from slightly different versions.</p>
<p class="last"><strong>0x80000000:</strong>
Enable unified memory support for OpenACC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">199:</span></code></dt>
<dd>Non-zero value enable -Mvect=fastfuse.  This flag is/must be passed only when
-fast is enabled.  Value other than 0 represents the miximum number of blocks
to enable -Mvect=fastfuse.  default value is 10.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">200:</span></code></dt>
<dd>how many levels of inlining to do from leaves for bottom-up auto-inlining</dd>
<dt><code class="docutils literal notranslate"><span class="pre">201:</span></code></dt>
<dd><p class="first">Enable/Disable Accelerator optimizations</p>
<p><strong>0x04:</strong>
Disable FMA generation</p>
<p><strong>0x08:</strong>
Enable FMA generation</p>
<p><strong>0x10:</strong>
Disable vector sync optimization - add vector syncs after every worker/vector loop</p>
<p><strong>0x100:</strong>
Enable gang-vector mode globally</p>
<p><strong>0x200:</strong>
Enable gang-vector mode only with gang/worker/vector routines or calls to them</p>
<p><strong>0x400:</strong>
Disable gang-vector mode entirely</p>
<p><strong>0x800:</strong>
Enable gang-worker mode globally</p>
<p><strong>0x1000:</strong>
Enable gang-worker mode only with gang/worker/vector routines or calls to them</p>
<p><strong>0x2000:</strong>
Disable gang-worker mode entirely</p>
<p><strong>0x4000:</strong>
Enable vector-32 mode for NVIDIA GPUs globally</p>
<p><strong>0x8000:</strong>
Enable vector-32 mode only with gang/worker/vector routines or calls to them</p>
<p><strong>0x10000:</strong>
Disable vector-32 entirely</p>
<p><strong>0x20000:</strong></p>
<p><strong>0x40000:</strong>
Set accelerator CG loop index variables as ‘noforward’</p>
<p><strong>0x80000:</strong>
Print array assignments using pointer arithmetic always.</p>
<p><strong>0x100000:</strong>
Don’t demote address KMUL operations</p>
<p><strong>0x200000:</strong>
in LLVM output, don’t output the instruction info (lilix index, opcode)</p>
<p><strong>0x400000:</strong></p>
<p><strong>0x800000:</strong>
If the number of ACIV induction variables is too large, kill off all
but the innermost loop ones.</p>
<p><strong>0x1000000:</strong>
Only find ACIV induction variables for innermost loops.
reserved</p>
<p class="last"><strong>0x2000000:</strong>
Assume that complex arrays on GPU are aligned as follows: complex:8-byte dcmplx:16-byte</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">202:</span></code></dt>
<dd>Set number of bigbuffers for multi-buffer memory management for AMD GPU.
(moved from 250)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">203:</span></code></dt>
<dd>Set the default vector_length for OpenACC scheduling for NVIDIA</dd>
<dt><code class="docutils literal notranslate"><span class="pre">204:</span></code></dt>
<dd>Set the default num_workers for OpenACC scheduling for NVIDIA</dd>
<dt><code class="docutils literal notranslate"><span class="pre">205:</span></code></dt>
<dd>Set the default vector_length for OpenACC scheduling for AMD</dd>
<dt><code class="docutils literal notranslate"><span class="pre">206:</span></code></dt>
<dd>Set the default num_workers for OpenACC scheduling for AMD</dd>
<dt><code class="docutils literal notranslate"><span class="pre">207:</span></code></dt>
<dd>Set the default vector_length for OpenACC scheduling for Generic OpenCL</dd>
<dt><code class="docutils literal notranslate"><span class="pre">208:</span></code></dt>
<dd>Set the default num_workers for OpenACC scheduling for Generic OpenCL</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">209:</span></code></p>
<blockquote>
<div><p><strong>0x01:</strong></p>
<p><strong>0x02:</strong></p>
<p><strong>0x04:</strong>
Restore old IL_SMOVE usage, don’t expand into IL_SMOVEI/IL_SMOVES tree</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">210:</span></code></dt>
<dd><p class="first">OpenACC Multicore behavior</p>
<p><strong>0x01:</strong>
Old behavior for collapsed gang loops</p>
<p><strong>0x02:</strong>
Remove unused induction variable assignments</p>
<p><strong>0x04:</strong>
don’t optimize away unused private variable assignments</p>
<p><strong>0x08:</strong>
enable tracing with -ta=multicore.</p>
<p><strong>0x10:</strong>
Enable master-thread task distribution model.</p>
<p class="last"><strong>0x20:</strong>
Generate “guided” schedule by default for OpenACC multicore with the LLVM backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">211:</span></code></dt>
<dd><p class="first">Enable various accelerator CG optimizations</p>
<p><strong>0x01:</strong>
Revoving unreachable code. (unreachable)</p>
<p><strong>0x02:</strong>
Rearranging threadidx compares.  (threadidxcompares)</p>
<p><strong>0x04:</strong>
Unswitching. (unswitching)</p>
<p><strong>0x08:</strong>
Simplify threadidx compares. (simplifycompares);</p>
<p><strong>0x10:</strong>
Loop unrolling.</p>
<p><strong>0x20:</strong>
Combine conditionals.</p>
<p><strong>0x40:</strong>
Find fused mul-add opportunities.</p>
<p><strong>0x80:</strong>
Redundancy elimination.</p>
<p class="last"><strong>0x100:</strong>
Local store forwarding.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">212:</span></code></dt>
<dd>Disable various accelerator CG optimizations. The bits here are the same
as for flag 211.  Disable overrides Enable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">213:</span></code></dt>
<dd><p class="first">Enable O2 accelerator CG optimizations</p>
<p><strong>0x01:</strong>
Initial forward substitution (forward1)</p>
<p><strong>0x02:</strong>
Find expressions that are only positive or negative, and optimize away some branches. (findsign)</p>
<p><strong>0x04:</strong>
Combine conditionals. (combineconditionals)</p>
<p><strong>0x08:</strong>
Initial reassociation.  (reassociate1, reassociatedead)</p>
<p><strong>0x10:</strong>
Induction variable recognition and replacement.  (induct)</p>
<p><strong>0x20:</strong>
Safe expression forward substitition. (safeforward)</p>
<p><strong>0x40:</strong>
Reassociate after safe expression forward substitution  (setlevel and reassociatesafe)</p>
<p><strong>0x80:</strong>
peephole optimizations. (peephole)</p>
<p><strong>0x100:</strong>
Mark cheap expressions</p>
<p><strong>0x200:</strong>
Forward substitution after marking cheap expressions. (forward2)</p>
<p><strong>0x400:</strong>
Local redundancy elimination. (localredund)</p>
<p><strong>0x800:</strong>
Local forward substitution. (localforward)</p>
<p><strong>0x1000:</strong>
Protext symbols holding descriptor values in OpenACC</p>
<p><strong>0x2000:</strong>
Protext symbols holding descriptor values in CUDA Fortran</p>
<p><strong>0x4000:</strong>
Second peephole optimization pass</p>
<p><strong>0x8000:</strong>
Wide load/store global memory optimization</p>
<p><strong>0x10000:</strong>
Use LDG instruction for CUDA and cc35+</p>
<p><strong>0x20000:</strong>
Interchange vector ploops outwards</p>
<p><strong>0x40000:</strong>
Scalar replacement.</p>
<p><strong>0x80000:</strong>
Late expression deassociation: turn 8*n + 8*m into 8*(n+m)</p>
<p><strong>0x100000:</strong>
Conditional removal based on min/max value determination</p>
<p><strong>0x200000:</strong>
Enable induction variable analysis across the memsize*subscript
multiply for an array reference.</p>
<p><strong>0x400000:</strong>
When combining induction variables to families with the same step,
do or don’t (default) limit to those with constant-offsets from the base value.</p>
<p><strong>0x800000:</strong>
Mark IL_IKMV as induction variable</p>
<p><strong>0x1000000:</strong>
Optimize branches based on finding min/max values of variables and expressions.</p>
<p class="last"><strong>0x2000000:</strong>
When combining induction variables to families with the same step,
do or don’t (default) limit to those with constant-offsets and maybe a constant
multiple of threadIdx, blockIdx, blockDim or gridDim from the base value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">214:</span></code></dt>
<dd>Disable O2 accelerator CG optimizations. The bits here are the same
as for flag 213.  Disable overrides Enable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">215:</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">216:</span></code></dt>
<dd><p class="first">FLANG flags</p>
<p><strong>0x01:</strong>
The -ffast-math command-line option is present.</p>
<p><strong>0x02:</strong>
Disable fast math attribute on floating-point addition.</p>
<p class="last"><strong>0x04:</strong>
Disable fast math attribute on floating-point division.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">217:</span></code></dt>
<dd><p class="first">POWER Modifications</p>
<p class="last"><strong>0x01:</strong>
Enable auto initialization of stack memory to 64bit signaling NaNs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">218:</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">220:</span></code></dt>
<dd>Enable tuning code for -Minline.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">221:</span></code></dt>
<dd>This sets the maximum caller function size into which to Minline.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">222:</span></code></dt>
<dd>Functions whose size if smaller than this value will get inlined by Minline.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">232:</span></code></dt>
<dd><p class="first">OpenMP Accelerator Model flags for Flang compiler</p>
<p><strong>0x01:</strong>
Enable outlining for device functions. Compiler creates a extra function for teams, parallel directives in the device.</p>
<p><strong>0x02:</strong>
Disable symbol replacer while saving ILM of outlined function. It is enabled normally for OpenMP GPU offload.</p>
<p><strong>0x04:</strong>
Disable skipping openmp cpu reduction code generation. We normally skip it since gpu has different implementation.</p>
<p><strong>0x08:</strong>
Enable debug information for GPU code. Experimental</p>
<p><strong>0x10:</strong>
Init libomptarget library in the main instead of constructor.</p>
<p><strong>0x20:</strong>
Enable codegne for push loop trip count for libomptarget runtime.</p>
<p class="last"><strong>0x40:</strong>
Enable codegen for spmd kernel init.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">233:</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">248:</span></code></dt>
<dd>OpenMP Threadprivate TLS/TPvector implementation control.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">249:</span></code></dt>
<dd>LLVM version number, computed as:
Major = n / 10
Minor = n - (Major * 10)
where, n = flg.x[249]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">250:</span></code></dt>
<dd>Set number of bigbuffers for multi-buffer memory management for AMD GPU.
(moved to 202)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">251:</span></code></dt>
<dd>(NOT available - check declaration in global.h for flg.x[], all compilers)</dd>
</dl>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="fin.html">Maintenance Info</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="xref.html">Cross Reference</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>