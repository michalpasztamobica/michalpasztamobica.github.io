
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Expander &#8212; Flang 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ILMs" href="ilm.html" />
    <link rel="prev" title="Program Controller" href="controller.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Flang 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Expander</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="controller.html">Program Controller</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ilm.html">ILMs</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="expander">
<h1>Expander<a class="headerlink" href="#expander" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The primary purpose of the expander module is to translate the ILMs produced
by the semantic analyzer into ILIs, the internal language
that is processed by the LLVM-bridge. The LLVM-bridge then
converts the ILI into LLVM Intermediate Representation (IR).</p>
<p>During ILM to ILI translation, the ILIs are grouped into blocks, where the
extent of a block is determined by certain compiler options and the
characteristics of the control flow ILMs.</p>
<p>For each block, the expander creates a block information header (see later
sections for more detail)
which describes the contents of the block.
In addition, global information is gathered.  This includes:</p>
<ul class="simple">
<li>a names table reflecting precisely the variables being referenced
(e.g.,
<code class="docutils literal notranslate"><span class="pre">\*p</span></code>,
<code class="docutils literal notranslate"><span class="pre">st.x</span></code>,
<code class="docutils literal notranslate"><span class="pre">a[i]</span></code>,
etc.).  These entries are accessed by the
the ILI which perform loads and stores.</li>
</ul>
<p>The expander is separated into language dependent and
language independent modules. The Fortran-specific portions of the
expander are contained in
<em>exp_ftn.c</em>.</p>
</div>
<div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="global-data-structures-used">
<h3>Global Data Structures Used<a class="headerlink" href="#global-data-structures-used" title="Permalink to this headline">¶</a></h3>
<p><em>Symbol Table</em> — described in section 11.</p>
<p><em>ILMs</em> — internal representation of executable statements read from
a temporary file into an area used by the semantic analyzer and
the expander.
Refer to section 12 for a general description and appendix IV
for a list of the ILM opcodes and descriptions of their meanings.</p>
<p><em>Static ILM Information</em> — Static tables describing the ILM to ILI table driven expansions,
ILM attributes, etc. This information is generated by the
ILMTP
utility.
Refer to section 12 for a general description and appendix IV
for a list of the ILM opcodes and descriptions of their meanings.</p>
<p><em>ILIs</em> — internal representation created by the expander which are
shared for an entire source file (across all functions in that source
file). The ILIs are maintained in a single dynamic memory area.
This area is an array of unsigned short ints.
Refer to section 13 for a general description and appendix
V for a list of the ILI opcodes and descriptions of their meanings.</p>
<p><em>Static ILI Information</em> — Static tables describing ILI attributes, etc.
This information is generated by the
ILITP
utility.
Refer to section 13 for a general description and appendix
V for a list of the ILI opcodes and descriptions of their meanings.</p>
<p><em>ILTs</em> — internal representation created by the expander which represents
the terminal nodes of an ILI
“statement”.
An ILI statement may
be a function call, a store, register move or a branch.  A sequence of ILTs
represents a block of ILIs.</p>
<p><em>BIHs</em> — block information header table.  Refer to section 13 for a description.</p>
<p><em>NMEs</em> — name table entries. Refer to section 13 for a description.</p>
</div>
<div class="section" id="ilm-area">
<h3>ILM Area<a class="headerlink" href="#ilm-area" title="Permalink to this headline">¶</a></h3>
<p>This area is a single dynamic memory area (an array of short ints)
used to hold the ILMs
read in for a block. This space is allocated by the
semantic analyzer and freed by the expander.
An additional memory area (an array of structs) is used to store
auxiliary information
created for an ILM by the Expander.
This area parallels the area used
for reading in ILMs; that is, an index (relative offset from the beginning
of the ILM area) locating an ILM also locates the auxiliary
structure for that ILM.
After an ILM is expanded, the pointer (actually an
unsigned int offset from the
beginning of the ILI area) to the ILI which is considered the
result of the ILM may be stored in its (the ILMs) auxiliary structure.
This is done for those ILMs which may be
“linked”
to by other ILMs.
References to an ILM whose result
has been saved is just an indirection through this word.
In addition, for those ILMs which produce an address result
(e.g, a
“reference”
ILM, a pointer load ILM, etc.),
the index to the
names table entry representing the reference is stored in the
ILM’s auxiliary structure.
For certain ILMs (stores and pseudo stores), the ILI block index
(a BIH index) is stored in the auxiliary structure indicating the
ILI block which contains the store or pseudo store ILI for the ILM
(see section 6.3.6,
<em>Common ILM Expressions</em>,
for more details).
Figure 6-1 shows the dependencies of the two areas.</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="27%" />
<col width="3%" />
<col width="10%" />
<col width="10%" />
<col width="47%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#160;</td>
<td>ILM Area</td>
<td>&#160;</td>
<td colspan="3">Auxiliary Area</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>_</td>
<td>&#160;</td>
<td colspan="3">_</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>&#160;</td>
<td>0</td>
<td colspan="3">&#160;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>…</td>
<td>&#160;</td>
<td colspan="3">…</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td colspan="3">&#160;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>_</td>
<td>&#160;</td>
<td colspan="3">_</td>
</tr>
<tr class="row-odd"><td>i</td>
<td>opc</td>
<td>i</td>
<td>ili</td>
<td>nme</td>
<td>blk</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>_</td>
<td>&#160;</td>
<td colspan="3">_</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td colspan="3">&#160;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>_</td>
<td>&#160;</td>
<td colspan="3">_</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td colspan="3">&#160;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>_</td>
<td>&#160;</td>
<td colspan="3">_</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td colspan="3">&#160;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>…</td>
<td>&#160;</td>
<td colspan="3">…</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td colspan="3">&#160;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>_</td>
<td>&#160;</td>
<td colspan="3">_</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>i</td>
<td>index of an ILM</td>
</tr>
<tr class="row-even"><td>opc</td>
<td>opcode of the ILM</td>
</tr>
<tr class="row-odd"><td>ili</td>
<td>index to the ILI created for the ILM at i</td>
</tr>
<tr class="row-even"><td>nme</td>
<td>index to the names entry created for the ILM</td>
</tr>
<tr class="row-odd"><td>blk</td>
<td>bih index containing the ili  for the ILM
(see section 6.3.6)</td>
</tr>
</tbody>
</table>
<p>Figure 6-1.  ILM Areas
The following variable, global to the expander module and declared in
the file
<em>ilm.h</em>,
is used to
locate the memory area and to give the size of the area:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct {
    short ilm_base; /\* pointer to the memory area \*/
    short ilm_size; /\* size in units of short words \*/
    short ilmavl;   /\* available index (used by semant) \*/
} ilmb;
</pre></div>
</div>
<p>A definition for the parallel area occurs in the local expander
data structure (described in the next section).</p>
<p>While an ILM is being expanded, it may be necessary to temporarily save
pointers to ILI created.
An ILI saved in this fashion is associated with a temporary number.
The area used to remember the ILI is just a static array, local to
the expander module and defined in the local expander data structure.
This array is
indexed by the temporary number,
and is
<em>n</em>
words long,
where
<em>n</em>
is a number sufficient for
the
temporary locations required by any one ILM macro.
Any references
to a temporary are just indirections through this area.
Note that this number is hard-coded in
<em>expand.h</em>
and will have to
be increased if the number of temp locations required by an ILM
exceeds 9.</p>
</div>
<div class="section" id="local-expander-data-structure">
<h3>Local Expander Data Structure<a class="headerlink" href="#local-expander-data-structure" title="Permalink to this headline">¶</a></h3>
<p>The file
<em>expand.h</em>
contains
the data structure (the structure
<code class="docutils literal notranslate"><span class="pre">exp</span></code>)
which is local to the expander module,
and various C macros used to access the values of an ILM and its auxiliary
information.
Details about the structure exp can be obtained by examining the file
<em>expand.h</em>.
The ILM macros used by the expander module are:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">ILM_OPC(ip)</span></code>,
<code class="docutils literal notranslate"><span class="pre">ILM_OPND(ip,j)</span></code>:
used to extract the opcode and the
<code class="docutils literal notranslate"><span class="pre">j</span></code>-th
operand of ILM in the ILM area located by
<code class="docutils literal notranslate"><span class="pre">ip</span></code>.
<code class="docutils literal notranslate"><span class="pre">ip</span></code>
is an
<em>absolute pointer</em>
(not an offset) to the ILM.</li>
<li><code class="docutils literal notranslate"><span class="pre">ILM_RESULT(ix)</span></code>:
is used to store the result (and index to an ILI) of an
ILM.  The ILM is located by the
<em>index</em>
<code class="docutils literal notranslate"><span class="pre">ix</span></code>
(the offset from the beginning of the ILM area to the ILM in units
of short ints).</li>
<li><code class="docutils literal notranslate"><span class="pre">NME_RESULT(ix)</span></code>:
used to store the
“names”
result of an ILM.</li>
<li><code class="docutils literal notranslate"><span class="pre">ILI_OF(ix)</span></code>:
used to extract the ILI result of ILM located at index
<code class="docutils literal notranslate"><span class="pre">ix</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">NME_OF(ix)</span></code>:
used to extract the
“names”
result of ILM located at
index
<code class="docutils literal notranslate"><span class="pre">ix</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">ILM_BLOCK(ix)</span></code>:
used to store and extract the block identification
(a BIH index) of the block containing the ILI generated for ILM
<code class="docutils literal notranslate"><span class="pre">ix</span></code>.
This is used for the ILMs which are stores or pseudo stores.</li>
</ol>
</div>
</div>
<div class="section" id="processing">
<h2>Processing<a class="headerlink" href="#processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Overview<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The Expander module is divided into the following parts:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">expand</span></code></dt>
<dd><p class="first">This routine is the main routine of the
<code class="docutils literal notranslate"><span class="pre">expand</span></code>
module and is the
routine which is called by the Program Controller.
<code class="docutils literal notranslate"><span class="pre">expand</span></code>
is responsible for reading in an ILM block, processing the terminal
ILMs in that block, and for cleaning up
after the block has been processed.
<code class="docutils literal notranslate"><span class="pre">expand</span></code>
processes ILMs by scanning through the ILM blocks
calling
<code class="docutils literal notranslate"><span class="pre">eval_ilm</span></code>
on the terminal ILMs (an attribute in the static ILM
information).
Refer to Figure 6-2 for a high level description of
<code class="docutils literal notranslate"><span class="pre">expand</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>exp_init() ;
while ( not end of ILM file ) {
   rdilms();    /\* this routine reads in the BOS ILM,
                   processes the BOS, and then reads
                   in the ILMS in the ILM block \*/

   for each ILM, located by index ilmx, in the block {
     if ILM is a terminal ILM
        eval_ilm(ilmx);
   }
}
cleanup expand module;
</pre></div>
</div>
<p class="last">Figure 6-2.  <em>expand(^)</em></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exp_init</span></code></dt>
<dd>This routine is called by
<code class="docutils literal notranslate"><span class="pre">expand</span></code>
to initialize the Expander data
items and to allocate space for certain Expander data
structures.
This routine is called immediately before expanding any ILMs for the
source program.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eval_ilm</span></code></dt>
<dd>This routine controls the main processing of an ILM.
This routine is called by
<code class="docutils literal notranslate"><span class="pre">expand</span></code>
when
<code class="docutils literal notranslate"><span class="pre">expand</span></code>
sees a
“terminal”
ILM. The routine makes recursive calls on the ILMs operands
which are links and have not yet been evaluated (ILI have not been created
for it). If an ILM has already been processed,
<code class="docutils literal notranslate"><span class="pre">check_ilm</span></code>
is
called to ensure that the ILI originally generated will be
be used as a common expression (see section 6.3.6,
<em>Common ILM Expressions</em>).
<code class="docutils literal notranslate"><span class="pre">eval_ilm</span></code>
sets three variables which are static to the expand module
and are used by the various expansion routines:
<code class="docutils literal notranslate"><span class="pre">ilmp</span></code>
(a pointer,
<em>not an index</em>,
to the ILM being evaluated),
<code class="docutils literal notranslate"><span class="pre">curilm</span></code>
(the index of the ILM being evaluated),
and
<code class="docutils literal notranslate"><span class="pre">opc</span></code>
(the opcode of the ILM being evaluated).
Refer to Figure 6-3 for a high level description of the main
expand process.</dd>
<dt>expansion routines</dt>
<dd><p class="first">The ILMs are divided into two classes:</p>
<ul class="simple">
<li>table driven expansion defined by the ILM macros.
The routine
<code class="docutils literal notranslate"><span class="pre">exp_mac</span></code>
is responsible for expanding ILMs using the
template or macro information created by the utility ILMTP.</li>
<li>special case ILMs.
Several routines are responsible for these ILMs. The ILIs produced
for these ILMs are determined by various conditions as determined
by the routines. Typically, a routine will exist for each of the
ILM types (i.e., reference, branch, load, store, etc.) which are to
be special cased.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/\*  evaluate all operands of ilmp  \*/

for each ILM link operand, opnd, of ilmp
    if opnd has not been processed
        eval_ilm(opnd);
    else
        check_ilm(opnd);

define curilm, ilmp, opc;

/\*  evaluate ilmp  \*/

select processing for ilmp {

case ILM is table driven:
    exp_mac();

/\*  the following are special cased ILMS  \*/

case ILM is type reference:
    exp_ref();
case ILM is type branch:
    exp_bran();
case ILM is type procedure:
    exp_call();
case ILM is type load:
    exp_load();
case ILM is type store:
    exp_store();
case ILM is type arithmetic, constant, or miscellaneous:
    process ILM according to its opcode;
}
</pre></div>
</div>
<p class="last">Figure 6-3.  Expand Process</p>
</dd>
<dt>utility routines</dt>
<dd>These routines are called by the various expand routines
to perform such functions as reading in a block of ILMs,
creating and completing a basic block of ILI, and
performing certain ILI optimizations, etc.
These routines are found in the file
<code class="docutils literal notranslate"><span class="pre">exputil.c</span></code>.</dd>
</dl>
<p>Important expander issues are discussed in the remainder of this
section.</p>
</div>
<div class="section" id="ilt-blocks">
<h3>ILT Blocks<a class="headerlink" href="#ilt-blocks" title="Permalink to this headline">¶</a></h3>
<p>During expansion, ILT nodes are grouped into a unit called a basic block
or extended basic block.
A basic block of ILT nodes consists of a sequence of ILTs which can only
be entered at the beginning and may be exited only at the end
(it has a single
exit point).
An extended basic block is the same as a basic block except that there
may be more than one exit.
A basic block is formed according to the following rules:</p>
<ol class="arabic">
<li><p class="first">The occurrence of the
<code class="docutils literal notranslate"><span class="pre">LABEL</span></code>
ILM causes a new block to be created provided
that the label is referenced (its reference count is greater than zero).</p>
</li>
<li><p class="first">A branch (conditional and unconditional) ends a block.</p>
</li>
<li><p class="first">At opt level 0, at least one basic block is created for one ILM block
(note that an ILM block always begins with a
<code class="docutils literal notranslate"><span class="pre">BOS</span></code>
ILM).
At opt levels greater than 0, a basic block may span ILM block boundaries.</p>
</li>
<li><p class="first">The operands of an ILI cannot span a block boundary. This can only occur
if the operand of an ILM
is a store or pseudo store ILM (refer to section 6.3.6,
<em>Common ILM Expressions</em>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/\*
   previlt - the previous ILT
   curilt  - the current ILT
   curilm  - current ILM being expanded
   optlvl  - opt level selected
\*/

-----  curilm is a BOS  -----

if (optlvl==0) {
   wrtilts();             /\* save block just created \*/
   create new block;
   process BOS;
}

-----  curilm is a LABEL  -----

   lbl = label defined by ILM;
   while (previlt is a branch which references lbl) {
      previlt = delilt(previlt);  /\* delete this ILT and
                               update previlt \*/
      rfcnt(lbl)--;
      if (branch deleted was in a jump table) break;
   }
   if (rfcnt(lbl) &gt; 0 ) {
      wrtilts();  /\*  save block just created  \*/
      create new block;
   }
}

-----  curilm is one which creates an ILT  -----

if (curilt is a branch) {
   if (curilt is unconditional &amp;&amp; previlt is unconditional){
      if (not in jump table) {
   delilt(curilt);   /\*  the result of delilt is
                         discarded  \*/
   curilt = NULL;
      }
   else {
      wrtilts();
      create new block;
      previlt = curilt;
      curilt = NULL;
   }
}
else {    /\*  just add curilt to block  \*/
   next(previlt) = curilt;
   prev(curilt) = previlt;
   previlt = curilt;
}
</pre></div>
</div>
<p>Figure 6-4. ILT Basic Block Creation</p>
</li>
</ol>
<p>Extended basic blocks are created by the expander only at opt level 1.
These blocks are formed
according to the same rules as above except that a branch does not
terminate an extended basic block (i.e., the block may have more than
one exit point).</p>
<p>Creating a block
initially involves creating a BIH for it and then adding
ILTs.
Whether an ILT is added to the block or causes a new block to be created
depends on its type and the opt level selected.
An ILT may be one of the following:</p>
<dl class="docutils">
<dt>store</dt>
<dd>The ILT locates the store ILI created by a store ILM.</dd>
<dt>branch</dt>
<dd>The ILT locates the branch ILI created by a branch ILM.</dd>
<dt>procedure call</dt>
<dd>The ILT locates the function ILI that is called.
The result of the function is either
is type void or is discarded.
This ILT may also be created when an
ILT is deleted (since its expressions
are scanned for function calls),
or when the
<code class="docutils literal notranslate"><span class="pre">ESTMT</span></code>
ILM is processed.</dd>
<dt>move</dt>
<dd>he ILT locates a register move ILI.</dd>
<dt>entry/exit</dt>
<dd>The ILT locates the entry/exit ILI.
Note that these ILTs are always in their own blocks at opt not equal to 1
or if the option debug was selected.</dd>
</dl>
<p>After an ILT is created, it is determined if the previous ILT (if one exists)
is a branch. If so, one of four cases occurs:</p>
<ol class="arabic">
<li><p class="first">the previous ILT is an unconditional branch which is not a member of a
switch-jump table. The current ILT is deleted.</p>
</li>
<li><p class="first">the current ILT is an unconditional branch. The previous ILT is deleted
if the target labels are identical.
Function ILTs may be created by this action.</p>
</li>
<li><p class="first">The current ILT is an unconditional branch and the previous ILT is a
conditional branch.  The creation of the block is delayed until the
next ILM is processed (this is a non-BOS ILM if the opt level is 1).
If the ILM is a
<code class="docutils literal notranslate"><span class="pre">LABEL</span></code>,
then the following optimization is performed if
the label is referenced by the conditional branch:</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><dl class="first docutils">
<dt>.CW</dt>
<dd>if (cond) goto y;
goto x;</dd>
</dl>
<p class="last">y: …
.CE</p>
</td>
<td><dl class="first docutils">
<dt>.CW</dt>
<dd>if (!cond) goto x;</dd>
</dl>
<p class="last">y: …</p>
</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">Otherwise, the previous block is complete.
The current ILT becomes the
first ILT of the new block.</p>
</li>
</ol>
<p>If the previous ILT is not a branch, the current ILT is added to the
current block.</p>
<p>When a
<code class="docutils literal notranslate"><span class="pre">LABEL</span></code>
ILM is processed, the following checks are performed:</p>
<ol class="arabic simple">
<li>The above-mentioned optimization (3) occurs if the conditions are satisfied.
In addition, the reference count of the label described
as
<code class="docutils literal notranslate"><span class="pre">x</span></code>
is decremented.
If the label is not referenced by the conditional branch and the opt level is
not 1, the ILT for the conditional branch is the last ILT of the current
block.
The ILT for the unconditional branch becomes the first ILT of
the next block.</li>
<li>If (1) does not occur, the previous ILT is checked to determine if
it is some sort of branch to the label.  If so, the ILT is deleted and the
label’s reference count is decremented.
Deleting this ILT could cause a function ILT or ILTs to be created
if it is a conditional branch.</li>
<li>If the reference count of the label is greater than zero (this
check is performed regardless of the outcome of (1) or (2)), a new block is
created with the label defining the beginning of the block.</li>
</ol>
<p>When a
<code class="docutils literal notranslate"><span class="pre">BOS</span></code>
ILM is processed and the opt level is zero, a new block
is created whose line number is extracted from the BOS.
Otherwise, the line number is saved away for use by the next block created.
Note that if multiple ILI blocks are created for an ILM block, all but the
first block have their line numbers set to zero.</p>
<div class="section" id="debugger-interface">
<h4>Debugger Interface<a class="headerlink" href="#debugger-interface" title="Permalink to this headline">¶</a></h4>
<p>&lt;this may change&gt;</p>
<p>When the debug compiler option is selected, the first ILT of a block which is
neither an entry nor an exit block is a
call to the debugger routine
<code class="docutils literal notranslate"><span class="pre">dbg$i_line</span></code>.
This involves creating an ILI which is a call to the routine and an ILT which
locates this ILI.
Note that this is done for only those blocks which have non-zero line numbers.</p>
</div>
</div>
<div class="section" id="ilm-macro-expansion">
<h3>ILM Macro Expansion<a class="headerlink" href="#ilm-macro-expansion" title="Permalink to this headline">¶</a></h3>
<p>The routine
<code class="docutils literal notranslate"><span class="pre">exp_mac</span></code>
is responsible for expanding ILMs which
are defined as macros as specified by the ILM template definitions.
This expansion is straightforward and consists of looping through
the template to add the ILI.
All detail can be found in the
code for the routine.</p>
</div>
<div class="section" id="reference-ilms">
<h3>Reference ILMs<a class="headerlink" href="#reference-ilms" title="Permalink to this headline">¶</a></h3>
<p>The routine
<code class="docutils literal notranslate"><span class="pre">exp_ref</span></code>
expands the reference ILMs (c
<code class="docutils literal notranslate"><span class="pre">BASE</span></code>,
<code class="docutils literal notranslate"><span class="pre">ELEMENT</span></code>,
and
<code class="docutils literal notranslate"><span class="pre">MEMBER</span></code>).
The ILI generated represent the memory address of
the reference. In addition, a names table entry is created which
represents the reference. The cases are:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">BASE</span> <span class="pre">sym</span></code></li>
</ol>
<p>The add ILI routine,
<code class="docutils literal notranslate"><span class="pre">addili</span></code>
(described in section 13), is called
to produce the ILI
<code class="docutils literal notranslate"><span class="pre">ACON</span> <span class="pre">sym'</span></code>
(where
<code class="docutils literal notranslate"><span class="pre">sym'</span></code>
is an address constant
whose value is
<code class="docutils literal notranslate"><span class="pre">&lt;sym,0&gt;</span></code>).
The final
result of this
<code class="docutils literal notranslate"><span class="pre">ACON</span></code>
is either the stack offset allocated to
<code class="docutils literal notranslate"><span class="pre">sym</span></code>
by the code scheduler (if
<code class="docutils literal notranslate"><span class="pre">sym</span></code>
is automatic or a dummy argument),
or a relative offset allocated by the code
scheduler from the beginning of its psect
(if
<code class="docutils literal notranslate"><span class="pre">sym</span></code>
is static or external).</p>
<p>The add names entry routine,
<code class="docutils literal notranslate"><span class="pre">addnme</span></code>
(described in section 13),
is called to create a names
entry for the
<code class="docutils literal notranslate"><span class="pre">BASE</span></code>
ILM.
<code class="docutils literal notranslate"><span class="pre">addnme</span></code>
is called with a template which describes
a names entry of type variable (c
<code class="docutils literal notranslate"><span class="pre">NT_VAR</span></code>)
whose symbol field is
<code class="docutils literal notranslate"><span class="pre">sym</span></code>.
This template is described as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;NT_VAR, sym, 0, 0&gt;
</pre></div>
</div>
<p>(the last two 0’s
represent a names table entry and a constant offset, respectively).</p>
<p>If
<code class="docutils literal notranslate"><span class="pre">sym</span></code>
is an argument of type double
(on 32-bit machines), struct, or union, a
<code class="docutils literal notranslate"><span class="pre">LDA</span></code>
ILI
referencing the
<code class="docutils literal notranslate"><span class="pre">ACON</span></code>
is also generated which will extract the
argument’s address from the argument list.
This is done since double
(on 32-bit machines), struct, and union values passed
to procedures are actually passed in temporaries.
The address
of the temporary is passed and it is as if the formal argument is
a pointer to the double, struct, or union argument.
The names entry created by
<code class="docutils literal notranslate"><span class="pre">addnme</span></code>
is used in the
<code class="docutils literal notranslate"><span class="pre">LDA</span></code>.</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ELEMENT</span> <span class="pre">base</span> <span class="pre">subs</span> <span class="pre">dt</span></code></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd><p class="first last">is the base ILI of this reference.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subs</span></code></dt>
<dd><p class="first last">is the subscript ILI.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dt</span></code></dt>
<dd><p class="first last">is a pointer to the dtype record which represents the data type
of the element and is used to compute the multiplier of
<code class="docutils literal notranslate"><span class="pre">subs</span></code>.
The multiplier is defined to be the size of each element in units of bytes.
However, for certain machines, it is possible to use a scaling
instruction which will scale a value before adding.
Consequently, two values,
<code class="docutils literal notranslate"><span class="pre">size</span></code>
(the number of units to scale) and
<code class="docutils literal notranslate"><span class="pre">scl</span></code>
(the scale factor),
are computed from
<code class="docutils literal notranslate"><span class="pre">dt</span></code>
using the function
<em>scale_of</em>
in the compiler module
<em>dtypeutil.c</em>.
The multiplier based on these values is
<code class="docutils literal notranslate"><span class="pre">size\*2\\*[scl\\*]</span></code>.
For a machine which does not have this capability,
<code class="docutils literal notranslate"><span class="pre">size</span></code>
is the number of bytes in each element and
<code class="docutils literal notranslate"><span class="pre">scl</span></code>
is 0.</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>The handling of
<code class="docutils literal notranslate"><span class="pre">ELEMENT</span></code>
depends on
<code class="docutils literal notranslate"><span class="pre">subs</span></code>:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">subs</span></code>
is a constant ILI (let
<code class="docutils literal notranslate"><span class="pre">c</span></code>
be its value)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(1)  ACON c \* size
(2)  AADD base (1) scl
</pre></div>
</div>
<p>Note that the constant
<code class="docutils literal notranslate"><span class="pre">c\*size</span></code>
may be folded into base by
<code class="docutils literal notranslate"><span class="pre">addili</span></code>.</p>
</li>
<li><p class="first">subs is
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">c</span></code>
— add
<code class="docutils literal notranslate"><span class="pre">c\*size</span></code>
to the base</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(1)  ACON c \* size       The constant may be folded into base.
(2)  AADD base (1) scl
(3)  ICON size
(4)  IMUL i (3)
(5)  DAMV (4)
(6)  AADD (2) (5) scl     i is added to the (new) base.
</pre></div>
</div>
</li>
<li><p class="first">subs is
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">-</span> <span class="pre">c</span></code>
— subtract
<code class="docutils literal notranslate"><span class="pre">c\*size</span></code>
from the base</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(1)  ACON c \* size       The constant may be folded into base.
(2)  ASUB base (1) scl
(3)  ICON size
(4)  IMUL i (3)
(5)  DAMV (4)
(6)  AADD (2) (5) scl     i is added to the (new) base.
</pre></div>
</div>
</li>
<li><p class="first">otherwise,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(1)  ICON size
(2)  IMUL subs (1)
(3)  DAMV (2)
(4)  AADD (3) base scl
</pre></div>
</div>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">addnme</span></code>
is called with the template</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;NT_ARR, arr, bnme, cnst&gt;
</pre></div>
</div>
<p>to create
a names entry for the
<code class="docutils literal notranslate"><span class="pre">ARRAY</span></code>
ILM.
<code class="docutils literal notranslate"><span class="pre">bnme</span></code>
is the names entry of the base ILI.
<code class="docutils literal notranslate"><span class="pre">arr</span></code>
and
<code class="docutils literal notranslate"><span class="pre">cnst</span></code>
combine to indicate if this array reference is one with constant
subscripts.  If
<code class="docutils literal notranslate"><span class="pre">subs</span></code>
is a constant,
<code class="docutils literal notranslate"><span class="pre">arr</span></code>
is 0 and
<code class="docutils literal notranslate"><span class="pre">cnst</span></code>
is the value of the
constant subscript multiplied by size.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">arr</span></code>
is -1.</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">MEMBER</span> <span class="pre">base</span> <span class="pre">sym</span></code></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd><p class="first last">is the base ILI of the reference.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sym</span></code></dt>
<dd><p class="first">is the member symbol table item used to extract its offset
from the beginning of the structure.</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span>(1)  ACON offset
(2)  AADD base (1) 0
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>The names entry template for the
<code class="docutils literal notranslate"><span class="pre">MEMBER</span></code>
ILM is</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;NT_MEM, psmem, bnme, 0&gt; .
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bnme</span></code>
is the names entry of the base ILI.
<code class="docutils literal notranslate"><span class="pre">psmem</span></code>
is the symbol table item which is the value of the pseudo member
field of
<code class="docutils literal notranslate"><span class="pre">sym</span></code>
(refer to the section,
<em>Symbol Table</em>).</p>
</div>
<div class="section" id="loads-and-stores">
<h3>Loads and Stores<a class="headerlink" href="#loads-and-stores" title="Permalink to this headline">¶</a></h3>
<p>The ILMs of type load and store perform loads and stores of
“variables”
(scalar, array element, structure member) and loads and stores of
structures (the
<code class="docutils literal notranslate"><span class="pre">SMOVE</span></code>
ILM). The
“variable”
ILMs correspond to the C scalar types.
Expanding these types of ILMs to ILIs involves chosing the
ILI which reflects the size of the data type on the
target machine.
For the ILIs
<code class="docutils literal notranslate"><span class="pre">LD</span></code>
and
<code class="docutils literal notranslate"><span class="pre">ST</span></code>
(load and store data register),
an additional operand value is used to denote the size
of the fetch or store. These ILIs are of the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LD adr sym stc
ST val adr sym stc
</pre></div>
</div>
<p>where</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">adr</span></code></dt>
<dd>is a link to the address of the load or store</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sym</span></code></dt>
<dd>is the names table entry of the reference</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val</span></code></dt>
<dd>is a link to the value being stored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siz</span></code></dt>
<dd>is an immediate constant selecting size.  These are of the form
<code class="docutils literal notranslate"><span class="pre">MSZ_&lt;name&gt;</span></code>
and are described in the ILI section.</dd>
</dl>
<p>The remaining ILIs are for loading and storing pointers (c
<code class="docutils literal notranslate"><span class="pre">PLD</span></code>
and
<code class="docutils literal notranslate"><span class="pre">PST</span></code>),
loading and storing doubles (c
<code class="docutils literal notranslate"><span class="pre">DLD</span></code>
and
<code class="docutils literal notranslate"><span class="pre">DST</span></code>),
and loading and storing floats (c
<code class="docutils literal notranslate"><span class="pre">RLD</span></code>
and
<code class="docutils literal notranslate"><span class="pre">RST</span></code>)
are of the form:</p>
<table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="30%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>LDA/LDDP/LDSP adr sym</td>
<td>PLD/DLD/RLD</td>
</tr>
<tr class="row-even"><td>STA/STDP/STSP val adr sym1</td>
<td>PST/DST/RST</td>
</tr>
</tbody>
</table>
<p>Each ILM has a link to an expression which represents the address
of the quantity to be loaded or stored.
For the load ILMs, this
is the only link; for the stores, this is the first link.
This link is also used to locate the names table entry of the entity
being fetched or stored (the next word following that link
contains the index to the names table entry).</p>
<p>For the
<code class="docutils literal notranslate"><span class="pre">PLD</span></code>
ILM, a new names entry of type indirection is
created.  The template for this entry is</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;NT_IND, 0, sym, 0&gt;
</pre></div>
</div>
<p>(c
<code class="docutils literal notranslate"><span class="pre">sym</span></code>
is the names entry located by link).  The index to this entry
is stored away in the second word of the
<code class="docutils literal notranslate"><span class="pre">PLD</span></code>
ILM.</p>
<p>For field operations, the
<code class="docutils literal notranslate"><span class="pre">LD</span></code>
or
<code class="docutils literal notranslate"><span class="pre">ST</span></code>
ILIs are used.
The names table entry created for the referenced
<code class="docutils literal notranslate"><span class="pre">MEMBER</span></code>
ILM
is used in these operations.
The size
of the operation depends on the
<code class="docutils literal notranslate"><span class="pre">LDSIZE</span></code>
field of the member symbol
table item in the
<code class="docutils literal notranslate"><span class="pre">MEMBER</span></code>
ILM located by the address ILM link.
This value is one of 1 (byte), 2 (half-word), or 4 (word)
and indicates which memory unit in a load or store operation
(byte, half-word, or word) is
used to reference the field.</p>
<p>For the
<code class="docutils literal notranslate"><span class="pre">SLD</span></code>
or
<code class="docutils literal notranslate"><span class="pre">FLD</span></code>
ILMs, a
<code class="docutils literal notranslate"><span class="pre">LD</span></code>
ILI is generated which will fetch from
memory the unit which contains the field.
Following the
<code class="docutils literal notranslate"><span class="pre">LD</span></code>
ILI, a sequence of ILI is
generated to extract from this unit the actual field,
using either the field
<code class="docutils literal notranslate"><span class="pre">EXTRACT</span></code>
instruction, if one exists, or
a left shift followed by a right shift.
The end result is that the
field is right justified in a data register.
These shifts are calculated from the
<code class="docutils literal notranslate"><span class="pre">BITOFF</span></code>,
<code class="docutils literal notranslate"><span class="pre">FLDSZ</span></code>,
and
<code class="docutils literal notranslate"><span class="pre">LDSIZE</span></code>
fields
of the member symbol table item.  The actual calculation depends on
the bit ordering (
“big-endian”
or
“little-endian”)
of the target machine.  See the code for details.</p>
<p>For the
<code class="docutils literal notranslate"><span class="pre">FST</span></code>
ILM, a
<code class="docutils literal notranslate"><span class="pre">ST</span></code>
ILI is generated to store the value of the
field and any bits from other members of the structure which are
in the memory unit.
Prior to the
<code class="docutils literal notranslate"><span class="pre">ST</span></code>
ILI, a sequence of ILI is generated to insert into a
data register the value being stored. These ILI consist of shifts
and masking operations, or field
<code class="docutils literal notranslate"><span class="pre">MERGE</span></code>
instructions
if available,
which are derived from the
<code class="docutils literal notranslate"><span class="pre">BITOFF</span></code>,
<code class="docutils literal notranslate"><span class="pre">FLDSZ</span></code>,
and
<code class="docutils literal notranslate"><span class="pre">LDSIZE</span></code>
fields.  Again, see the code for details.</p>
<p>Field load and store operations are optimized in cases where the
field takes up a whole load unit (e.g., 8 bits), and when the field
is left justified in the load unit.</p>
<p>The
<code class="docutils literal notranslate"><span class="pre">SMOVE</span></code>
ILM for the structure
assignment,
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>,
consists of three operands:
<code class="docutils literal notranslate"><span class="pre">addr</span></code>        link to the ILM defining the address of <code class="docutils literal notranslate"><span class="pre">a</span></code>
<code class="docutils literal notranslate"><span class="pre">expr</span></code>        link to the ILM defining the address of <code class="docutils literal notranslate"><span class="pre">b</span></code>
<code class="docutils literal notranslate"><span class="pre">sym</span></code> pointer to the data type of the structure</p>
<p>The ILI generated for the
<code class="docutils literal notranslate"><span class="pre">SMOVE</span></code>
depend on the size and alignment of the
structure type:</p>
<ol class="arabic simple">
<li>size of the structure is less than or equal
to eight units, where units depends on the alignment
and is one of bytes, half-words, words, or double words.
For this case, the structures
<code class="docutils literal notranslate"><span class="pre">a</span></code>
and
<code class="docutils literal notranslate"><span class="pre">b</span></code>
are divided into
<code class="docutils literal notranslate"><span class="pre">size</span></code>
distinct
units.  A sequence of
<code class="docutils literal notranslate"><span class="pre">LD</span></code>
and
<code class="docutils literal notranslate"><span class="pre">ST</span></code>
ILIs are generated to move a unit of
<code class="docutils literal notranslate"><span class="pre">a</span></code>
to
its position (according to the same offset for the beginning) in
<code class="docutils literal notranslate"><span class="pre">b</span></code>.
The names entries created for
<code class="docutils literal notranslate"><span class="pre">addr</span></code>
and
<code class="docutils literal notranslate"><span class="pre">expr</span></code>
are used in these ILIs.</li>
<li>size of the structure is greater than eight units.
For this case, an external call ILI is generated to (depending on the
alignment)
one of
<code class="docutils literal notranslate"><span class="pre">c$bcopy</span></code>
(copy bytes),
<code class="docutils literal notranslate"><span class="pre">c$hcopy</span></code>
(copy half-words),
<code class="docutils literal notranslate"><span class="pre">c$wcopy</span></code>
(copy words),
or
<code class="docutils literal notranslate"><span class="pre">c$dcopy</span></code>
(copy double words).
These are procedure linkage routines whose
arguments are
<code class="docutils literal notranslate"><span class="pre">n</span></code>,
<code class="docutils literal notranslate"><span class="pre">a</span></code>,
and
<code class="docutils literal notranslate"><span class="pre">b</span></code>
where
<code class="docutils literal notranslate"><span class="pre">a</span></code>
and
<code class="docutils literal notranslate"><span class="pre">b</span></code>
are pointers to
<code class="docutils literal notranslate"><span class="pre">char</span></code>,
<code class="docutils literal notranslate"><span class="pre">short</span></code>,
<code class="docutils literal notranslate"><span class="pre">int</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">double</span></code>
and
<code class="docutils literal notranslate"><span class="pre">n</span></code>
is the number of bytes, half-words, words, or double words
to copy.  Note that 8 is approximately the number of
cycles for the call overhead &lt;this will change and needs to be
part of the MACHAR utility&gt;.</li>
</ol>
<p>Special ILMs called
<code class="docutils literal notranslate"><span class="pre">NCSELD</span></code>
and
<code class="docutils literal notranslate"><span class="pre">NCSEST</span></code>
are used to support the
<code class="docutils literal notranslate"><span class="pre">volatile</span></code>
type modifier of C.  When a load of a volatile location is generated,
it is covered by a
<code class="docutils literal notranslate"><span class="pre">NCSELD</span></code>
ILM.  This generates a special names entry
that forces the scheduler to always do the load (i.e., it is never
optimized out).</p>
<p>When a store to a volatile location is generated, the store is covered
by a
<code class="docutils literal notranslate"><span class="pre">NCSEST</span></code>
ILM.  This generates a special names entry that forces
the scheduler to always do the store.  Note that, since both store ILMs
and the
<code class="docutils literal notranslate"><span class="pre">NCSEST</span></code>
ILM are terminal, care must be taken to avoid calling
the
<code class="docutils literal notranslate"><span class="pre">check_ilm</span></code>
routine on the store when it is covered by a
<code class="docutils literal notranslate"><span class="pre">NCESST</span></code>
ILM.</p>
<div class="section" id="pseudo-stores">
<h4>Pseudo Stores<a class="headerlink" href="#pseudo-stores" title="Permalink to this headline">¶</a></h4>
<p>The pseudo store ILM,
<code class="docutils literal notranslate"><span class="pre">PSEDUOST</span></code>,
is generated by the semantic analyzer
for postfix operations. For example,
<code class="docutils literal notranslate"><span class="pre">i++</span></code>
causes a
<code class="docutils literal notranslate"><span class="pre">PSEUDOST</span></code>
to be
generated which will represent the original value of
<code class="docutils literal notranslate"><span class="pre">i</span></code>.
Subsequent uses of
<code class="docutils literal notranslate"><span class="pre">i</span></code>,
in particular the add, will locate this ILM.
The expander creates a pseudo store ILI which is one of
<code class="docutils literal notranslate"><span class="pre">FREEIR</span></code>,
<code class="docutils literal notranslate"><span class="pre">FREEAR</span></code>,
<code class="docutils literal notranslate"><span class="pre">FREESP</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">FREEDP</span></code>,
depending on the type of the register needed to load
<code class="docutils literal notranslate"><span class="pre">i</span></code>.
Subsequent references to this ILM will cause the expander to create
an ILI to ensure that the reference uses the original value of
<code class="docutils literal notranslate"><span class="pre">i</span></code>
instead
of the updated value of
<code class="docutils literal notranslate"><span class="pre">i</span></code>
(refer to section 6.3.6,
<em>Common ILM Expressions</em>).</p>
<p>The
<code class="docutils literal notranslate"><span class="pre">PSEUDOST</span></code>
ILM is also used to force the expander to evaluate expressions protected
by unary
<code class="docutils literal notranslate"><span class="pre">+</span></code>
as written without reordering.</p>
</div>
<div class="section" id="names-conflicts">
<h4>Names Conflicts<a class="headerlink" href="#names-conflicts" title="Permalink to this headline">¶</a></h4>
<p>In certain situations, the names entry created by normal processing may not
be sufficient for the detection of memory reference conflicts.
For example, consider the following program segment:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/\* (1) \*/   int a[2], k;
/\* (2) \*/   (double \*)&amp;a[0] = 0.0;
/\* (3) \*/   k = a[1];
</pre></div>
</div>
<p>The names entry created for
<code class="docutils literal notranslate"><span class="pre">a[0]</span></code>
indicates that it is an array reference
with a constant offset of 0.
Because of the double context at statement
(2),
<code class="docutils literal notranslate"><span class="pre">a[1]</span></code>
is also modified.
At statement (3), the names entry for
<code class="docutils literal notranslate"><span class="pre">a[1]</span></code>
is an array reference with
a constant offset of 4. This entry does not conflict with the names entry
for
<code class="docutils literal notranslate"><span class="pre">a[0]</span></code>.
For the reference at (2), the expander recognizes that a double reference
occurs on an entity which is not type double.
For this situation,
the expander changes the names reference for
<code class="docutils literal notranslate"><span class="pre">a[0]</span></code>
to one which
denotes an array reference with variable subscripts.
This names entry will conflict with the one at (3).</p>
<p>This processing occurs whenever:</p>
<ol class="arabic simple">
<li>the load or store operation is not double and the item involved is type double,
or the load or store operation is double and the item involved is not type
double, and</li>
<li>the names entry denotes an array with constant subscripts or an indirection
with constant subscripts.</li>
</ol>
</div>
</div>
<div class="section" id="common-ilm-expressions">
<h3>Common ILM Expressions<a class="headerlink" href="#common-ilm-expressions" title="Permalink to this headline">¶</a></h3>
<p>A common ILM expression occurs when an ILM has multiple references.
Common situations are prefix expressions and using the results of
assignments and postfix expressions.
For common ILMs, the expander must ensure that the
“value”
stored is the
one that is re-used.</p>
<p>When the store or pseudo store ILM is processed, the index locating the
terminal ILI generated for the ILM is saved away as the
“result”
of the ILM.
Also, the block id, a BIH index, of the ILI block containing the ILI is saved.
When the expander finds an ILM which has been evaluated (in
<code class="docutils literal notranslate"><span class="pre">eval_ilm</span></code>
while
recursively searching a terminal ILM’s links),
routine
<code class="docutils literal notranslate"><span class="pre">check_ilm</span></code>
is called to examine the
“result”
of the ILM.
If the block of the result is the same as the current block being created,
then all that has to be done is to create a cse (common subexpression) ILI
of the value being stored (this is always the first operand of the terminal
ILI).
This (cse) ILI replaces the result of the ILM which is being referenced and
is therefore the ILI used by the referencing ILM (note that subsequent
evaluations of this ILM will use the cse ILI).
The expander must guarantee that the scheduler will see the cse’d
ILI before it sees the cse ILI.
For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i = j = k;
</pre></div>
</div>
<p>results in the following ILM block:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> 0 BOS            3    17
 3 BASE          43            ;i
 5 BASE          44            ;j
 7 BASE          45            ;k
 9 ILD           7^
11 IST           5^    9^
14 IST           3^   11^
</pre></div>
</div>
<p>The ILM at (11) generates a store ILI which stores the value of
<code class="docutils literal notranslate"><span class="pre">k</span></code>
(a load
ILI of
<code class="docutils literal notranslate"><span class="pre">k</span></code>)
in
<code class="docutils literal notranslate"><span class="pre">j</span></code>.
For ILM (14), the value stored (the second operand) is the value of
ILM (11).
Since this ILM has already been evaluated, the new
“result”
of (11)
is a cse ILI of the value being stored (the load ILI of
<code class="docutils literal notranslate"><span class="pre">k</span></code>).
A cse ILI of the load ILI of
<code class="docutils literal notranslate"><span class="pre">k</span></code>
is the ILI which is accessed by the
store ILI for ILM (14).
Note that the scheduler will see the store of
<code class="docutils literal notranslate"><span class="pre">j</span></code>
before the store of
<code class="docutils literal notranslate"><span class="pre">i</span></code>.
Therefore, it will see the load of
<code class="docutils literal notranslate"><span class="pre">k</span></code>
before it sees its corresponding cse.</p>
<p>If the ILI occurs in a block which is not the current block, then
the expander must add to the block containing the ILI a temporary store
of a cse of the stored value.
The result of the ILM is replaced by a load of the temporary.
For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>\*p++ = flag ? 1 : 0;
</pre></div>
</div>
<p>results in the following ILM block (created ILI basic block
boundaries are denoted by
<code class="docutils literal notranslate"><span class="pre">---</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> 0 BOS            6    55
 3 BASE          45            ;p
 5 PLD           3^
 7 PSEUDOST       0    5^
10 ICON          35
12 PIADD         5^   10^     1
16 PST           3^   12^
19 BASE          44            ;flag
21 ILD          19^
23 BRF          21^    46
_____________________________________\_

26 BASE          47            ;.I0000
28 ICON          35
30 IST          26^   28^
33 BR            48
_____________________________________\_

35 LABEL         46
37 ICON          32
39 BASE          47            ;.I0000
41 ICON          32
43 IST          39^   41^
_____________________________________\_

46 LABEL         48
48 BASE          47            ;.I0000
50 ILD          48^
52 IST           7^   50^
</pre></div>
</div>
<p>In this case, the ILM at (52) references ILM (7) whose ILI is in a
different ILI block.
Therefore, the expander will add to the block containing the ILI for ILM
(7) a store into a temporary.
The value stored is just a cse of the ILI which does a load of
<code class="docutils literal notranslate"><span class="pre">p</span></code>.
ILM (52) will use a load of the temporary.</p>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>A function ILM exists for each scalar type and void type.
The ILMs are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>VFUNC</td>
<td>void</td>
</tr>
<tr class="row-even"><td>IFUNC</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>UIFUNC</td>
<td>unsigned int</td>
</tr>
<tr class="row-even"><td>RFUNC</td>
<td>float</td>
</tr>
<tr class="row-odd"><td>DFUNC</td>
<td>double</td>
</tr>
<tr class="row-even"><td>PFUNC</td>
<td>pointer</td>
</tr>
</tbody>
</table>
<p>A function ILM has the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;function ILM&gt;  n  lnk1  lnk\*
</pre></div>
</div>
<p>where,</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span></code></dt>
<dd>number of actual arguments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lnk1</span> <span class="pre">=</span></code></dt>
<dd>address expression which computes the address of the function
being called</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lnk\*</span> <span class="pre">=</span></code></dt>
<dd>zero or more links locate the arguments that are passed to the
function. These arguments are the actual values passed to the
function.</dd>
</dl>
<p>The
<code class="docutils literal notranslate"><span class="pre">VFUNC</span></code>
ILM is also used whenever a non-void function is called and
its value is discarded. The remaining ILMs are used in contexts which
access their values.</p>
<p>Processing a function ILM involves:</p>
<ol class="arabic">
<li><p class="first">possibly creating a dummy argument to keep the stack double word
aligned.</p>
</li>
<li><p class="first">looping through the argument links to generate ILI to push their
values on the stack.  The ILI generated are in the set
<code class="docutils literal notranslate"><span class="pre">IL_ARGIR</span></code>
(data
register),
<code class="docutils literal notranslate"><span class="pre">IL_ARGAR</span></code>
(address register),
<code class="docutils literal notranslate"><span class="pre">IL_ARGSP</span></code>
(single precision
floating register),
<code class="docutils literal notranslate"><span class="pre">IL_ARGDP</span></code>
(double precision floating register).</p>
</li>
<li><p class="first">generating the ILI to push the
argument count on the stack.</p>
</li>
<li><p class="first">generating the
“jsr”
ILI which links to the function address and
argument list address. This can be one of two ILI:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">JSR</span> <span class="pre">sym</span> <span class="pre">lnk</span></code>
— sym is the ST entry for the function (if
<code class="docutils literal notranslate"><span class="pre">lnk1</span></code>
locates an
<code class="docutils literal notranslate"><span class="pre">ACON</span></code>
ILI)</li>
<li><code class="docutils literal notranslate"><span class="pre">JSRA</span> <span class="pre">lnk</span> <span class="pre">lnk</span></code>
—
the first
<code class="docutils literal notranslate"><span class="pre">lnk</span></code>
locates the function address which is computed,
i.e.,
<code class="docutils literal notranslate"><span class="pre">(\*p)()</span></code></li>
</ul>
</div></blockquote>
<ol class="arabic">
<li><p class="first">If the function ILM is not void, the
“define result”
ILI
is generated which will link to the
“jsr”.
This is one of:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">DFRAR</span> <span class="pre">lnk</span> <span class="pre">0</span></code>
— pointer result; 0 indicates
<code class="docutils literal notranslate"><span class="pre">AR(0)</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">DFRIR</span> <span class="pre">lnk</span> <span class="pre">0</span></code>
— integer register result; 0 indicates
<code class="docutils literal notranslate"><span class="pre">IR(0)</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">DFRSP</span> <span class="pre">lnk</span> <span class="pre">0</span></code>
— single precision result; 0 indicates
<code class="docutils literal notranslate"><span class="pre">SP(0)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">DFRDP</span> <span class="pre">lnk</span> <span class="pre">0</span></code>
— double precision result; 0 indicates
<code class="docutils literal notranslate"><span class="pre">DP(0)</span></code>.</li>
</ul>
</div></blockquote>
</li>
</ol>
</li>
</ol>
<p>If the function is a
<code class="docutils literal notranslate"><span class="pre">VFUNC</span></code>
ILM, an ILT is created.
If the function is a
<code class="docutils literal notranslate"><span class="pre">PFUNC</span></code>
ILM, a names entry of type
<code class="docutils literal notranslate"><span class="pre">NT_UNK</span></code>
(unknown)
is created for the names result of the ILM.</p>
</div>
<div class="section" id="estmt-processing">
<h3>ESTMT Processing<a class="headerlink" href="#estmt-processing" title="Permalink to this headline">¶</a></h3>
<p>The
<code class="docutils literal notranslate"><span class="pre">ESTMT</span></code>
ILM is used for an expression whose result is not used (its
value is discarded).  This is particularly true for all but the rightmost
expression in a comma expression.
The ILI expression tree located by the
<code class="docutils literal notranslate"><span class="pre">ESTMT</span></code>’s
link is
searched for the functions. The result of this search is that
ILTs are created which reference just the function ILIs.
For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>a = ( f() + g(), b )

----  ILM  ----          ----  ILI ----

ESTMT   -----+          (1) JSR &quot;f&quot;
             |          (2) DFRIR (1) 0
             |          (3) JSR &quot;g&quot;
             |          (4) DFRIR (3) 0
             +-----&gt;    (5) IADD (4) (2)
</pre></div>
</div>
<p>Two ILT nodes are created for this ILM:  one locates the ILI at (1) and
the second locates the ILI at (3).</p>
</div>
<div class="section" id="comparison-and-relational-processing">
<h3>Comparison and Relational Processing<a class="headerlink" href="#comparison-and-relational-processing" title="Permalink to this headline">¶</a></h3>
<p>Comparison ILMs serve only as placeholders for the relational ILMs.
The appropriate ILM is generated by the semantic analyzer
which reflects the scalar data type of its operands.
The expander passes up the opcode of the equivalent ILI to the relational
ILM accessing the compare by saving away the opcode.
When the relational ILM is processed, the opcode and the compare’s
operands are extracted, and the value denoting the relation is computed.
The “compare for relation” ILI is then generated.
Note that the value indicating the
relation is an immediate value to the ILI.
This value is computed by relying on the following consecutive ordering
of the relational ILMs: EQ, NE, LT, GE, LE, and GT.
The respective values are 1, 2, 3, 4, 5, and 6.</p>
</div>
<div class="section" id="branch-processing">
<h3>Branch Processing<a class="headerlink" href="#branch-processing" title="Permalink to this headline">¶</a></h3>
<p>Most branch ILMs are expanded using
<code class="docutils literal notranslate"><span class="pre">exp_mac</span></code>.
Certain ILMs require special handling by the expander.
For now, there is just one ILM special cased — the
<code class="docutils literal notranslate"><span class="pre">SWITCH</span></code>
ILM.</p>
<p>The
<code class="docutils literal notranslate"><span class="pre">SWITCH</span></code>
ILM consists of the switch expression and the switch list (a
list of the switch labels including the default; refer to Section 12 for
a description of the switch list).
Simple heuristics are used to generate the ILIs for the
<code class="docutils literal notranslate"><span class="pre">SWITCH</span></code>.
There are
three cases:</p>
<ol class="arabic">
<li><p class="first">The number of cases in the switch is less than or equal to
four.
A sequence of conditional if’s is used to represent the switch:
For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (i) {
case 1: s1;
case 2: s2;
}
s3;
</pre></div>
</div>
<p>The ILIs generated are for a sequence of conditional if’s:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    if (i==1) goto l1;
    if (i==2) goto l2;
    goto l3:
l1: s1;
l2: s2;
l3: s3;
</pre></div>
</div>
</li>
<li><p class="first">The number of cases in the switch is greater than four and
less than or equal to 16, or
the case values consist of a set of dense values (many values —
80 percent —
which exist between the minimum and maximum values).</p>
<blockquote>
<div><p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (i) {
case 1: s1;
case 2: s2;
case 3: s3;
case 5: s5;
case 6: s6;
}
s7;
</pre></div>
</div>
<p>yields ILIs which select an entry from an address table.
The address table is a data initialized,
compiler created array, with a name of the form
<code class="docutils literal notranslate"><span class="pre">.Jxxxx</span></code>
where
<code class="docutils literal notranslate"><span class="pre">xxxx</span></code>
is a decimal number.
The address table consists of a series of addresses
where the first entry
is the address of
the default statement (c
<code class="docutils literal notranslate"><span class="pre">s7</span></code>
in the above example), the
second entry is the address of
the statement corresponding to the smallest case value
(c
<code class="docutils literal notranslate"><span class="pre">s1</span></code>
in the example), the third entry is the address of
the statement corresponding
to the next (increase of 1) case value (c
<code class="docutils literal notranslate"><span class="pre">s2</span></code>
in the example),
and so forth.
The index to the jump table is determined by adding to the switch
expression (in the above example,
<code class="docutils literal notranslate"><span class="pre">i</span></code>)
a value which normalizes
the switch value to 1.
This calulation results in the
minimum case value corresponding to the second entry (the first case
value) in the jump table. In the example, the value added is one.
If this value falls outside of the range
of 1 to n (n is the number of entries in the table including the default
entry), the default statement is branched to.
For the above example, the following ILIs are generated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        (1) IADD i &#39;1&#39;          &#39;1&#39; is a constant ST for the
                                value 1
        (2) JMPM (1) &#39;7&#39; tab    The table has 7 entries.
        ...
tab:    l7                      default
        l1                      case 1
        l2                      case 2
        l3                      case 3
        l7                      case 4 is default
        l5                      case 5
        l6                      case 6
</pre></div>
</div>
<p>An ILT is created for the JMPM ILI.</p>
</div></blockquote>
</li>
<li><p class="first">The number of cases in the switch is greater than 16 and the case
values are sparse.
In this case, ILIs are generated which will call the C support routine,
<code class="docutils literal notranslate"><span class="pre">c$i_switch</span></code>,
to perform the switch. Passed to the routine are the switch
expression and the
label list, which must be created by the expander module.
The label list is a compiler created symbol (an auto integer array)
whose name is
<code class="docutils literal notranslate"><span class="pre">.Jxxxx</span></code>
where
<code class="docutils literal notranslate"><span class="pre">xxxx</span></code>
is a decimal number.
The label list has the form:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>_</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>n</td>
<td>number of case value-label pairs</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>default label</td>
<td>label of default statment</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>case value\*&lt;1\*&gt;</td>
<td>value-label pair</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>^</td>
</tr>
<tr class="row-even"><td>case label\*&lt;1\*&gt;</td>
<td>for first entry</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>&amp;…</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>case value\*&lt;N\*&gt;</td>
<td>value-label pair</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>^</td>
</tr>
<tr class="row-even"><td>case label\*&lt;N\*&gt;</td>
<td>for Nth entry</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Note that the case values are in sorted (ascending) order.
An ILT node is created which locates the ILI representing the
call to the switch routine.</p>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="entry-processing">
<h3>Entry Processing<a class="headerlink" href="#entry-processing" title="Permalink to this headline">¶</a></h3>
<p>When an
<code class="docutils literal notranslate"><span class="pre">ENTRY</span></code>
ILM is processed, the following actions are performed:</p>
<ol class="arabic simple">
<li>A basic block is created. This will be the first block of the function.</li>
<li>The
<code class="docutils literal notranslate"><span class="pre">ENTRY</span></code>
ILI is generated. This ILI has two operands:
<code class="docutils literal notranslate"><span class="pre">pro</span></code>,
and
<code class="docutils literal notranslate"><span class="pre">func</span></code>,
respectively.
<code class="docutils literal notranslate"><span class="pre">pro</span></code>
is a symbol table item of type
<code class="docutils literal notranslate"><span class="pre">ST_FUNC</span></code>
which represents the C prologue
routine (
<code class="docutils literal notranslate"><span class="pre">c$i_entry</span></code>).
<code class="docutils literal notranslate"><span class="pre">func</span></code>
is the symbol table item of type
<code class="docutils literal notranslate"><span class="pre">ST_FUNC</span></code>
which represents the
entry.
Note that the first ILT in this block locates this ILI.</li>
<li>If exceptions are to be disabled and/or enabled, two constants are
created from the values of the global variables
<code class="docutils literal notranslate"><span class="pre">flg.xon</span></code>
and
<code class="docutils literal notranslate"><span class="pre">flg.xoff</span></code>.
The first represents the mask value used to enable exceptions
(by OR’ing). The second represents the mask value used
to disable exceptions (by AND’ing).
The method by which these exceptions are enabled and disabled
is machine dependent and is specified in the MACHAR utility.</li>
<li>If the debug option was selected, an ILT is created to locate the ILI
which calls the debugger routine
<code class="docutils literal notranslate"><span class="pre">dbg$i_entry</span></code>
&lt;this may change&gt;.</li>
</ol>
</div>
<div class="section" id="return-processing">
<h3>Return Processing<a class="headerlink" href="#return-processing" title="Permalink to this headline">¶</a></h3>
<p>When the
<code class="docutils literal notranslate"><span class="pre">RET</span></code>
or
<code class="docutils literal notranslate"><span class="pre">RETV</span></code>
ILM is processed, a jump ILI is created which
references the label (a compiler created symbol table item) of the
exit block. This label’s name is
<code class="docutils literal notranslate"><span class="pre">.Rxxxx</span></code>
where
<code class="docutils literal notranslate"><span class="pre">xxxx</span></code>
is a decimal
number.
Its symbol table index is stored in
<code class="docutils literal notranslate"><span class="pre">exp.retlbl</span></code>.
Only one return label is needed per function.
For the
<code class="docutils literal notranslate"><span class="pre">RETV</span></code>,
the appropriate move register ILI is generated to
move the function’s return value into a register prior to the jump.</p>
</div>
<div class="section" id="end-processing">
<h3>End Processing<a class="headerlink" href="#end-processing" title="Permalink to this headline">¶</a></h3>
<p>When the
<code class="docutils literal notranslate"><span class="pre">END</span></code>
ILM is processed, the following actions are performed:</p>
<ol class="arabic simple">
<li>If a return ILM was processed, a label would have been created which
is accessed by a
<code class="docutils literal notranslate"><span class="pre">JMP</span></code>
ILI.
That is, a return is turned into a jump to the block defined by the
return label.
Note that the same rules for the label specified in a
<code class="docutils literal notranslate"><span class="pre">LABEL</span></code>
ILM apply
to the return label (optimizing out, etc.).</li>
<li>If exceptions were modified, machine dependent exception
cleanup ILI are generated and
linked to by an ILT node.</li>
<li>If the debug option was selected, an ILT is created which locates the
ILI which calls the debugger routine
<code class="docutils literal notranslate"><span class="pre">dbg$i_exit</span></code>
&lt;this may change&gt;.</li>
<li>The
<code class="docutils literal notranslate"><span class="pre">EXIT</span></code>
ILI is generated. This ILI has one operand, a
<code class="docutils literal notranslate"><span class="pre">ST_FUNC</span></code>
symbol table item
representing the C epilogue routine
<code class="docutils literal notranslate"><span class="pre">c$i_exit</span></code>).
An ILT node locates this ILI.</li>
</ol>
</div>
<div class="section" id="miscellaneous">
<h3>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h3>
<p>The following ILMs are the remaining
“address”
producing ILMs which
require that each produces a names entry result in addition to an ILI
result:</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ACON</span></code>
— A names entry of type
<code class="docutils literal notranslate"><span class="pre">NT_VAR</span></code>
is created. The symbol field is set
to the address constant.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">IPTR</span></code>
— This ILM converts an integer value to a pointer value. The names
entry created is type
<code class="docutils literal notranslate"><span class="pre">NT_UNK</span></code>
(unknown).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">LOC</span></code>
— This ILM
“passes”
up the ILI and names entry located by its link.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">PIADD/PISUB</span></code>
— These ILMs call the
<code class="docutils literal notranslate"><span class="pre">addnme</span></code>
routine with the template</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;NT_ADD, ptr, bnme, cnst&gt; .
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NT_ADD</span></code>
indicates that addnme is to add
<code class="docutils literal notranslate"><span class="pre">bnme</span></code>
(the name entry of the address ILI located by the first ILM link)
to the
“value”
denoted by
<code class="docutils literal notranslate"><span class="pre">ptr</span></code>
and
<code class="docutils literal notranslate"><span class="pre">cnst</span></code>.
<code class="docutils literal notranslate"><span class="pre">ptr</span></code>
is zero if a constant is
being added (c
<code class="docutils literal notranslate"><span class="pre">cnst</span></code>
is the constant value in the
<code class="docutils literal notranslate"><span class="pre">PIADD</span></code>
or
the negative of the
constant value in the
<code class="docutils literal notranslate"><span class="pre">PISUB</span></code>),
and (mi1 if a non-constant
is being added.</p>
</li>
</ol>
</div>
<div class="section" id="program-units">
<h3>Program Units<a class="headerlink" href="#program-units" title="Permalink to this headline">¶</a></h3>
<p>The expander module is composed of four C files:
<em>expdf.c</em>,
<em>expand.c</em>,
<em>exp_clang.c</em>, and
<em>exputil.c</em>.
The file
<em>expdf.c</em>
contains
the definitions and static initializations of the data structures
required by the expander.</p>
<p>The file
<em>expand.c</em>
contains the following routines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void exp_init()
</pre></div>
</div>
<ul class="simple">
<li>Initialize the expander module: allocates space for the ILM, ILI, ILT, BIH,
and NME areas. Clears the zeroth entry for the ILT and BIH areas (refer
to section 13). The
“noblock”
flag in the expander local data area is set on
(no current block exists). The ILM file is rewound.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void expand()
</pre></div>
</div>
<ul class="simple">
<li>Main expander routine called by the program controller.
This routine reads in a block of ILMs and scans the block for terminal
ILMs.  When one is found, it calls
<code class="docutils literal notranslate"><span class="pre">eval_ilm</span></code>
to evaluate the terminal ILM
which in turn evaluates all of its operands.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void eval_ilm(ilmx)
int ilmx;
</pre></div>
</div>
<ul class="simple">
<li>This routine controls evaluates the ILM
indexed by
<code class="docutils literal notranslate"><span class="pre">ilmx</span></code>
and all of its operands.
When the operands have been evaluated,
<em>eval_ilm</em>
sets up the following static variables for use by the various subordinate
expand routines:
<code class="docutils literal notranslate"><span class="pre">ilmp</span></code>     pointer to the current ILM
<code class="docutils literal notranslate"><span class="pre">opc</span></code>      opcode of the current ILM
<code class="docutils literal notranslate"><span class="pre">curilm</span></code>   index of the current ILM
<code class="docutils literal notranslate"><span class="pre">eval_ilm</span></code>
selects the appropriate action depending on the ILM
attributes.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_estmt(ilmx)
int ilmx;
</pre></div>
</div>
<ul class="simple">
<li>Expands the
<code class="docutils literal notranslate"><span class="pre">ESTMT</span></code>
ILM.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_label(lbl)
int lbl;
</pre></div>
</div>
<ul class="simple">
<li>Expands the
<code class="docutils literal notranslate"><span class="pre">LABEL</span></code>
ilm.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_load(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the load ILMs.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_store(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the store ILMs.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_mac(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the non-special case ILMs using the templates defined using the
ILITP utility.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_ref(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the reference ILMs (except for
<code class="docutils literal notranslate"><span class="pre">ELEMENT</span></code>)
and creates names
entries.</li>
</ul>
<p>The C module file,
<em>exp_clang.c</em>, contains:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_ac(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the arithmetic and constant ILMs.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_array(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the
<code class="docutils literal notranslate"><span class="pre">ELEMENT</span></code>
ILM and creates names entries.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_bran(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the branch ILMs, particulary the switch.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_call(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the call ilms.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
exp_misc(opc, ilmp, curilm)
int opc;
ILM \*ilmp;
int curilm;
</pre></div>
</div>
<ul class="simple">
<li>Expands the miscellanous ILMs.</li>
</ul>
<p>The C module file,
<em>exputil.c</em>,
contains:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int mkfunc(name)
char \*name;
</pre></div>
</div>
<ul class="simple">
<li>Creates a symbol table entry of type function given the name and returns
its index.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cr_block()
</pre></div>
</div>
<ul class="simple">
<li>Creates a BIH. Sets
<code class="docutils literal notranslate"><span class="pre">exp.curbih</span></code>
to its index and defines its line number.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>wr_block()
</pre></div>
</div>
<ul class="simple">
<li>Terminates the block defined by
<code class="docutils literal notranslate"><span class="pre">exp.curbih</span></code>.
Sets the first and last
fields of the BIH. Sets the
“noblock”flag in
<code class="docutils literal notranslate"><span class="pre">exp</span></code>
to 1 (no block currently
exists).</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
flsh_block()
</pre></div>
</div>
<ul class="simple">
<li></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
chk_block(ilix)
int ilix;
</pre></div>
</div>
<ul class="simple">
<li>Checks to see if the ILI (located by
<code class="docutils literal notranslate"><span class="pre">ilix</span></code>)
will terminate the current block.
If it will terminate the block, the block is terminated and the
“noblock”
flag in
<code class="docutils literal notranslate"><span class="pre">exp</span></code>
is set to 1. Otherwise, an ILT is created for the ILI
and added to the current block.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int
check_ilm(ilmx)
int ilmx;
</pre></div>
</div>
<ul class="simple">
<li>Checks the ILM (located by
<code class="docutils literal notranslate"><span class="pre">ilmx</span></code>)
which has already been evaluated.
Actions are performed to ensure that the ILI originally generated for the
ILM is treated as a common subexpression or is used if
across block boundaries.  Special care is take not to call this
routine for store ILMs covered by the
<code class="docutils literal notranslate"><span class="pre">NCSEST</span></code>
ILM.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int mk_swlist(n, swhdr)
INT n;
SWEL \*swhdr
</pre></div>
</div>
<ul class="simple">
<li>Makes the address/value table for the switch statement.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int mk_swtab(n, swhdr)
INT n;
SWEL \*swhdr
</pre></div>
</div>
<ul class="simple">
<li>Makes the address table for the switch statement.</li>
</ul>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="controller.html">Program Controller</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ilm.html">ILMs</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>