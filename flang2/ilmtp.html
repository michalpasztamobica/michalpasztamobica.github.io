
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Appendix IV - ILM Definitions &#8212; Flang 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="X86-64 ILI Definitions" href="ilitp.html" />
    <link rel="prev" title="Symbol Table" href="symtab.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Flang 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Appendix IV - ILM Definitions</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="symtab.html">Symbol Table</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ilitp.html">X86-64 ILI Definitions</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="appendix-iv-ilm-definitions">
<h1>Appendix IV - ILM Definitions<a class="headerlink" href="#appendix-iv-ilm-definitions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="ilm-definitions">
<h2>ILM Definitions<a class="headerlink" href="#ilm-definitions" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first"><strong>BOS</strong> stc1 stc2 stc3    <em>Type</em>: <em>misc</em></p>
<p>Always (and only) appears as the first ILM of an ILM block.
(roughly corresponds to the beginning of a source statement.)</p>
<div class="line-block">
<div class="line">stc1 - source statement line number (negated for insert files?).</div>
<div class="line">If more than one ILM block is written for a given</div>
<div class="line">statement, all but the first have 0 specified for the</div>
<div class="line">line number.</div>
<div class="line">For typical statements, this is actually the line</div>
<div class="line">number of the terminating ‘;’.</div>
<div class="line">stc2 - current file index, default is 1.</div>
<div class="line">stc3 - number of words for this ILM block (including the BOS).</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>FLOAT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert integer to real number (REAL and FLOAT intrinsics).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FLOAT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DFLOAT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert integer to double precision (DFLOAT intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DFLOAT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CTOI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned character to signed integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CTOI</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SCTOI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned character to signed integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>STOI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert short to signed integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>USTOI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned short to signed integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CTOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned character to unsigned integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>SCTOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert signed character to unsigned integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ITOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert signed integer to unsigned integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UITOI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned integer to signed integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>STOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert short to unsigned integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>USTOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned short to unsigned integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDTOUDI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DP2KR r rp1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CTOUDI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SP2IR t1 rp1
UIKMV r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DTOUDI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DP2KR r rp1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DTOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DP2KR t1 p1
KIMV r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UDCON</strong> sym    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UDITOD</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KR2DP r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UDITOR</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV t1 p1
IR2SP r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UDITOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UDITOSC</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UDITOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UITOD</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV t1 p1
KR2DP r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UITOR</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IR2SP r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UITOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UITOSC</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UITOUDI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ITOUDI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a 32-bit integer to a 64-bit unsigned integer (dword).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>SCTOUDI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a 8 bit integer quantity to a 64-bit unsigned integer (dword).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>STOUDI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a 16 bit integer quantity to a 64-bit quantity.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UDITOI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast an unsigned double integer (dword) to a 32-bit signed integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>RTOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a real to a 32-bit unsigned integer (word).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SP2IR r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>RTOUDI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a real to a 64-bit unsigned integer (dword).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SP2IR t1 p1
UIKMV r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CRTOI</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a complex to integer (C)</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDTOI</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>UITOC</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned integer to unsigned character.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;255
AND r t1 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ITOSC</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert signed integer to signed character.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>ITOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert integer to short.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UITOUS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned integer to unsigned short.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;65535
AND r t1 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>FLOATU</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned integer to real.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV t1 p1
FLOATK r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DFLOATU</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned to double.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV t1 p1
DFLOATK r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>RTOR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FPOWF r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>VRTOR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
</li>
<li><p class="first"><strong>DTOD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DPOWD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CTOC</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDTOCD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>FIX</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert real number to integer (INT and IFIX intrinsics).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FIX r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>FIXU</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert real number to unsigned.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FIXK t1 p1
KIMV r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DBLE</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert single precision floating point value to double precision.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DBLE r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DFIX</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert double precision floating point number to integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DFIX r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DFIXU</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert double precision floating point number to
unsigned integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DFIXK t1 p1
KIMV r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>REAL</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Returns real part of complex number (single precision).</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVSP r rp1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DREAL</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Returns double precision real part of a double complex value.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVDP r rp1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IMAG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Returns imaginary part of complex value (single precision)
(AIMAG intrinsic).</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVSP r ip1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DIMAG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Returns double precision imaginary part of a double complex value
(DIMAG intrinsic).</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVDP r ip1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CMPLX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Form complex number out of two single precision real values.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DCMPLX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Form double complex number out of two double precision real values.</p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>ICHAR</strong> lnk    <em>Type</em>: <em>fstr</em></p>
<p>Converts single character to integer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>INCHAR</strong> lnk    <em>Type</em>: <em>fstr</em></p>
<p>Converts single ncharacter to integer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CHAR</strong> lnk    <em>Type</em>: <em>fstr</em></p>
<p>Converts integer to character string of length 1.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>NCHAR</strong> lnk    <em>Type</em>: <em>fstr</em></p>
<p>Converts integer to ncharacter string of length 1.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>AINT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>AINT intrinsic (converts real to real).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>AINT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DINT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>DINT intrinsic (converts double to double).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DINT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ANINT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>ANINT intrinsic (converts real to real).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_anint t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DNINT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>DNINT intrinsic (converts double to double).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dnint t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>NINT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>NINT intrinsic (converts real to integer).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NINT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IDNINT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>IDNINT intrinsic (converts double to integer).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IDNINT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ZEXTB</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Zero extend byte (ZEXT intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;255
AND r t1 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ZEXTS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Zero extend short (ZEXT intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;65535
AND r t1 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IABS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IABS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ABS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Absolute value of single precision real number.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FABS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DABS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DABS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CABS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DBLE t1 rp1
DBLE t2 ip1
DMUL t1 t1 t1
DMUL t2 t2 t2
DADD t3 t1 t2
DSQRT t3 t3
SNGL r t3
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDABS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 ip1 dp(0) t1
DADP t2 rp1 dp(1) t1
QJSR t3 =e&#39;%d%__mth_i_cdabs t2
DFRDP r t3 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>LEN</strong> lnk    <em>Type</em>: <em>fstr</em></p>
<p>Length of a character expression.  This ILM contains a link to
one character expression.
The result returned is the sum of the lengths of its operands.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>NLEN</strong> lnk    <em>Type</em>: <em>fstr</em></p>
<p>Length of ncharacter expr.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CONJG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Conjugate of a single precision complex number.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVSP rr rp1 iv-1
FNEG ir ip1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DCONJG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Conjugate of a double complex number.</p>
<p><em>Attributes</em>: spec dcmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVDP rr rp1 iv-1
DNEG ir ip1
</pre></div>
</div>
</li>
<li><p class="first"><strong>SQRT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Square root of a single precision real number (SQRT intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FSQRT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DSQRT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DSQRT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CSQRT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDSQRT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>EXP</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>EXP intrinsic for single precision floating point values.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FEXP r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DEXP</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DEXP r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CEXP</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDEXP</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CACOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDACOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CASIN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDASIN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CATAN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDATAN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CCOSH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDCOSH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CSINH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDSINH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CTANH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDTANH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CTAN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDTAN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>ALOG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FLOG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DLOG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DLOG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CLOG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDLOG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>ALOG10</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FLOG10 r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DLOG10</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DLOG10 r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>SIN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Sine of a single precision value</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FSIN r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DSIN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DSIN r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CSIN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDSIN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>COS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cosine of a single precision number</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FCOS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DCOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DCOS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CCOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDCOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>TAN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Tangent of a single precision value</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FTAN r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DTAN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DTAN r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ASIN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FASIN r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DASIN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DASIN r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ACOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FACOS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DACOS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DACOS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ATAN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FATAN r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DATAN</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DATAN r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ATAN2</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FATAN2 r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DATAN2</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DATAN2 r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>SIND</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>SIN in degrees.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_sind t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DSIND</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dsind t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>COSD</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>COS in degrees.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_cosd t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DCOSD</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dcosd t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>TAND</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>TAN in degrees.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_tand t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DTAND</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dtand t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ASIND</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>ASIN in degrees.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_asind t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DASIND</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dasind t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ACOSD</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>ACOS in degrees.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_acosd t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DACOSD</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dacosd t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ATAND</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>ATAN in degrees.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_atand t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DATAND</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_datand t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ATAN2D</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>ATAN2 in degrees.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p2 sp(1) t1
DASP t2 p1 sp(0) t1
QJSR t3 =e&#39;%s%__mth_i_atan2d t2
DFRSP r t3 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DATAN2D</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p2 dp(1) t1
DADP t2 p1 dp(0) t1
QJSR t3 =e&#39;%d%__mth_i_datan2d t2
DFRDP r t3 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>SINH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FSINH r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DSINH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DSINH r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>COSH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FCOSH r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DCOSH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DCOSH r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>TANH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FTANH r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DTANH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DTANH r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ERF</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_erf t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DERF</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_derf t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ERFC</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_erfc t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DERFC</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_derfc t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ERFC_SCALED</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_erfc_scaled t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DERFC_SCALED</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_derfc_scaled t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>GAMMA</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_gamma t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DGAMMA</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dgamma t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>LOG_GAMMA</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_log_gamma t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DLOG_GAMMA</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dlog_gamma t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>HYPOT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p2 sp(1) t1
DASP t2 p1 sp(0) t1
QJSR t3 =e&#39;%s%__mth_i_hypot t2
DFRSP r t3 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DHYPOT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p2 dp(1) t1
DADP t2 p1 dp(0) t1
QJSR t3 =e&#39;%d%__mth_i_dhypot t2
DFRDP r t3 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ACOSH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_acosh t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DACOSH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dacosh t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ASINH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_asinh t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DASINH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dasinh t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ATANH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_atanh t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DATANH</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_datanh t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>BESSEL_J0</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_bessel_j0 t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DBESSEL_J0</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dbessel_j0 t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>BESSEL_J1</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_bessel_j1 t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DBESSEL_J1</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dbessel_j1 t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>BESSEL_JN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p2 sp(0) t1
DAIR t2 p1 dr(0) t1
QJSR t3 =e&#39;%s%__mth_i_bessel_jn t2
DFRSP r t3 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DBESSEL_JN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p2 dp(0) t1
DAIR t2 p1 dr(0) t1
QJSR t3 =e&#39;%d%__mth_i_dbessel_jn t2
DFRDP r t3 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>BESSEL_Y0</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_bessel_y0 t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DBESSEL_Y0</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dbessel_y0 t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>BESSEL_Y1</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%s%__mth_i_bessel_y1 t1
DFRSP r t2 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DBESSEL_Y1</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%d%__mth_i_dbessel_y1 t1
DFRDP r t2 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>BESSEL_YN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p2 sp(0) t1
DAIR t2 p1 dr(0) t1
QJSR t3 =e&#39;%s%__mth_i_bessel_yn t2
DFRSP r t3 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DBESSEL_YN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p2 dp(0) t1
DAIR t2 p1 dr(0) t1
QJSR t3 =e&#39;%d%__mth_i_dbessel_yn t2
DFRDP r t3 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>SNGL</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert double precision number to single precision (SNGL intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SNGL r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IPTR</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Converts integral value to pointer.
The ili created is:
IAMV r p1</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>KPTR</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Converts long (64-bit) value to pointer.
The ili created is:
KAMV r p1</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PTRI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Converts pointer to an integral value
The ili created is:
AIMV r p1</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PTRK</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Converts pointer to a long (64-bit) value
The ili created is:
AKMV r p1</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>INEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer negation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INEG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UINEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INEG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>RNEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FNEG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DNEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DNEG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CNEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FNEG rr rp1
FNEG ir ip1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDNEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Double complex negation.</p>
<p><em>Attributes</em>: spec dcmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DNEG rr rp1
DNEG ir ip1
</pre></div>
</div>
</li>
<li><p class="first"><strong>NOT64</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise negation of 64 bit value (NOT intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KNOT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>NOT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise negation of 32 bit signed value (NOT intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NOT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UNOT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise negation of 32 bit unsigned value.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UNOT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>LNOT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical negation.  The link must be to an expression of type
integer, float, or pointer.
The value is 1 if link is zero (0.0, or NULL); otherwise, the value is 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ r p1 eq
</pre></div>
</div>
</li>
<li><p class="first"><strong>LNOT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical negation.  The link must be to an expression of type
LOGICAL; depends on internal representation of logical values (VAX or
UNIX)</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DLNOT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical negation, where the link is an expression of type double.
The value is 1 if link is zero; otherwise, it is 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DCMPZ r p1 eq
</pre></div>
</div>
</li>
<li><p class="first"><strong>LNOP</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical no-op.  Used by semant when space must be reserved
for a potential LNOT ILM.
Returns 1 if its operand is non-zero, else 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ r p1 ne
</pre></div>
</div>
</li>
<li><p class="first"><strong>LNOP</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical noop.  Used by semant when space must be reserved
for a potential LNOT ILM.  ‘lnk’ points to a logical
expression.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IMERGE</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer valued f90 merge intrinsic.</p>
<div class="line-block">
<div class="line">p1 - tsource</div>
<div class="line">p2 - fsource</div>
<div class="line">p3 - mask</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p3 ne
ISELECT r t1 p2 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KMERGE</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer*8 valued f90 merge intrinsic.</p>
<div class="line-block">
<div class="line">p1 - tsource</div>
<div class="line">p2 - fsource</div>
<div class="line">p3 - mask</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p3 ne
KSELECT r t1 p2 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>RMERGE</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Real valued f90 merge intrinsic.</p>
<div class="line-block">
<div class="line">p1 - tsource</div>
<div class="line">p2 - fsource</div>
<div class="line">p3 - mask</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p3 ne
FSELECT r t1 p2 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DMERGE</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Real*8 valued f90 merge intrinsic.</p>
<div class="line-block">
<div class="line">p1 - tsource</div>
<div class="line">p2 - fsource</div>
<div class="line">p3 - mask</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p3 ne
DSELECT r t1 p2 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CMERGE</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Real*4 complex valued f90 merge intrinsic.</p>
<div class="line-block">
<div class="line">p1 - tsource</div>
<div class="line">p2 - fsource</div>
<div class="line">p3 - mask</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p3 ne
CSSELECT r t1 p2 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDMERGE</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Real*8 complex valued f90 merge intrinsic.</p>
<div class="line-block">
<div class="line">p1 - tsource</div>
<div class="line">p2 - fsource</div>
<div class="line">p3 - mask</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p3 ne
CDSELECT r t1 p2 p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IADD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIADD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FADD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DADD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FADD rr rp1 rp2
FADD ir ip1 ip2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DADD rr rp1 rp2
DADD ir ip1 ip2
</pre></div>
</div>
</li>
<li><p class="first"><strong>PIADD</strong> lnk1 lnk2 stc    <em>Type</em>: <em>arth</em></p>
<p>Add pointer (lnk1) to integer (lnk2) creating a new pointer value.
‘stc’ locates a data type item describing the type which
the pointer (lnk1) points to.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 scz3
IMUL t2 t1 p2
IAMV t3 t2
AADD r p1 t3 scf3
</pre></div>
</div>
</li>
<li><p class="first"><strong>PKADD</strong> lnk1 lnk2 stc    <em>Type</em>: <em>arth</em></p>
<p>Add pointer (lnk1) to long (lnk2) creating a new pointer value.
‘stc’ locates a data type item describing the type which
the pointer (lnk1) points to.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 scz3
IKMV t1 t1
KMUL t2 t1 p2
KAMV t3 t2
AADD r p1 t3 scf3
</pre></div>
</div>
</li>
<li><p class="first"><strong>ISUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ISUB r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UISUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UISUB r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RSUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FSUB r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DSUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DSUB r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CSUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FSUB rr rp1 rp2
FSUB ir ip1 ip2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDSUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DSUB rr rp1 rp2
DSUB ir ip1 ip2
</pre></div>
</div>
</li>
<li><p class="first"><strong>PSUB</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Subtract two pointers (of the same type).
‘stc’ locates a data type item describing the type which
the pointer (lnk1) points to.
The result of this operation is an
integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ASUB t1 p1 p2 iv0
AKMV t2 t1
ICON t1 sz3
IKMV t1 t1
KDIVZR r t2 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>PISUB</strong> lnk1 lnk2 stc    <em>Type</em>: <em>arth</em></p>
<p>Substract integer (lnk2) from a pointer (lnk1) creating a new
pointer value.
‘stc’ locates a data type item describing the type which
the pointer (lnk1) points to.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 scz3
IMUL t2 t1 p2
IAMV t3 t2
ASUB r p1 t3 scf3
</pre></div>
</div>
</li>
<li><p class="first"><strong>PKSUB</strong> lnk1 lnk2 stc    <em>Type</em>: <em>arth</em></p>
<p>Substract long (lnk2) from a pointer (lnk1) creating a new
pointer value.
‘stc’ locates a data type item describing the type which
the pointer (lnk1) points to.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 scz3
IKMV t1 t1
KMUL t2 t1 p2
KAMV t3 t2
ASUB r p1 t3 scf3
</pre></div>
</div>
</li>
<li><p class="first"><strong>IMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FMUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DMUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FMUL t1 rp1 rp2
FMUL t2 ip1 ip2
FMUL t3 ip1 rp2
FMUL t4 ip2 rp1
FSUB rr t1 t2
FADD ir t3 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DMUL t1 rp1 rp2
DMUL t2 ip1 ip2
DSUB rr t1 t2
DMUL t1 ip1 rp2
DMUL t2 ip2 rp1
DADD ir t2 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IDIV r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIDIV r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FDIV r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DDIV r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDIVR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FDIV rr rp1 p2
FDIV ir ip1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CDDIVD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DDIV rr rp1 p2
DDIV ir ip1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>ITOI</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Exponentiation - integer to an integer power.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IPOWI r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RTOI</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FPOWI r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DTOI</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DPOWI r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>MOD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer remainder</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MOD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>MOD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer remainder (MOD intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MOD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIMOD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIMOD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>AMOD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FMOD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DMOD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DMOD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>ISIGN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p2 lt
IABS t2 p1
INEG t3 t2
ISELECT r t1 t2 t3
</pre></div>
</div>
</li>
<li><p class="first"><strong>SIGN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Real valued SIGN intrinsic.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FCMPZ t1 p2 lt
FABS t2 p1
FNEG t3 t2
FSELECT r t1 t2 t3
</pre></div>
</div>
</li>
<li><p class="first"><strong>DSIGN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DCMPZ t1 p2 lt
DABS t2 p1
DNEG t3 t2
DSELECT r t1 t2 t3
</pre></div>
</div>
</li>
<li><p class="first"><strong>IDIM</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAIR t1 p2 dr(1) t1
DAIR t2 p1 dr(0) t1
QJSR t3 =e&#39;%i%ftn_i_idim t2
DFRIR r t3 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DIM</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Real valued DIM intrinsic.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p2 sp(1) t1
DASP t2 p1 sp(0) t1
QJSR t3 =e&#39;%s%ftn_i_dim t2
DFRSP r t3 spret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DDIM</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p2 dp(1) t1
DADP t2 p1 sp(0) t1
QJSR t3 =e&#39;%d%ftn_i_ddim t2
DFRDP r t3 dpret
</pre></div>
</div>
</li>
<li><p class="first"><strong>DPROD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Multiply two single precision real values and return double
precision value. (DPROD intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DBLE t1 p1
DBLE t2 p2
DMUL r t1 t2
</pre></div>
</div>
</li>
<li><p class="first"><strong>IMAX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMAX r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIMAX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIMAX r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RMAX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FMAX r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DMAX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DMAX p p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>IMIN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMIN r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIMIN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIMIN r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RMIN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FMIN r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DMIN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DMIN r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>INDEX</strong> lnk lnk    <em>Type</em>: <em>fstr</em></p>
<p>INDEX intrinsic (inputs are two character strings and result is an integer).</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>QJSR t1 =e&#39;%i%ftn_index iv0
DFRIR r t1 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>NINDEX</strong> lnk lnk    <em>Type</em>: <em>fstr</em></p>
<p>Same as INDEX except for ncharacter strings.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>QJSR t1 =e&#39;%i%ftn_nindex iv0
DFRIR r t1 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>AND64</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise logical and of two 64 bit values (AND intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KAND r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>AND</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise logical and of two 32 bit values (AND intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>AND r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>OR64</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise logical or of two 64-bit values (OR instrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KOR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>OR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise logical or of two 32 bit values (OR intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>OR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>XOR64</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise exclusive or of two 64 bit values (NEQV intrinsic)</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KXOR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>XOR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise exclusive or of two 32 bit values (^ operator / EOR intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>XOR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>XNOR64</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise exclusive nor of two 64 bit values (EQV intrinsic)</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KXOR t1 p1 p2
KNOT r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>EQV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise complement of the exclusive or of two 32 bit values</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>XOR t1 p1 p2
NOT r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>LSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Left shift operator (&lt;&lt;) - first operand is 32 bit signed integer
value and second is a positive integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LSHIFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Right shift operator (&gt;&gt;).  First operand is 32 bit signed integer
value and second is assumed to be a positive integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RSHIFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KRSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KARSHIFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>ULSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Left shift operator (&lt;&lt;) - first operand is 32 bit unsigned integer
value and second is a positive integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ULSHIFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>URSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Right shift operator (&gt;&gt;).  First operand is 32 bit unsigned integer
value and second is assumed to be a positive integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>URSHIFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>SHIFT64</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>SHIFT intrinsic - first operand is 64 bit value and second is a positive
or negative integer shift count.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAIR t1 p2 dr(1) t1
DAKR t1 p1 dr(0) t1
QJSR t2 =e&#39;%l%ftn_i_kishft t1
DFRKR r t2 krret
</pre></div>
</div>
</li>
<li><p class="first"><strong>SHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>SHIFT intrinsic - first operand is 32 bit value and second is positive or
negative integer shift count (not constants).
When the second operand is a constant, ULSHIFT or URSHIFT is used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAIR t1 p2 dr(1) t1
DAIR t2 p1 dr(0) t1
QJSR t2 =e&#39;%i%ftn_i_shift t2
DFRIR r t2 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>I1SHFT</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p>ISHFT intrinsic - first operand is 8 bit value and second is positive or
negative integer shift count. If the shift count &lt;= -8 or &gt;=8, the
result is 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAIR t1 p2 dr(1) t1
DAIR t2 p1 dr(0) t1
QJSR t2 =e&#39;%i%ftn_i_i1shft t2
DFRIR r t2 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>IISHFT</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p>ISHFT intrinsic - first operand is 16 bit value and second is positive or
negative integer shift count. If the shift count &lt;= -16 or &gt;=16, the
result is 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAIR t1 p2 dr(1) t1
DAIR t2 p1 dr(0) t1
QJSR t2 =e&#39;%i%ftn_i_iishft t2
DFRIR r t2 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>JISHFT</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p>ISHFT intrinsic - first operand is 32 bit value and second is positive or
negative integer shift count. If the shift count &lt;= -32 or &gt;=32, the
result is 0.  Expand will convert JISHFT ili to a ULSHIFT, URSHIFT, or
a call.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>JISHFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>LAND</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .AND. operation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>AND r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>VSLAND</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Vector 16-bit logical and</p>
</li>
<li><p class="first"><strong>LOR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical or.
This opcode is for use within the Semantic Analyzer only, and should
never appear in the ILM’s sent to the Expander.</p>
</li>
<li><p class="first"><strong>LOR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .OR. operation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>OR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>LEQV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .EQV. operation.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMP r p1 p2 eq
</pre></div>
</div>
</li>
<li><p class="first"><strong>LNEQV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .NEQV. operation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>XOR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>I1SHFTC</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>ISHFTC(p1, p2, p3) - circularly shift the rightmost p3 bits of p1
by p2, where p1 is a 8-bit interger</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAIR t1 p3 dr(2) t1
DAIR t2 p2 dr(1) t1
DAIR t3 p1 dr(0) t2
QJSR t1 =e&#39;%i%ftn_i_i1shftc t3
DFRIR r t1 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>IISHFTC</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>ISHFTC(p1, p2, p3) - circularly shift the rightmost p3 bits of p1
by p2, where p1 is a 16-bit interger</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAIR t1 p3 dr(2) t1
DAIR t2 p2 dr(1) t1
DAIR t3 p1 dr(0) t2
QJSR t1 =e&#39;%i%ftn_i_iishftc t3
DFRIR r t1 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>ISHFTC</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>ISHFTC(p1, p2, p3) - circularly shift the rightmost p3 bits of p1
by p2.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAIR t1 p3 dr(2) t1
DAIR t2 p2 dr(1) t1
DAIR t3 p1 dr(0) t2
QJSR t1 =e&#39;%i%ftn_ishftc t3
DFRIR r t1 drret
</pre></div>
</div>
</li>
<li><p class="first"><strong>IBITS</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>IBITS(p1, p2, p3) - extract p3 bits beginning at p2 from p1.</p>
<div class="line-block">
<div class="line">r = p3 != 0 ? (p1 &gt;&gt; p2) &amp; (-1 &gt;&gt; (32 - p3)) : 0</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RSHIFT t1 p1 p2
ICON t2 =i&#39;-1
ICON t3 =i&#39;32
ISUB t4 t3 p3
URSHIFT t5 t2 t4
AND t6 t1 t5
ICMPZ t7 p3 eq
ISELECT r t7 t6 p3
</pre></div>
</div>
</li>
<li><p class="first"><strong>IBSET</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>IBSET(p1, p2) - set bit p2 of p1 to 1.</p>
<div class="line-block">
<div class="line">r = p1 | (1 &lt;&lt; p2)</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
LSHIFT t2 t1 p2
OR r p1 t2
</pre></div>
</div>
</li>
<li><p class="first"><strong>BTEST</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>BTEST(p1, p2) - .TRUE. if bit p2 of p1 is 1.</p>
<div class="line-block">
<div class="line">r = (p1 &amp; (1 &lt;&lt; p2)) != 0</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
LSHIFT t2 t1 p2
AND t3 p1 t2
ICMPZ r t3 ne
</pre></div>
</div>
</li>
<li><p class="first"><strong>IBCLR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>IBLCR(p1, p2) - clear bit p2 of p1.</p>
<div class="line-block">
<div class="line">r = p1 &amp; ~(1 &lt;&lt; p2)</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
LSHIFT t2 t1 p2
NOT t3 t2
AND r p1 t3
</pre></div>
</div>
</li>
<li><p class="first"><strong>RFLOOR</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>FLOOR of real to real</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FFLOOR r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DFLOOR</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>FLOOR of double to double</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DFLOOR r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>RCEIL</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>CELING of real to real</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FCEIL r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DCEIL</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>CELING of double to double</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DCEIL r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ICMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer comparision of two integer numbers.
The compare ILMs are used only in the context of a relational expression
and do not by themselves generate code.
A compare ILM passes up the opcode of the compare ILI which reflects the
data type of the operands to the relational ILM.
When the relational ILM using the compare ILM is processed,
the appropriate code is generated.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>RCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Compare two single precision floating point numbers.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Compare two double precision floating point numbers.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UICMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Unsigned integer comparison.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UDICMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Unsigned double integer comparison.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Pointer comparison.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Compare two complex numbers.
The value computed is 0 if equal and -1 or 1 if not equal.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Compare two double complex numbers.
The value computed is the same as for the ICMP ILM.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SCMP</strong> lnk lnk    <em>Type</em>: <em>fstr</em></p>
<p>Compare two strings.
The value computed is the same as for the ICMP ILM.  SCMP has no
corresponding vector ILM.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>NSCMP</strong> lnk lnk    <em>Type</em>: <em>fstr</em></p>
<p>Same as SCMP for ncharacter strings.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>EQ</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is equal (lnk locates a compare ILM)</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>NE</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is not equal</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>LT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is less than</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>GE</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is greater than or equal to</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>LE</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is less than or equal to</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>GT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is greater than</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SCAT</strong> lnk lnk    <em>Type</em>: <em>fstr</em></p>
<p>Character string concatenation of 2 character expressions
(none of which are themselves concatenations).</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>QJSR r =e&#39;%v%ftn_str_copy iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>NSCAT</strong> lnk lnk    <em>Type</em>: <em>fstr</em></p>
<p>Concatenate ncharacter strings.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>QJSR r =e&#39;%v%ftn_str_copy iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>LOC</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Returns the address represented by a BASE, ELEMENT, or
a MEMBER ILM, or substring reference.
Used for the ‘&amp;’ operator.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>BASE</strong> sym    <em>Type</em>: <em>ref</em></p>
<p>Represents base address of a variable, array, struct, or union.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>ELEMENT</strong> lnk lnk stc    <em>Type</em>: <em>ref</em></p>
<p>Address of an array element reference:
lnk1 - subscripted lvalue
lnk2 - subscript expression
stc  - data type of each element</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>ELEMENT</strong> n lnk1 stc lnk+    <em>Type</em>: <em>ref</em></p>
<p>Address of an array element reference:
lnk1 - subscripted lvalue
stc  - data type of each element
lnk+ - subscript expressions (&lt;= 7)</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>INLELEM</strong> n lnk1 stc lnk+    <em>Type</em>: <em>ref</em></p>
<p>Address of an array element reference.  Generated by function inlining.
lnk1 - subscripted lvalue
stc  - data type of each element
lnk+ - subscript expressions (&lt;= 7)</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>MEMBER</strong> lnk sym    <em>Type</em>: <em>ref</em></p>
<p>Address of a structure member or field reference.
lnk  - base address of the structure.
sym  - pointer to a struct member ST item.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SHAPE</strong> n lnk+    <em>Type</em>: <em>misc</em></p>
<p>Shape ILM.  Links point to SHD ILMs.  One link for each dimension.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SHD</strong> lnk lnk lnk    <em>Type</em>: <em>misc</em></p>
<p>Shape descriptor for a dimension.
lnk1 - lower bound
lnk2 - upper bound
lnk3 - stride</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UCON</strong> sym    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ICON</strong> sym    <em>Type</em>: <em>cons</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>RCON</strong> sym    <em>Type</em>: <em>cons</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FCON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DCON</strong> sym    <em>Type</em>: <em>cons</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DCON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CCON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FCON rr iv0
FCON ir iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>CDCON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DCON rr iv0
DCON ir iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>ACON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p>Address constant ILM. sym is a symbol table pointer to
an address constant.
The template is: ACON r v1</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>ACON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p>Address constant. ‘sym’ must be a symbol table pointer to
an address constant for a label.
This ILM is generated when an ASSIGN statement is processed.</p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ACON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>LCON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p>Logical constant.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>BR</strong> sym    <em>Type</em>: <em>branch</em></p>
<p>Branch to label indicated by ‘sym’.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>JMP null v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>BRT</strong> lnk sym    <em>Type</em>: <em>branch</em></p>
<p>Branch on logical condition true by comparing for zero/nonzero (PGC).
‘lnk’ may point to a constant ILM, in which case it will always
be an ICON 0 or 1.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICJMPZ null p1 ne v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>BRF</strong> lnk sym    <em>Type</em>: <em>branch</em></p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICJMPZ null p1 eq v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>BRT</strong> lnk sym    <em>Type</em>: <em>branch</em></p>
<p>Branch on logical condition true by testing the low bit (PGFTN).
‘lnk’ may point to a constant ILM.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LCJMPZ null p1 ne v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>BRF</strong> lnk sym    <em>Type</em>: <em>branch</em></p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LCJMPZ null p1 eq v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>SWITCH</strong> lnk stc    <em>Type</em>: <em>branch</em></p>
<p>Switch determinator, where
lnk - switch expression
stc - relative pointer to switch table, consisting of linked list of case value/label pairs.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SWTCHLL</strong> lnk stc    <em>Type</em>: <em>branch</em></p>
<p>Switch determinator, where
lnk - switch expression
stc - relative pointer to switch table, consisting of linked list of case value/label pairs.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>IAIF</strong> lnk sym1 sym2 sym3    <em>Type</em>: <em>branch</em></p>
<p>Arithmetic IF branch on integer expression.
‘sym’s are symbol table pointers to labels.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICJMPZ null p1 le v2
ICJMPZ null p1 eq v3
ICJMPZ null p1 gt v4
</pre></div>
</div>
</li>
<li><p class="first"><strong>RAIF</strong> lnk sym1 sym2 sym3    <em>Type</em>: <em>branch</em></p>
<p>Arithmetic if branch on real expression.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FCJMPZ null p1 le v2
FCJMPZ null p1 eq v3
FCJMPZ null p1 gt v4
</pre></div>
</div>
</li>
<li><p class="first"><strong>DAIF</strong> lnk sym1 sym2 sym3    <em>Type</em>: <em>branch</em></p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DCJMPZ null p1 le v2
DCJMPZ null p1 eq v3
DCJMPZ null p1 gt v4
</pre></div>
</div>
</li>
<li><p class="first"><strong>AGOTO</strong> n lnk sym*    <em>Type</em>: <em>branch</em></p>
<p>Assigned GOTO.
‘lnk’ is to an ILD ILM.
‘sym’s are symbol table pointers
to labels specified on the assigned GOTO statement, if any.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>JMPA null t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CGOTO</strong> lnk stc    <em>Type</em>: <em>branch</em></p>
<p>Computed goto.
lnk - ILM of the computed goto index
stc - relative pointer to goto/switch table, consisting of linked list of index value/label pairs.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CHLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load signed char (byte)</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UCHLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load unsigned char (byte)</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>ILD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load long integer</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UILD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load unsigned long integer</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UDILD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load unsigned double integer</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SILD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load short signed integer</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>USILD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load short unsigned integer</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>RLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load real</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load double</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>QLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load m128</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>M256LD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load m256</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>LLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load logical value.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SLLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load logical value - LOGICAL*2</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PLD</strong> lnk sym    <em>Type</em>: <em>load</em></p>
<p>Load pointer.  For fortran, ‘sym’ field is used for PLD’s
generated by inlining array arguments, and points to actual array
For C &amp; Fortran, the ‘sym’ field locates the based object
for which the PLD is generated; the ‘sym’ field is 0 for
loads of normal C pointers.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>FLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load field.  Always points to a MEMBER ilm.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SFLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load signed field.  Always points to a MEMBER ilm.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SUBS</strong> lnk1 lnk2 lnk3    <em>Type</em>: <em>fstr</em></p>
<p>Character substring.  Lnk1 must point to a BASE, MEMBER, or ELEMENT ILM.
Lnk2 and lnk3 must point to the integer expressions for the lower
and upper bounds respectively.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>NSUBS</strong> lnk1 lnk2 lnk3    <em>Type</em>: <em>fstr</em></p>
<p>Substring of ncharacter string.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>NCSELD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Non-cse load.  lnk points to a load ilm.  Used for
volatile types.  Expands to ILI that forces scheduler to do the load rather
then optimizing it away.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VLD</strong> stc    <em>Type</em>: <em>load</em></p>
<p>Fake vector load ILM for vector expander.  stc is really
index into vector table.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CHST</strong> lnk1 lnk2    <em>Type</em>: <em>store</em></p>
<p>Store signed char, lnk1 = lnk2 (??)</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>UCHST</strong> lnk1 lnk2    <em>Type</em>: <em>store</em></p>
<p>Store unsigned char, lnk1 = lnk2 (??)</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>IST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store into integer variable.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>UIST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store into unsigned long integer</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SIST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store short signed integer</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>USIST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store short unsigned integer</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>RST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store float</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>DST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store double</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>QST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store m128</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>M256ST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store m256</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CSTR</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store the real part of a single complex</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CSTI</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store the imaginary part of a single complex</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CDST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p><em>Attributes</em>: spec trm dcmplx</p>
</li>
<li><p class="first"><strong>CDSTR</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store the real part of a double complex</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CDSTI</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store the imaginary part of a double complex</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>LST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SLST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>AST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store address scalar.
This ILM is used for an ASSIGN statement.
‘lnk’ points to an ACON ILM.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SST</strong> lnk1 lnk2    <em>Type</em>: <em>fstr</em></p>
<p>Store character expression into character variable, array element,
or substring.
Lnk1 and lnk2 point to character expressions.
Lnk1 is the destination - cannot be a concatenation.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>QJSR null =e&#39;%v%ftn_str_copy iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>NSST</strong> lnk1 lnk2    <em>Type</em>: <em>fstr</em></p>
<p>Store ncharacter expression.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>QJSR null =e&#39;%v%ftn_str_copy iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>PST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store pointer</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PSTRG1</strong> lnk stc    <em>Type</em>: <em>store</em></p>
<p>Store pointer to argument register number stc : used in g++ style thunks
to store the adjusted value bask to rdi/rsi etc before jumping through to the function.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>FST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store into field.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SMOVE</strong> lnk1 lnk2 stc    <em>Type</em>: <em>store</em></p>
<p>Store from one structure into another (of same type).
lnk1 - base address of receiving structure (to).
lnk2 - base address of stored structure (from).
stc is a data type pointer which describes the structures.
The expansion of this ILM can generate ILI for a sequence of
loads and stores or a call (JSR) to one of:
“c_bcopy”  copy bytes
“c_hcopy”  copy half-words
“c_wcopy”  copy words
“c_dcopy”  copy double words</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SZERO</strong> lnk1 lnk2 stc    <em>Type</em>: <em>store</em></p>
<p>Zero memory locations.
lnk1 - base address to zero
lnk2 - number of units to zero
stc  - data type of units to zero: char, short, int, dble
The expansion of this ILM can generate ILI for a sequence of
stores or a JSR to one of
“c_bzero”  zero bytes
“c_hzero”  zero halfwords
“c_wzero”  zero words
“c_dzero”  zero double words</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PSEUDOST</strong> stc lnk    <em>Type</em>: <em>store</em></p>
<p>Pseudo store.
This ILM is used to mark an expression whose value may be required
later in the ILM block (e.g., for i++, the orginal value of i may be
needed as the result of this expression.  The expander will expand
this ILM to one of the ILIs (FREEIR, FREEAR, or FREEIR) depending on
the type of the register defined by the ILI which lnk locates.
stc is just a dummy field (0) so that the ILM requires a total of
3 words.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SPSEUDOST</strong> stc lnk    <em>Type</em>: <em>fstr</em></p>
<p>Character pseudo store.  lnk points to a character expression.
stc is the length of the destination.
This ILM is used to mark a character expression whose value is
restricted by length;  this occurs when a character expression
is used as an argument to a statement function and when the result
of a character statement function is referenced.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>NSPSEUDOST</strong> stc lnk    <em>Type</em>: <em>fstr</em></p>
<p>Same as SPSEUDOST but for ncharacter type.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>NCSEST</strong> lnk    <em>Type</em>: <em>store</em></p>
<p>Non-cse store.  lnk points to a store ilm.  Used for
volatile types.  Expands to ILI that forces scheduler to do the store rather
then optimizing it away.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>FAPPLY</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function, where stc is the dtype for the function signature.
‘n’ is the number of actual arguments.
‘lnk1’ is the lvalue of the procedure
The other links point to the arguments in the same order they appeared
in the actual argument list.
If the type of the argument is struct,
the lnk will point to
an ILM for the address of the struct.
For other types of arguments the lnk will just point to
the ILM’s for the expression.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VAPPLY</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Like FAPPLY, but has trm attribute.
The result is discarded if there is one, i.e. if the function signature
has a return type other than DT_VOID.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>FINVOKE</strong> n sym stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Like FAPPLY, but has label argument indicating where control-flow
jumps if the function throws an exception.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VINVOKE</strong> n sym stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Like VAPPLY, but has label argument similar to FINVOKE.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>VFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call void function, where
‘n’ is the number of actual arguments.
‘lnk1’ is the lvalue of the procedure
The links point to the arguments in the same order they appeared
in the actual argument list.
If the type of the argument is struct,
the lnk will point to
an ILM for the address of the struct.
For other types of arguments the lnk will just point to
the ILM’s for the expression.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>IFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call integer function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>IFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call integer function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>IFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call integer function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PIFUNCA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call integer function through procedure pointer</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>IVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call integer function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UIFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call unsigned function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>RFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call float function.  This ILM is only
when the compiler is asked to not convert ALL instances
of float to double.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>RFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call real function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>RFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call real function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PRFUNCA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call real function through procedure pointer</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>RVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call real function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call double function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call double function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call double function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PDFUNCA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call double function through procedure pointer</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call double function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>QFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m128 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>QFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m128 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>QFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m128 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>M256FUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m256 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>M256FUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m256 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>M256FUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m256 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>M256VFUNC</strong> n sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m256 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>M256VFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m256 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>QVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call m128 function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CALL</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call external subprogram.
‘n’ is the number of actual arguments.
‘sym’ is symbol table pointer to the external subprogram.
The links point to the arguments in the same order they appeared
in the CALL statement.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CALLA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call external subprogram.
‘n’ is the number of actual arguments.
‘lnk1’ is address of the subprogram
The links point to the arguments in the same order they appeared
in the CALL statement.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PCALLA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call subprogram through procedure pointer
‘n’ is the number of actual arguments.
‘sym’ is the pointer’s descriptor
‘lnk1’ is address of the subprogram
The links point to the arguments in the same order they appeared
in the CALL statement.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>VCALLA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call external subprogram.
‘n’ is the number of actual arguments.
‘sym1’ is symbol table pointer to the external subprogram.
‘lnk’ ilm of invoking object
‘sym2’ address of invoking object desc
The links point to the arguments in the same order they appeared
in the CALL statement.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PCFUNCA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call complex function through procedure pointer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CDFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>PCDFUNCA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call double complex function through procedure pointer.</p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>CDVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>LFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>LFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PLFUNCA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call logical function through procedure pointer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>LVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns a pointer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns a pointer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PPFUNCA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns a pointer through a procedure pointer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns a pointer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns a pointer.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns a structure/union.
The second link is the address (a LOC ilm) of the
temporary which is used to return the result of the function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>SFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function that has the bind(C) attribute and returns a structure/union.
The first link is the address (a LOC ilm) of the
temporary which is used to return the result of the function.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CHFUNC</strong> n sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns Fortran character.
The first link is the address (a BASE ilm) of the
temporary which is used to return the result of the function.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CHFUNCA</strong> n stc lnk lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns Fortran character.
The first link is the address (a BASE ilm) of the
temporary which is used to return the result of the function.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PCHFUNCA</strong> n stc sym lnk lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns Fortran character through a procedure pointer.
The first link is the address (a BASE ilm) of the
temporary which is used to return the result of the function.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CHVFUNCA</strong> n stc sym lnk sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns Fortran character.
The first link is the address (a BASE ilm) of the
temporary which is used to return the result of the function.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>NCHFUNC</strong> n sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns ncharacter.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>NCHFUNCA</strong> n stc lnk lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns ncharacter.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PNCHFUNCA</strong> n stc lnk lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns ncharacter through a procedure pointer.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>NCHVFUNCA</strong> n stc sym lnk sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns ncharacter.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>ARG</strong> lnk lnk stc stc    <em>Type</em>: <em>misc</em></p>
<p>Special purpose ilm for arguments which require special processing.
For example, an argument which is a structure or union would
use this ilm (the function ilm locates the ARG ilm).</p>
<div class="line-block">
<div class="line">lnk1 - BASE ilm of temporary (if needed)</div>
<div class="line">lnk2 - ilm of argument</div>
<div class="line">stc  - dtype of dummy argument</div>
<div class="line">stc  - dtype of actual argument</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>FARG</strong> lnk stc    <em>Type</em>: <em>misc</em></p>
<p>Special purpose ilm for argument passing, to keep the
data type of the actual argument around</p>
<div class="line-block">
<div class="line">lnk - ilm of argument</div>
<div class="line">stc - dtype of actual argument</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PARG</strong> lnk lnk    <em>Type</em>: <em>misc</em></p>
<p>Special purpose ilm for passing arguments with the F90 pointer attribute.</p>
<div class="line-block">
<div class="line">lnk1 - ilm representing the address of the argument’s pointer</div>
<div class="line">lnk2 - BASE ilm of the object with the pointer attribute.</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>FARGF</strong> lnk stc stc    <em>Type</em>: <em>misc</em></p>
<p>Same as FARG with the addition of a flag denoting certain context.</p>
<div class="line-block">
<div class="line">lnk  - ilm of argument</div>
<div class="line">stc1 - dtype of actual argument</div>
<div class="line">stc2 - a bit vector:</div>
<div class="line">0x0 - no special case (therefore, same as FARG)</div>
<div class="line">0x1 - corresponding formal is CLASS(#)</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>FATTR</strong> lnk stc stc    <em>Type</em>: <em>misc</em></p>
<p>ILM which passes up the address of the called procedure and specifies
certain attributes, such as stdcall, about the call.</p>
<div class="line-block">
<div class="line">lnk1 - address of the procedure</div>
<div class="line">stc1 - attributes (bit vector):</div>
<div class="line">0x0001 - stdcall</div>
<div class="line">stc2 - dtype record (TY_PFUNC/TY_FUNC) of the procedure</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>ENTRY</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>This ILM is put out as the entry point for each
entry point defined in this file is processed (except for the
main entry in Fortran).
‘sym’ is a symbol table
pointer to the function name.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>LABEL</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>Marks the position of a user defined or compiler created
label within the current ILM block.  ‘sym’ is a symbol table
pointer to a label.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>ESTMT</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>Expression statement – generated when the value of an
expression (other than an assignment or VFUNC) is not
referenced (i.e., the value may be discarded).
However, the functions appearing in the expression must
still be evaluated (because of side effects).</p>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">RET</span></code></dt>
<dd><p class="first">Written for a RETURN statement which does not return a value.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>RETV</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>Return value from function.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>ARET</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>Alternate return.  ‘lnk’ points to expression defining the
alternate return number.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>RETAUTO</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>Return from function after freeing automatic objects.
‘sym’ is the symbol of the block containing the return.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>RETVAUTO</strong> lnk sym    <em>Type</em>: <em>misc</em></p>
<p>Return value from function after freeing automatic objects.
‘sym’ is the symbol of the block containing the return.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">NOP</span></code></p>
<blockquote>
<div><em>Attributes</em>: spec trm</div></blockquote>
<ol class="arabic">
<li><p class="first"><strong>ASM</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>asm ( &lt;string&gt; );  ‘sym’ is the symbol table pointer of the
ST_STRING representing &lt;string&gt;.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>GASM</strong> sym lnk lnk lnk    <em>Type</em>: <em>misc</em></p>
<p>asm ( &lt;string&gt; : &lt;outputs&gt; : &lt;inputs&gt; : &lt;clobbers&gt; );
‘sym’ is the symbol table pointer of the
ST_STRING representing &lt;string&gt;.
‘lnk1’ is GASMLNK of list of outputs
‘lnk2’ is GASMLNK of list of inputs
‘lnk3’ is GASMLNK of list of clobber descriptors</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>GASMLNK</strong> sym1 lnk lnk sym2 stc3    <em>Type</em>: <em>misc</em></p>
<p>‘sym1’ is the symbol table pointer of the ST_STRING representing the
descriptor (‘=r’ for outputs, ‘r’ for inputs, ‘r2’ for clobbers)
‘lnk1’ is the link to the output or input expression
‘lnk2’ is the link to the next GASMLNK
‘sym2’ is the symbol table pointer of the identifier representing the constraint
name for an input or output item. It is 0 if no constraint name applies to this
item.
‘stc3’ is the dtype of the item.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">END</span></code></dt>
<dd><p class="first">End of function – written when the final ‘}’ is processed.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">END</span></code></dt>
<dd><p class="first">End of subroutine or main program - last ILM in ilm file seen by Expander.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>ENDF</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>End of function subprogram - lnk points to load of the
compiler created variable for the function return value.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>DOBEG</strong> lnk sym1 sym2    <em>Type</em>: <em>misc</em></p>
<p>DO-loop begin.  May be used, as an optimization, for certain
for loops.
ILM’s to store the initial DO value into the DO index
variable must precede the DOBEG ILM,
and a LABEL ILM for the loop-top label must follow it.</p>
<div class="line-block">
<div class="line">lnk - link to expression computing the loop count:</div>
<div class="line"><br /></div>
<div class="line">INT((e2 - e1 + e3) / e3)</div>
<div class="line"><br /></div>
<div class="line">sym1 - symbol table pointer to zero trip label.</div>
<div class="line">sym2 - symbol table pointer to DO count temporary.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>DOBEGNZ</strong> lnk sym1 sym2 lnk    <em>Type</em>: <em>misc</em></p>
<p>DO-loop begin.  Used as an optimization, for certain
for array assignment compiler generated forall loops.
ILM’s to store the initial DO value into the DO index
variable must precede the DOBEGNZ ILM,
and a LABEL ILM for the loop-top label must follow it.</p>
<div class="line-block">
<div class="line">lnk - link to expression computing the loop count:</div>
<div class="line"><br /></div>
<div class="line">INT((e2 - e1 + e3) / e3)</div>
<div class="line"><br /></div>
<div class="line">sym1 - symbol table pointer to zero trip label.</div>
<div class="line">sym2 - symbol table pointer to DO count temporary.</div>
<div class="line">lnk -  link to expression to check if array is zero-size</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>DOENDNZ</strong> sym1 sym2    <em>Type</em>: <em>misc</em></p>
<p>DO-loop end.
Always matches a DOBEGNZ ILM.</p>
<div class="line-block">
<div class="line">sym1 - symbol table pointer to loop top label.</div>
<div class="line">sym2 - symbol table pointer to DO count variable.</div>
<div class="line">This item generates the following for the loop end condtion:</div>
<div class="line">v2 &lt;– v2 - 1</div>
<div class="line">if ( v2 &gt; 0 ) goto v1</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>DOEND</strong> sym1 sym2    <em>Type</em>: <em>misc</em></p>
<p>DO-loop end.
Always matches a DOBEG ILM.</p>
<div class="line-block">
<div class="line">sym1 - symbol table pointer to loop top label.</div>
<div class="line">sym2 - symbol table pointer to DO count variable.</div>
<div class="line">This item generates the following for the loop end condtion:</div>
<div class="line">v2 &lt;– v2 - 1</div>
<div class="line">if ( v2 &gt; 0 ) goto v1</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>BYVAL</strong> lnk stc    <em>Type</em>: <em>misc</em></p>
<p>General ILM to support passing arguments by value.</p>
<div class="line-block">
<div class="line">lnk  - link to argument being passed by value</div>
<div class="line">stc  - its data type</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DPVAL</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>This ILM is generated when the %VAL operator is used.
‘lnk’ is a pointer to a 32-bit valued expression.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DPREF</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>This ILM is generated when the %REF operator is used.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DPSCON</strong> stc    <em>Type</em>: <em>misc</em></p>
<p>Define parameter which is a short integer constant passed
by value.  This ILM is included for the convenience of semant
when generating code for io statements.</p>
<p><em>Attributes</em>: spec</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DPNULL</span></code></dt>
<dd><p class="first">Define a parameter which is a ‘null pointer’, i.e. the value 0 is
to be passed, and an additional argument for the character length
(which equals 0) is to be added to the end of the argument list.</p>
<p class="last"><em>Attributes</em>: spec</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>CMSIZE</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>Get the size of the common block (sym1).</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>MAD24</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMUL t1 p1 p2
IADD r t1 p3
</pre></div>
</div>
</li>
<li><p class="first"><strong>UMAD24</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMUL t1 p1 p2
UIADD r t1 p3
</pre></div>
</div>
</li>
<li><p class="first"><strong>MUL24</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UMUL24</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>HADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>hadd(x,y), where x and y are char or short, and
computed as (x+y) &gt;&gt; 1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
IADD t2 p1 p2
RSHIFT r t2 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>hadd(x,y), where x and y are unsigned char or unsigned short, and
computed as (x+y) &gt;&gt; 1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
UIADD t2 p1 p2
URSHIFT r t2 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>hadd(x,y), where x and y are int, and
computed as (x&gt;&gt;1) + (y&gt;&gt;1) + (x&amp;y)&amp;1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
ARSHIFT t2 p1 t1
ARSHIFT t3 p2 t1
AND t4 p1 p2
AND t4 t4 t1
IADD t5 t2 t3
IADD r t5 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>hadd(x,y), where x and y are unsigned, and
computed as (x&gt;&gt;1) + (y&gt;&gt;1) + (x&amp;y)&amp;1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
URSHIFT t2 p1 t1
URSHIFT t3 p2 t1
AND t4 p1 p2
AND t4 t4 t1
UIADD t5 t2 t3
UIADD r t5 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>KHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>hadd(x,y), where x and y are long, and
computed as (x&gt;&gt;1) + (y&gt;&gt;1) + (x&amp;y)&amp;1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
KARSHIFT t2 p1 t1
KARSHIFT t3 p2 t1
IKMV t1 t1
KAND t4 p1 p2
KAND t4 t4 t1
KADD t5 t2 t3
KADD r t5 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>hadd(x,y), where x and y are unsigned long, and
computed as (x&gt;&gt;1) + (y&gt;&gt;1) + (x&amp;y)&amp;1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
KURSHIFT t2 p1 t1
KURSHIFT t3 p2 t1
IKMV t1 t1
KAND t4 p1 p2
KAND t4 t4 t1
UKADD t5 t2 t3
UKADD r t5 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>RHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>rhadd(x,y), where x and y are char or short, and
computed as (x+y+1) &gt;&gt; 1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
IADD t2 p1 p2
IADD t2 t2 t1
RSHIFT r t2 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>URHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>rhadd(x,y), where x and y are unsigned char or unsigned short, and
computed as (x+y+1) &gt;&gt; 1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
UIADD t2 p1 p2
UIADD t2 t2 t1
URSHIFT r t2 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IRHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>rhadd(x,y), where x and y are int, and
computed as (x&gt;&gt;1) + (y&gt;&gt;1) + (x|y)&amp;1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
ARSHIFT t2 p1 t1
ARSHIFT t3 p2 t1
OR t4 p1 p2
AND t4 t4 t1
IADD t5 t2 t3
IADD r t5 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIRHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>rhadd(x,y), where x and y are unsigned, and
computed as (x&gt;&gt;1) + (y&gt;&gt;1) + (x|y)&amp;1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
URSHIFT t2 p1 t1
URSHIFT t3 p2 t1
OR t4 p1 p2
AND t4 t4 t1
UIADD t5 t2 t3
UIADD r t5 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>KRHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>rhadd(x,y), where x and y are long, and
computed as (x&gt;&gt;1) + (y&gt;&gt;1) + (x|y)&amp;1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
KARSHIFT t2 p1 t1
KARSHIFT t3 p2 t1
IKMV t1 t1
KOR t4 p1 p2
KAND t4 t4 t1
KADD t5 t2 t3
KADD r t5 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKRHADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>rhadd(x,y), where x and y are unsigned long, and
computed as (x&gt;&gt;1) + (y&gt;&gt;1) + (x|y)&amp;1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICON t1 =i&#39;1
KURSHIFT t2 p1 t1
KURSHIFT t3 p2 t1
IKMV t1 t1
KOR t4 p1 p2
KAND t4 t4 t1
UKADD t5 t2 t3
UKADD r t5 t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>VECTFUNC</strong> n lnk stc lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call function which returns a vector
n    - the number of arguments.
lnk1 - address of the function being called
stc  - the function’s vector data type.
lnk2 - address (a LOC ilm) of the temporary which is used to return the result of the function.
lnk3 … - user arguments</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VSCALAR</strong> lnk stc2 stc3    <em>Type</em>: <em>ref</em></p>
<p>Represents the address of a scalar component of a vector
lnk  - base address of vector
stc2 - which component [0, n-1], where n is the number of components in the vector
stc3 - element dtype</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VSEL</strong> lnk sym stc    <em>Type</em>: <em>ref</em></p>
<p>Represents the address of selecting multiple components from a vector
lnk  - base address of vector
sym  - component mask (int vector constant)
stc  - result vector data type of the components</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VCON</strong> sym    <em>Type</em>: <em>cons</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VCON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>VLD</strong> lnk stc    <em>Type</em>: <em>load</em></p>
<p>Vector load.</p>
<div class="line-block">
<div class="line">lnk  - its address</div>
<div class="line">stc  - its vector data type</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VLDU</strong> lnk stc    <em>Type</em>: <em>load</em></p>
<p>Vector load (unaligned)</p>
<div class="line-block">
<div class="line">lnk  - its address</div>
<div class="line">stc  - its vector data type</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VNEG</strong> lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VNEG r p1 v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>VADD</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VADD r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VSUB</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VSUB r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VMUL</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VMUL r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VDIV</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VDIV r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VDIVZ</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Vector divide where divide by zero does not fault.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VDIVZ r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VMOD</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VMOD r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VMODZ</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Vector remainder where divide by zero does not fault.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VMODZ r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VCVTV</strong> lnk stc stc    <em>Type</em>: <em>arth</em></p>
<p>Vector convert from vector</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VCVTV r p1 v2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VCVTS</strong> lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Vector convert from scalar</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VCVTS r p1 v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>VNOT</strong> lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VNOT r p1 v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>VAND</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VAND r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VOR</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VOR r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VXOR</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VXOR r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VLSHIFTV</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Vector &gt;&gt; by scalar</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VLSHIFTV r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VRSHIFTV</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Vector &gt;&gt; by vector</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VRSHIFTV r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VLSHIFTS</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Vector &lt;&lt; by scalar</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VLSHIFTS r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VRSHIFTS</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Vector &gt;&gt; by scalar</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VRSHIFTS r p1 p2 v3
</pre></div>
</div>
</li>
<li><p class="first"><strong>VCMP</strong> lnk lnk stc    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>VST</strong> lnk lnk stc    <em>Type</em>: <em>store</em></p>
<p>Vector store.
lnk1 - destination
lnk2 - source
stc  - its vector data type</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>VSTU</strong> lnk lnk stc    <em>Type</em>: <em>store</em></p>
<p>Vector store (unaligned)
lnk1 - destination
lnk2 - source
stc  - its vector data type</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>ADJARR</strong> sym sym sym    <em>Type</em>: <em>misc</em></p>
<p>This ILM is emitted after every “entry” if the entry has
adjustable array arguments. This ILM is used control any additional
setup necessary for the array bounds information of the entry’s
adjustable arrays. This ILM will do nothing if the this is for
the primary entry and code has already been emitted for its adjustable
arrays.
‘sym1’ entry symbol
‘sym2’ label of the additional code
‘sym3’ label to which the code branches (returns)</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>VFENTER</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>Enter a “function” which computes the value of an expression in a
variable format item (&lt;expr&gt;).  This ILM is “closed” by a VFRET.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>VFRET</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>Return the value of an expression in a variable format item (&lt;expr&gt;).</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PRAGMA</strong> stc1 stc2 stc3    <em>Type</em>: <em>misc</em></p>
<p>pragma/directive ILM</p>
</li>
<li><p class="first"><strong>FLOATK</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert long long to real number (REAL and FLOAT intrinsics).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FLOATK r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>FLOATUK</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned long long to real</p>
<p><em>Attributes</em>: spec i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FLOATK r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DFLOATK</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert long long to double precision (DFLOAT intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DFLOATK r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DFLOATUK</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned long long integer to double precision (DFLOAT intrinsic).</p>
<p><em>Attributes</em>: spec i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DFLOATUK r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KNEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer negation.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KNEG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKNEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer negation.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKNEG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KADD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKADD kr p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KSUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KSUB r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKSUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKSUB kr p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KMUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKMUL kr p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KDIV r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKDIV kr p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>IDIVZ</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Signed integer divide where divide by zero does not fault.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IDIVZ r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIDIVZ</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Unsigned integer divide where divide by zero does not fault.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIDIVZ r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KDIVZ</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Signed integer64 divide where divide by zero does not fault.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KDIVZ r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKDIVZ</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Unsigned integer64 divide where divide by zero does not fault.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKDIVZ kr p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KTOI</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p>Exponentiation - integer to an integer power.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KPOWI r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KTOK</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p>Exponentiation - integer to an integer power.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KPOWK r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>RTOK</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FPOWK r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DTOK</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DPOWK r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CTOK</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CDTOK</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p><em>Attributes</em>: spec dcmplx</p>
</li>
<li><p class="first"><strong>KCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>UKCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>KABS</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KABS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KFIX</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert real number to integer*8 (INT and IFIX intrinsics).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FIXK r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKFIX</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert real number to integer*8 (INT and IFIX intrinsics).</p>
<p><em>Attributes</em>: spec i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FIXUK r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KDFIX</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert double precision floating point number to integer*8.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DFIXK r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKDFIX</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert double precision floating point number to integer*8.</p>
<p><em>Attributes</em>: spec i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DFIXUK r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ITOI8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert int to long (long long)
Convert integer to integer*8</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IKMV kr p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ITOUI8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert long to unsigned long (unsigned long long)</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IKMV kr p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UITOI8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned int to long (long long)</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV kr p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UITOUI8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert unsigned int to unsigned long (unsigned long long)</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV kr p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>I8TOI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert long long to long
Convert integer*8 to integer*4</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>I8TOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert long long to long</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UI8TOI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert long long to long</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UI8TOUI</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert long long to long</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KNINT</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>NINT intrinsic (converts real to integer*8).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DASP t1 p1 sp(0) t1
QJSR t2 =e&#39;%l%__mth_i_knint t1
DFRKR r t2 krret
</pre></div>
</div>
</li>
<li><p class="first"><strong>KDNINT</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>KIDNINT intrinsic (converts double to integer).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DADP t1 p1 dp(0) t1
QJSR t2 =e&#39;%l%__mth_i_kidnnt t1
DFRKR r t2 krret
</pre></div>
</div>
</li>
<li><p class="first"><strong>KMAX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KMAX r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKMAX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKMAX r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KMIN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KMIN r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKMIN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKMIN r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KDIM</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
DAKR t1 p2 dr(1) t1
DAKR t2 p1 dr(0) t1
QJSR t2 =e&#39;ftn_i_kidim t2
DFRKR r t2 krret
</pre></div>
</div>
</li>
<li><p class="first"><strong>KMOD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer remainder (MOD intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KMOD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKMOD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer remainder (MOD intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KUMOD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>MODZ</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer remainder where divide by zero does not fault.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MODZ r p1 p2
</pre></div>
</div>
<p>Integer remainder (MODZ intrinsic).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MODZ r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UIMODZ</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Unsigned integer mod where divide by zero does not fault.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIMODZ r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KMODZ</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Integer64 remainder where divide by zero does not fault.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KMODZ r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKMODZ</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Unsigned integer64 remainder where divide by zero does not fault.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KUMODZ r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KSIGN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCMPZ t1 p2 lt
KABS t2 p1
KNEG t3 t2
KSELECT r t1 t2 t3
</pre></div>
</div>
</li>
<li><p class="first"><strong>KAND</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise logical and of two 64 bit values (AND intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KAND r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KOR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise logical or of two 64 bit values (OR intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KOR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KXOR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise exclusive or of two 64 bit values (^ operator / EOR intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KXOR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KNOT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise negation of 64 bit signed value (NOT intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KNOT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKNOT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Bitwise negation of 64 bit signed value (NOT intrinsic).</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UKNOT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KBITS</strong> lnk lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>IBITS(p1, p2, p3) - extract p3 bits beginning at p2 from p1.</p>
<div class="line-block">
<div class="line">r = p3 != 0 ? (p1 &gt;&gt; p2) &amp; (-1 &gt;&gt; (64 - p3)) : 0</div>
</div>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV t1 p2
KARSHIFT t1 p1 t1
KCON t2 =ll&#39;-1
KIMV t3 p3
ICON t4 =i&#39;64
ISUB t4 t4 t3
KURSHIFT t5 t2 t4
KAND t6 t1 t5
KCMPZ t7 p3 eq
KSELECT r t7 t6 p3
</pre></div>
</div>
</li>
<li><p class="first"><strong>KBSET</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>IBSET(p1, p2) - set bit p2 of p1 to 1.</p>
<div class="line-block">
<div class="line">r = p1 | (1 &lt;&lt; p2)</div>
</div>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCON t1 =ll&#39;1
KIMV t2 p2
KLSHIFT t2 t1 t2
KOR r p1 t2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KBTEST</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>BTEST(p1, p2) - .TRUE. if bit p2 of p1 is 1.</p>
<div class="line-block">
<div class="line">r = (p1 &amp; (1 &lt;&lt; p2)) != 0</div>
</div>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCON t1 =ll&#39;1
KIMV t2 p2
KLSHIFT t2 t1 t2
KAND t3 p1 t2
KCMPZ t4 t3 ne
IKMV r t4
</pre></div>
</div>
</li>
<li><p class="first"><strong>KBCLR</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>IBLCR(p1, p2) - clear bit p2 of p1.</p>
<div class="line-block">
<div class="line">r = p1 &amp; ~(1 &lt;&lt; p2)</div>
</div>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCON t1 =ll&#39;1
KIMV t2 p2
KLSHIFT t2 t1 t2
KNOT t3 t2
KAND r p1 t3
</pre></div>
</div>
</li>
<li><p class="first"><strong>KSHFTC</strong> lnk lnk lnk    <em>Type</em>: <em>intr</em></p>
<p>ISHFTC(p1, p2, p3) - circularly shift the rightmost p3 bits of p1
by p2.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
KIMV t2 p3
DAIR t1 t2 dr(2) t1
KIMV t2 p2
DAIR t2 t2 dr(1) t1
DAKR t3 p1 dr(0) t2
QJSR t1 =e&#39;%l%ftn_i_kishftc t3
DFRKR r t1 krret
</pre></div>
</div>
</li>
<li><p class="first"><strong>KULSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Left shift operator (&lt;&lt;) - first operand is 64 bit unsigned integer
value and second is a positive 64-bit integer.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV t1 p2
KLSHIFT r p1 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KULSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Left shift operator (&lt;&lt;) - first operand is 64 bit unsigned integer
value and second is a 32-bit positive integer.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KLSHIFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KURSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Right shift operator (&gt;&gt;).  First operand is 64 bit unsigned integer
value and second is assumed to be a positive 64-bit integer.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV t1 p2
KURSHIFT r p1 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KURSHIFT</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Right shift operator (&gt;&gt;).  First operand is 64 bit unsigned integer
value and second is assumed to be a positive 32-bit integer.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KURSHIFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>KAIF</strong> lnk sym1 sym2 sym3    <em>Type</em>: <em>branch</em></p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICJMPZ null p1 le v2
ICJMPZ null p1 eq v3
ICJMPZ null p1 gt v4
</pre></div>
</div>
</li>
<li><p class="first"><strong>KLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>KLLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load logical value.</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>KST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>KLST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>KFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec trm i8</p>
</li>
<li><p class="first"><strong>KFUNCA</strong> n stc lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec trm i8</p>
</li>
<li><p class="first"><strong>PKFUNCA</strong> n stc sym lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call a function which returns an integer*8 through a procedure pointer.</p>
<p><em>Attributes</em>: spec trm i8</p>
</li>
<li><p class="first"><strong>KVFUNCA</strong> n stc sym lnk sym lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec trm i8</p>
</li>
<li><p class="first"><strong>KFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>KCON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>KISHFT</strong> lnk lnk    <em>Type</em>: <em>intr</em></p>
<p>ISHFT intrinsic - first operand is 64 bit value and second is positive or
negative integer shift count. If the shift count &lt;= -64 or &gt;=64, the
result is 0.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KISHFT r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>DPREF8</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>This ILM is generated when integer*8/logical*8 arguments
are passed in certains contexts and where the address needs
to be adjusted by expand.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>LNOT8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical negation.  The link must be to an expression of type
LOGICAL; depends on internal representation of logical values (VAX or
UNIX)</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>LNOP8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical noop.  Used by semant when space must be reserved
for a potential LNOT ILM.  ‘lnk’ points to a logical
expression.</p>
<p><em>Attributes</em>: i8 spec</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVIR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>LAND8</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .AND. operation.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KAND r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>LOR8</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .OR. operation.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KOR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>LEQV8</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .EQV. operation.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCMP t1 p1 p2 eq
IKMV r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>LNEQV8</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .NEQV. operation.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KXOR r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>EQ8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is equal (lnk locates a compare FLM)</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>NE8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is not equal</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>LT8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is less than</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>GE8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is greater than or equal to</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>LE8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is less than or equal to</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>GT8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Generate true if compare is greater than</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>K2D</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a 64-bit integer to a 64-bit unsigned integer (dword).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVKR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>K2R</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a 64-bit integer to a single precision real.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KR2SP r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>K2I</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast an integer to a 64-bit integer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KIMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>D2K</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a 64-bit unsigned integer (dword) to a 64-bit integer.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MVKR r p1 iv-1
</pre></div>
</div>
</li>
<li><p class="first"><strong>R2K</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast a single precision real to a 64-bit integer.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SP2IR r rp1
</pre></div>
</div>
</li>
<li><p class="first"><strong>I2K</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast an integer to a 64-bit integer.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KEQV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: i8
Bitwise complement of the exclusive or of two 32 bit values</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KXOR t1 p1 p2
KNOT r t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>UKLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load unsigned double integer</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>UKST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p><em>Attributes</em>: spec i8 trm</p>
</li>
<li><p class="first"><strong>KAST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store address scalar.
This ILM is used for an ASSIGN statement where varref is integer*8
‘lnk’ points to an ACON ILM.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>KLEN</strong> lnk    <em>Type</em>: <em>fstr</em></p>
<p>Length of a character expression, returned as integer*8.</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>KINDEX</strong> lnk lnk    <em>Type</em>: <em>fstr</em></p>
<p>KINDEX intrinsic (inputs are two character strings and result is an integer*8).</p>
<p><em>Attributes</em>: spec i8</p>
</li>
<li><p class="first"><strong>UI2K</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Cast an unsigned integer to a 64-bit integer.</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UIKMV r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>BLEADZ</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>8-bit integer LEADZ intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ILEADZI r p1 iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>SLEADZ</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>16-bit integer LEADZ intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ILEADZI r p1 iv1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ILEADZ</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>32-bit integer LEADZ intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ILEADZ r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KLEADZ</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>64-bit integer LEADZ intrinsic</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KLEADZ r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>BTRAILZ</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>8-bit integer TRAILZ intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ITRAILZI r p1 iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>STRAILZ</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>16-bit integer TRAILZ intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ITRAILZI r p1 iv1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ITRAILZ</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>32-bit integer TRAILZ intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ITRAILZ r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KTRAILZ</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>64-bit integer TRAILZ intrinsic</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KTRAILZ r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>BPOPCNT</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>8-bit integer POPCNT intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IPOPCNTI r p1 iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>SPOPCNT</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>16-bit integer POPCNT intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IPOPCNTI r p1 iv1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IPOPCNT</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>32-bit integer POPCNT intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IPOPCNT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KPOPCNT</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>64-bit integer POPCNT intrinsic</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KPOPCNT r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>BPOPPAR</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>8-bit integer POPPAR intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IPOPPARI r p1 iv0
</pre></div>
</div>
</li>
<li><p class="first"><strong>SPOPPAR</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>16-bit integer POPPAR intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IPOPPARI r p1 iv1
</pre></div>
</div>
</li>
<li><p class="first"><strong>IPOPPAR</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>32-bit integer POPPAR intrinsic</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IPOPPAR r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>KPOPPAR</strong> lnk    <em>Type</em>: <em>intr</em></p>
<p>64-bit integer POPPAR intrinsic</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KPOPPAR r p1
</pre></div>
</div>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ENLAB</span></code></dt>
<dd><p class="first">Marks the position of the first executable statement within
a function: Compiler generated</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>BMPSCOPE</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>Begin scope parallel/clause region.</p>
<div class="line-block">
<div class="line">sym - symbol table entry to scope ST_BLOCK for this region</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">EMPSCOPE</span></code></dt>
<dd><p class="first">End scope for parallel/clause region.
Always matches a BMPSCOPE ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>BPAR</strong> lnk    <em>Type</em>: <em>SMP</em></p>
<p>Begin parallel region.</p>
<div class="line-block">
<div class="line">lnk - link to logical expression (inhibit parallel flag):</div>
<div class="line">0       – parallel execution</div>
<div class="line">nonzero – serial execution</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>BPARD</strong> lnk    <em>Type</em>: <em>SMP</em></p>
<p>Begin nested parallel region.</p>
<div class="line-block">
<div class="line">lnk - link to logical expression (inhibit parallel flag):</div>
<div class="line">0       – parallel execution</div>
<div class="line">nonzero – serial execution</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">EPARD</span></code></dt>
<dd><p class="first">End nested parallel region.
Always matches a BPARD ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EPAR</span></code></dt>
<dd><p class="first">End parallel region.
Always matches a BPAR ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BCS</span></code></dt>
<dd><p class="first">Begin critical section.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ECS</span></code></dt>
<dd><p class="first">End critical section.
Always matches a BCS ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BARRIER</span></code></dt>
<dd><p class="first">Barrier; thread synchronization point.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
QJSR null =e&#39;_mp_barrier2 t1
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>PDO</strong> sym stc    <em>Type</em>: <em>SMP</em></p>
<p>Marks the block associated with label as a parallel loop.
‘sym’ - symbol table pointer to the label.
‘stc’ - encoded schedule information: stc&amp;0xff          (stc&gt;&gt;8)&amp;Oxff
0 static       0 chunk not specified
0 static       1 chunk is 1
0 static       1 chunk is ‘n’
1 dynamic         NA
2 guided          NA
3 interleaved     NA
4 runtime         NA</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>BSECTIONS</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>Begin SECTIONS directive.</p>
<div class="line-block">
<div class="line">The BSECTIONS, SECTION, and ESECTIONS ILMs define a sections</div>
<div class="line">control structure.  The sequence of ILMs and generated code</div>
<div class="line">appear as:</div>
<div class="line">BSECTIONS L1</div>
<div class="line">if (_mp_lcpu2() .ne. 0) goto L1</div>
<div class="line">&lt;section 0&gt;</div>
<div class="line">SECTION   1 L2 L1</div>
<div class="line">L1:</div>
<div class="line">if (_mp_lcpu2() .ne. mod(1, _mp_ncpus2()) goto L2</div>
<div class="line">&lt;section 1&gt;</div>
<div class="line">SECTION   2 L3 L2</div>
<div class="line">L2:</div>
<div class="line">if (_mp_lcpu2() .ne. mod(2, _mp_ncpus2()) goto L3</div>
<div class="line">&lt;section 2&gt;</div>
<div class="line">…</div>
<div class="line">SECTION   n LL Ln</div>
<div class="line">Ln:</div>
<div class="line">if (_mp_lcpu2() .ne. mod(n, _mp_ncpus2()) goto LL</div>
<div class="line">&lt;section n&gt;</div>
<div class="line">ESECTIONS LL</div>
<div class="line">LL:</div>
<div class="line">…</div>
<div class="line"><br /></div>
<div class="line">sym - symbol table pointer of the label of the next lexical section</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
JSR t2 =e&#39;_mp_lcpu2 t1
DFRIR t2 t2 drret
ICJMPZ null t2 ne v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>SECTION</strong> lnk sym1 sym2    <em>Type</em>: <em>SMP</em></p>
<p>SECTION directive.</p>
<div class="line-block">
<div class="line">lnk  - ILM representing the current section number.</div>
<div class="line">sym1 - symbol table pointer of the label of the next lexical section</div>
<div class="line">sym2 - symbol table pointer of the label which labels this section.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
JSR t2 =e&#39;_mp_lcpu2 t1
DFRIR t2 t2 drret
JSR t3 =e&#39;_mp_ncpus2 t1
DFRIR t3 t3 drret
MOD t3 p1 t3
ICJMP null t3 t2 ne v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>LSECTION</strong> lnk sym1 sym2    <em>Type</em>: <em>SMP</em></p>
<p>LSECTION represent the end of last section for llvm target.</p>
<div class="line-block">
<div class="line">lnk  - ILM representing the current section number.</div>
<div class="line">sym1 - symbol table pointer of the label of the next lexical section</div>
<div class="line">sym2 - symbol table pointer of the label which labels this section.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
JSR t2 =e&#39;_mp_lcpu2 t1
DFRIR t2 t2 drret
JSR t3 =e&#39;_mp_ncpus2 t1
DFRIR t3 t3 drret
MOD t3 p1 t3
ICJMP null t3 t2 ne v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>ESECTIONS</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>End SECTIONS directive; always matches a BSECTIONS.</p>
<div class="line-block">
<div class="line">sym - symbol table pointer of the label of the end of the</div>
<div class="line">sections/endsections control structure.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>MASTER</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>Begin master section.</p>
<div class="line-block">
<div class="line">sym - symbol table pointer to the end of section label.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
JSR t2 =e&#39;_mp_lcpu2 t1
DFRIR t2 t2 drret
ICJMPZ null t2 ne v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>EMASTER</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>End master section.
Always matches a MASTER ilm.</p>
<div class="line-block">
<div class="line">sym - symbol table pointer to the end of section label.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SINGLE</strong> lnk sym    <em>Type</em>: <em>SMP</em></p>
<p>Single directive.</p>
<div class="line-block">
<div class="line">lnk - ILM representing the current single section number.</div>
<div class="line">sym - symbol table pointer to the end of section label.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
JSR t2 =e&#39;_mp_lcpu2 t1
DFRIR t2 t2 drret
JSR t3 =e&#39;_mp_ncpus2 t1
DFRIR t3 t3 drret
MOD t3 p1 t3
ICJMP null t3 t2 ne v2
</pre></div>
</div>
</li>
<li><p class="first"><strong>ESINGLE</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>End single section.
Always matches a SINGLE ilm.</p>
<div class="line-block">
<div class="line">sym - symbol table pointer to the end of section label.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">LCPU</span></code></dt>
<dd><p class="first">Intrinsic for computing the cpu/thread number - only works
within the context of BPAR/EPAR.</p>
<p><em>Attributes</em>: spec</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
JSR t2 =e&#39;_mp_lcpu t1
DFRIR r t2 drret
</pre></div>
</div>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">LCPU2</span></code></p>
<blockquote>
<div><em>Attributes</em>: spec
Intrinsic for computing the cpu/thread number - more general
version of LCPU.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">LCPU3</span></code></p>
<blockquote>
<div><em>Attributes</em>: spec
Intrinsic for computing the cpu/thread number to be used as the subscript
of a threadprivate’s vector.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NCPUS</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: spec
Intrinsic for computing the number of cpus/threads - only works
within the context of BPAR/EPAR.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
JSR t2 =e&#39;_mp_ncpus t1
DFRIR r t2 drret
</pre></div>
</div>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NCPUS2</span></code></p>
<blockquote>
<div><em>Attributes</em>: spec
Intrinsic for computing the number of cpus/threads - more general
version of NCPUS.</div></blockquote>
<ol class="arabic">
<li><p class="first"><strong>PRE_TLS_COPY</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>Prepare the copyin for threadprivate in TLS. Thread that comes upon the
parallel  region must save tls-threaprivate address.</p>
<div class="line-block">
<div class="line">sym - symbol of the tls-threadprivate that is to be copied.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">BCOPYIN</span></code></dt>
<dd><p class="first">Begin a copyin block.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
QJSR null =e&#39;_mp_copyin_init t1
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>COPYIN</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>Copyin a threadprivate common block or member</p>
<div class="line-block">
<div class="line">sym - symbol table entry of the object to be copied in; if it’s</div>
<div class="line">ST_CMBLK, the whole common block is copied in.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>COPYIN_A</strong> sym lnk    <em>Type</em>: <em>SMP</em></p>
<p>Copyin a threadprivate allocatable</p>
<div class="line-block">
<div class="line">sym - symbol table entry of the allocatable object to be copied in.</div>
<div class="line">lnk - size of the allocatable</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>COPYIN_CL</strong> sym1 sym2    <em>Type</em>: <em>SMP</em></p>
<p>Copyin a threadprivate common block or member</p>
<div class="line-block">
<div class="line">sym1 - symbol table entry of the object to be copied in; if it’s</div>
<div class="line">ST_CMBLK, the whole common block is copied in.</div>
<div class="line">sym2 -  symbol table entry of the assignment operator routine</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ECOPYIN</span></code></dt>
<dd><p class="first">End a copyin block.</p>
<p><em>Attributes</em>: spec trm</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
QJSR null =e&#39;_mp_copyin_term t1
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>BCOPYPRIVATE</strong> lnk    <em>Type</em>: <em>SMP</em></p>
<p>Begin a copyprivate block.</p>
<div class="line-block">
<div class="line">lnk - thread number of the thread from which the value(s) are to be copied</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
QJSR null =e&#39;_mp_copypriv_init t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>COPYPRIVATE_P</strong> lnk1 lnk2    <em>Type</em>: <em>SMP</em></p>
<p>Copyprivate (out) a private variables</p>
<div class="line-block">
<div class="line">lnk1 - thread number of the thread from which the value(s) are to be copied</div>
<div class="line">lnk2 - link to the data item that is the object of the COPYPRIVATE</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>COPYPRIVATE_PA</strong> lnk1 lnk2 lnk3    <em>Type</em>: <em>SMP</em></p>
<p>Copyprivate (out) a private allocatable variable</p>
<div class="line-block">
<div class="line">lnk1 - thread number of the thread from which the value(s) are to be copied</div>
<div class="line">lnk2 - link to the data item that is the object of the COPYPRIVATE</div>
<div class="line">lnk3 - size of the allocatable</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>COPYPRIVATE_CL_P</strong> lnk1 lnk2 sym    <em>Type</em>: <em>SMP</em></p>
<p>Copyprivate (out) a C++ private variable of type class</p>
<div class="line-block">
<div class="line">lnk1 - thread number of the thread from which the value(s) are to be copied</div>
<div class="line">lnk2 - link to the data item that is the object of the COPYPRIVATE</div>
<div class="line">sym - symbol table enttry of the assignment operator routine</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>COPYPRIVATE</strong> lnk sym    <em>Type</em>: <em>SMP</em></p>
<p>Copyprivate (out) a threadprivate common block, common block member, or variable</p>
<div class="line-block">
<div class="line">lnk - thread number of the thread from which the value(s) are to be copied</div>
<div class="line">sym - symbol table entry of the object to be copied out; if it’s</div>
<div class="line">ST_CMBLK, the whole common block is copied out.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>COPYPRIVATE_CL</strong> lnk1 sym1 sym2    <em>Type</em>: <em>SMP</em></p>
<p>Copyprivate (out) a threadprivate C++ variable of type class</p>
<div class="line-block">
<div class="line">lnk1 - thread number of the thread from which the value(s) are to be copied</div>
<div class="line">sym1 - symbol table entry of the class object to be copied out</div>
<div class="line">sym2 - link to the ilms loading the assignment operator routine</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>ECOPYPRIVATE</strong> lnk    <em>Type</em>: <em>SMP</em></p>
<p>End a copyprivate block.</p>
<div class="line-block">
<div class="line">lnk - thread number of the thread from which the value(s) are to be copied</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
QJSR null =e&#39;_mp_copypriv_term t1
</pre></div>
</div>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">FLUSH</span></code></dt>
<dd><p class="first">Flush to memory</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>P</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>P(semaphore) - begin a critical section.</p>
<div class="line-block">
<div class="line">sym - symbol table entry of a semaphore variable</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>V</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>V(semaphore) - end a critical section.</p>
<div class="line-block">
<div class="line">sym - symbol table entry of a semaphore variable</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PREFETCH</strong> lnk stc    <em>Type</em>: <em>misc</em></p>
<p>Cache prefetch.</p>
<div class="line-block">
<div class="line">lnk1 - ILM link to an address</div>
<div class="line">stc2 - prefetch flag (for future use).</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PREFETCH null p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>BBND</strong> sym stc    <em>Type</em>: <em>misc</em></p>
<p>BBND begins the ILMs of the assignments of the bounds
of an adjustable array when it’s unknown by
semant that the array is dummy or allocatable
at the time the array is declared.
This could occur when an adjustable array is declared
before its appearance in an ENTRY statement.
If the array is a dummy argument,
the expander will skip the ensuing bounds assignments.</p>
<div class="line-block">
<div class="line">sym - symbol table entry of an array with adjustable bounds</div>
<div class="line">stc - number of words in the ensuing block of ILMs</div>
<div class="line">representing the adjustable bounds.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>FILE</strong> stc stc stc    <em>Type</em>: <em>misc</em></p>
<p>FILE gives file information when inlining a file.
First operand is the line number.
Second operand is the FIH index of the current file (source or include file).
Third operand is the global ILM index.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>ALLOC</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Allocate memory for a C or C++ variable length array.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ALLOC r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>DEALLOC</strong> lnk    <em>Type</em>: <em>misc</em></p>
<p>Deallocate memory that was allocated by ALLOC.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>ALLOCA</strong> lnk lnk sym stc    <em>Type</em>: <em>arth</em></p>
<p>Use the alloca builtin to create stack space.</p>
<div class="line-block">
<div class="line">lnk - number of elements</div>
<div class="line">lnk - size (units of bytes) of the base type</div>
<div class="line">sym - symbol table entry of the automatic array</div>
<div class="line">stc - flags: 0 - function level; 1 - from inliner</div>
</div>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>DEALLOCA</strong> lnk sym1 sym2 stc    <em>Type</em>: <em>misc</em></p>
<p>Deallocate memory that was allocated by ALLOCA.
Generally, this is a no-op, but if IM_ALLOCA reverts to using
the heap, need to explicitly free.
lnk  - load of array’s pointer variable
sym1 - symbol table entry of the automatic array
sym2 - symbol table entry of the deallocation routine
stc - flags: 0 - function level; 1 - from inliner</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>BPARN</strong> lnk lnk    <em>Type</em>: <em>SMP</em></p>
<p>Begin parallel region with num_threads.</p>
<div class="line-block">
<div class="line">lnk1 - link to logical expression (inhibit parallel flag):</div>
<div class="line">0       – parallel execution</div>
<div class="line">nonzero – serial execution</div>
<div class="line">lnk2 - link to the num_threads values</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>BPARA</strong> lnk lnk stc1 stc2    <em>Type</em>: <em>SMP</em></p>
<p>Begin parallel region with num_threads and proc_bind.</p>
<div class="line-block">
<div class="line">lnk1 - link to logical expression (inhibit parallel flag):</div>
<div class="line">0       – parallel execution</div>
<div class="line">nonzero – serial execution</div>
<div class="line">lnk2 - link to the num_threads values</div>
<div class="line">stc1 - bit vector:</div>
<div class="line">0x01 - proc_bind is present</div>
<div class="line">0x02 - num_thread is presetnt</div>
<div class="line">0x04 - if is present</div>
<div class="line">stc2:</div>
<div class="line">0x0  - proc_bind - false</div>
<div class="line">0x02 - proc_bind - master</div>
<div class="line">0x03 - proc_bind - close</div>
<div class="line">0x04 - proc_bind - spread</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">EPARN</span></code></dt>
<dd><p class="first">End parallel region.
Always matches a BPARN ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>BLOCK</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>Beginning of a lexical block; sym is the symbol table pointer to the
block symbol.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Pointer comparison for Fortran.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>PRAGMASYM</strong> n stc stc sym*    <em>Type</em>: <em>misc</em></p>
<p>Handles a pragma with a list of symbols.
First stc is the pragma identifier, 2nd stc is the scope.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PRAGMAEXPR</strong> n stc stc lnk stc*    <em>Type</em>: <em>misc</em></p>
<p>Handles a pragma with an expression argument
First stc is the pragma identifier, 2nd stc is the scope.
Link is the expression.
List of stc gives any other arguments.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PRAGMASYMEXPR</strong> n stc stc sym lnk*    <em>Type</em>: <em>misc</em></p>
<p>Handles a pragma with a symbol and a number of expression arguments.
First stc is the pragma identifier, 2nd stc is the scope.
Sym is the symbol.
Links point to the arguments.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PRAGMAGEN</strong> n stc stc stc*    <em>Type</em>: <em>misc</em></p>
<p>Handles a pragma with no expression and no symbol arguments.
First stc is the pragma identifier, 2nd stc is the scope.
List of stc gives any other arguments.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>MPLOOP</strong> sym sym sym sym sym stc stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin parallel do/loop
sym - lower bound
sym - upper bound
sym - stride
sym - chunk
sym - plast
stc -  dtype of loop bound type
stc -  schedule type</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>MPDISTLOOP</strong> sym sym sym sym sym sym stc stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin parallel do/loop
sym - lower bound
sym - upper bound
sym - stride
sym - chunk
sym - plast
sym - upperD
stc -  dtype of loop bound type
stc -  schedule type</p>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">BTASKDUP</span></code></dt>
<dd><p class="first">Begin taskdup routine</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ETASKDUP</span></code></dt>
<dd><p class="first">End taskdup routine</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>MPTASKLOOP</strong> sym sym sym sym stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin taskloop
sym - lower bound
sym - upper bound
sym - stride
sym - last iteration
stc -  dtype of loop bound type</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>TASKLASTPRIV</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>taskloop lastprivate offset on task structure
sym - offset constant</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>MPLOOPFINI</strong> stc stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin parallel do/loop
stc - dtype of loop bound type
stc - schedule type</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>MPSCHED</strong> sym sym sym sym stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin parallel do/loop schedule
sym - lower bound
sym - upper bound
sym - stride
sym - plast
stc - dtype of loop bound type</p>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MPBORDERED</span></code></dt>
<dd><p class="first">Begin KMPC ordered region</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPEORDERED</span></code></dt>
<dd><p class="first">End KMPC ordered region</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BPDO</span></code></dt>
<dd><p class="first">Begin parallel do/loop</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EPDO</span></code></dt>
<dd><p class="first">End parallel do/loop
Always matches a BPDO ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>CANCEL</strong> sym stc lnk    <em>Type</em>: <em>SMP</em></p>
<p>Cancel construct</p>
<div class="line-block">
<div class="line">sym - symbol table pointer to the end of construct label.</div>
<div class="line">stc - bit vector:</div>
<div class="line">0x01 - parallel</div>
<div class="line">0x02 - loop</div>
<div class="line">0x03 - sections</div>
<div class="line">0x04 - taskgroup</div>
<div class="line">lnk - link to the logical expression in the if clause; if the clause</div>
<div class="line">is absent, this field is 1 - always call cancel.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CANCELPOINT</strong> sym stc    <em>Type</em>: <em>SMP</em></p>
<p>Cancellation construct</p>
<div class="line-block">
<div class="line">sym - symbol table pointer to the end of construct label.</div>
<div class="line">stc - bit vector:</div>
<div class="line">0x01 - parallel</div>
<div class="line">0x02 - loop</div>
<div class="line">0x03 - sections</div>
<div class="line">0x04 - taskgroup</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>TASKFIRSTPRIV</strong> sym sym    <em>Type</em>: <em>SMP</em></p>
<p>Task firstprivate
sym - symbol table pointer to the shared variable.
sym - symbol table pointer to the private copy.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>BTASK</strong> sym stc lnk lnk    <em>Type</em>: <em>SMP</em></p>
<p>Begin task
Always matches a ETASK ilm</p>
<div class="line-block">
<div class="line">sym - symbol table pointer to the end of task label.</div>
<div class="line">If this is llvm and C, this will actually be a symbol</div>
<div class="line">table pointer to the flags variable that should already be initialized.</div>
<div class="line">stc - bit vector:</div>
<div class="line">0x01 - untied clause is present</div>
<div class="line">0x02 - if clause is present</div>
<div class="line">lnk1 - link to the logical expression in the if clause; if the clause</div>
<div class="line">is absent, this field is ‘null’ (BOS_SIZE)</div>
<div class="line">lnk2 - link to the logical expression in the final clause; if the clause</div>
<div class="line">is absent, this field is ‘null’</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>BTASKLOOP</strong> sym stc lnk lnk lnk lnk    <em>Type</em>: <em>SMP</em></p>
<p>Begin taskloop
Always matches a ETASKLOOP ilm</p>
<div class="line-block">
<div class="line">sym - symbol table pointer to the end of taskloop label.</div>
<div class="line">If this is llvm and C, this will actually be a symbol</div>
<div class="line">table pointer to the flags variable that should already be initialized.</div>
<div class="line">stc - bit vector:</div>
<div class="line">0x01 - untied clause is present</div>
<div class="line">0x02 - if clause is present</div>
<div class="line">0x20 - if final is present</div>
<div class="line">0x80 - if mergeable is present</div>
<div class="line">0x1000 - nogroup clause is present</div>
<div class="line">0x2000 - grainsize clause is present</div>
<div class="line">0x4000 - num_tasks clause is present</div>
<div class="line">lnk1 - link to the logical expression in the if clause; if the clause</div>
<div class="line">is absent, this field is ‘null’ (BOS_SIZE)</div>
<div class="line">lnk2 - link to the logical expression in the final clause; if the clause</div>
<div class="line">is absent, this field is ‘null’</div>
<div class="line">lnk3 - link to priority expression, if clause is absent, this file is 0</div>
<div class="line">lnk4 - link to grainsize or num_tasks, if clause is abssent, this field</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ETASKGROUP</span></code></dt>
<dd><p class="first">Begin Task group.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TASKGROUP</span></code></dt>
<dd><p class="first">End of Task group.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ETEAMS</span></code></dt>
<dd><p class="first">End of Teams register.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BTEAMS</span></code></dt>
<dd><p class="first">Teams register</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>BTEAMSN</strong> lnk lnk    <em>Type</em>: <em>SMP</em></p>
<p>Teams register
lnk1 - link to num_teams expression.
lnk2 - link to thread limit expression.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ETARGETDATA</span></code></dt>
<dd><p class="first">End of target data</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>BTARGETDATA</strong> lnk    <em>Type</em>: <em>SMP</em></p>
<p>Begin target data</p>
<div class="line-block">
<div class="line">lnk - link to logical expression (inhibit target data flag):</div>
<div class="line">0       – target data execution on host(device is host)</div>
<div class="line">nonzero – target data execution on device</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>BTARGETUPDATE</strong> lnk stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin target update</p>
<div class="line-block">
<div class="line">lnk - link to logical expression (inhibit target update flag):</div>
<div class="line">0       – nop</div>
<div class="line">nonzero – target update execution</div>
<div class="line">stc - flag for target [inout|out|in|nowait|if]</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>TARGETUPDATE</strong> n stc lnk lnk*    <em>Type</em>: <em>SMP</em></p>
<p>Handles a to/from clause from target update with a link to a symbol and a number of expression arguments.</p>
<div class="line-block">
<div class="line">n - number of extra args</div>
<div class="line">stc - map type</div>
<div class="line">lnk - symbol to be mapped</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ETARGETUPDATE</span></code></dt>
<dd><p class="first">End target update</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>TARGETENTERDATA</strong> lnk stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin target enter data</p>
<div class="line-block">
<div class="line">lnk - link to logical expression (inhibit target enter data flag):</div>
<div class="line">0       – target enter data execution on host(device is host)</div>
<div class="line">nonzero – target enter execution on device</div>
<div class="line">stc - flag for target [inout|out|in|nowait|if]</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>TARGETEXITDATA</strong> lnk stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin target exit data</p>
<div class="line-block">
<div class="line">lnk - link to logical expression (inhibit target exit data flag):</div>
<div class="line">0       – target exit data execution on host(device is host)</div>
<div class="line">nonzero – target exit data execution on device</div>
<div class="line">stc - flag for target [inout|out|in|nowait|if]</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ETARGET</span></code></dt>
<dd><p class="first">End of Target register.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>BTARGET</strong> lnk stc    <em>Type</em>: <em>SMP</em></p>
<p>Target register</p>
<div class="line-block">
<div class="line">lnk - link to logical expression (inhibit target exit data flag):</div>
<div class="line">0       – target exit data execution on host(device is host)</div>
<div class="line">nonzero – target exit data execution on device</div>
<div class="line">stc - flag for target [inout|out|in|nowait|if]</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">EDISTRIBUTE</span></code></dt>
<dd><p class="first">End of Distribute register.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BDISTRIBUTE</span></code></dt>
<dd><p class="first">Distribute register</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ETASKREG</span></code></dt>
<dd><p class="first">End of Task register used in llvm target to mark the end of task region.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TASKREG</span></code></dt>
<dd><p class="first">Task register</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ETASKLOOPREG</span></code></dt>
<dd><p class="first">End of Taskloop register used in llvm target to mark the end of task region.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TASKLOOPVARS</span></code></dt>
<dd><p class="first">Begin set up taskloop variables</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>TASKLOOPREG</strong> lnk lnk lnk    <em>Type</em>: <em>SMP</em></p>
<p>Begin taskloop register</p>
<div class="line-block">
<div class="line">stc - bit vector</div>
<div class="line">lnk1 -  lowerbound</div>
<div class="line">lnk2 -  upperbound</div>
<div class="line">lnk3 -  stride</div>
<div class="line">.AT spec trm</div>
<div class="line">.OP NULL t1 iv0</div>
<div class="line">.OP QJSR null =e’_mp_task_begin t1</div>
<div class="line">.IL ETASK SMP sym</div>
<div class="line">End task</div>
<div class="line">Always matches a BTASK ilm</div>
<div class="line">.nf</div>
<div class="line">sym - symbol table pointer to the end of task label.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
QJSR null =e&#39;_mp_task_end t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>ETASKLOOP</strong> sym    <em>Type</em>: <em>SMP</em></p>
<p>End taskloop
Always matches a BTASKLOOP ilm</p>
<div class="line-block">
<div class="line">sym - symbol table pointer to the end of task label.</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TASKWAIT</span></code></dt>
<dd><p class="first">Taskwait</p>
<p><em>Attributes</em>: spec trm</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
QJSR null =e&#39;_mp_task_wait t1
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TASKYIELD</span></code></dt>
<dd><p class="first">Taskyield</p>
<p><em>Attributes</em>: spec trm</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span>NULL t1 iv0
QJSR null =e&#39;_mp_task_yield t1
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BMPPG</span></code></dt>
<dd><p class="first">Mark the block representing possible prologue of an mp region for
the parallel, parallel do, parallel section, &amp; task directives.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EMPPG</span></code></dt>
<dd><p class="first">End the mp region to which the prologue applies.
Always matches a BMPPG ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BAMPPG</span></code></dt>
<dd><p class="first">Add the ensuing code to the prologue</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EAMPPG</span></code></dt>
<dd><p class="first">End adding to the prologue.
Always matches a BAMPPG ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>INLINE_START</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>INLINE_START is put out at the beginning of an lined function to tell zc_eh
processing to process a possible region</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>INLINE_END</strong> sym    <em>Type</em>: <em>misc</em></p>
<p>INLINE_END is put out at the end of an lined function to tell zc_eh
processing to process a possible region</p>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">BEGIN_CATCH</span></code></dt>
<dd><p class="first">Mark the beginning of a user’s C++ catch region for GSCOPE purposes</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">END_CATCH</span></code></dt>
<dd><p class="first">Mark the end of a user’s C++ catch region for GSCOPE purposes</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>EHREG_ST</strong> sym sym    <em>Type</em>: <em>misc</em></p>
<p>Store catch_clause, caught_object to registers</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>EHRESUME</strong> sym sym    <em>Type</em>: <em>misc</em></p>
<p>Resume propagation of an existing in-flight exception whose unwinding was
interrupted to run some cleanup code.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PRAGMASLIST</strong> n stc stc lnk*    <em>Type</em>: <em>misc</em></p>
<p>Handles a pragma with a list of links to symbols.
First stc is the pragma identifier, 2nd stc is the scope.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>PRAGMASELIST</strong> n stc stc lnk lnk*    <em>Type</em>: <em>misc</em></p>
<p>Handles a pragma with a link to a symbol and a number of expression arguments.
First stc is the pragma identifier, 2nd stc is the scope.
Sym is the symbol link.
Links point to the arguments.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>SCOPEBEGIN</strong> sym sym    <em>Type</em>: <em>misc</em></p>
<p>Start a new lexical scope; first symbol is the block symbol, second symbol
is the label for the beginning of the scope.</p>
</li>
<li><p class="first"><strong>SCOPEEND</strong> sym sym    <em>Type</em>: <em>misc</em></p>
<p>End an existing lexical scope; first symbol is the block symbol, second symbol
is the label for the end of the scope.</p>
</li>
<li><p class="first"><strong>X87CON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p>x87 80-bit extended precision constant.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87CON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>X87LD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>x87 80-bit extended precision load.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>X87ST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>x87 80-bit extended precision store.</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>X87FROM</strong> lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Convert the DT_xxx type encoded by ‘stc’ to x87 80-bit extended precision.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>X87TO</strong> lnk stc    <em>Type</em>: <em>arth</em></p>
<p>Convert x87 80-bit extended precision to the DT_xxx type encoded by ‘stc’.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>X87NEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision negation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87CHS r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>X87ADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision addition.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87ADD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>X87SUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision subtraction.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87SUB r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>X87MUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision multiplication.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87MUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>X87DIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision division.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87DIV r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>X87CMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision comparison.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>X87FUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call long double function returning x87 80-bit extended precision.</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>X87CMPLX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>X87REAL</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>X87IMAG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>CX87CON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p>x87 80-bit extended precision complex constant.</p>
<p><em>Attributes</em>: spec x87cmplx</p>
</li>
<li><p class="first"><strong>CX87LD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>x87 80-bit extended precision complex load.</p>
<p><em>Attributes</em>: spec x87cmplx</p>
</li>
<li><p class="first"><strong>CX87ST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>x87 80-bit extended precision complex store.</p>
<p><em>Attributes</em>: spec trm x87cmplx</p>
</li>
<li><p class="first"><strong>CX87STR</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store the real part of a long double complex</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CX87STI</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store the imaginary part of a long double complex</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>CX87NEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision complex negation.</p>
<p><em>Attributes</em>: x87cmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87CHS rr rp1
X87CHS ir ip1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CX87ADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision complex addition.</p>
<p><em>Attributes</em>: x87cmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87ADD rr rp1 rp2
X87ADD ir ip1 ip2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CX87SUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision complex subtraction.</p>
<p><em>Attributes</em>: x87cmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87SUB rr rp1 rp2
X87SUB ir ip1 ip2
</pre></div>
</div>
</li>
<li><p class="first"><strong>CX87MUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision complex multiplication.</p>
<p><em>Attributes</em>: x87cmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87MUL t1 rp1 rp2
X87MUL t2 ip1 ip2
X87SUB rr t1 t2
X87MUL t1 ip1 rp2
X87MUL t2 ip2 rp1
X87ADD ir t2 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CX87DIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision complex division.</p>
<p><em>Attributes</em>: x87cmplx</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X87MUL t1 rp2 rp2
X87MUL t2 ip2 ip2
X87ADD t1 t1 t2
X87MUL t2 rp1 rp2
X87MUL t3 ip1 ip2
X87ADD t2 t2 t3
X87DIV rr t2 t1
X87MUL t2 ip1 rp2
X87MUL t3 rp1 ip2
X87SUB t2 t2 t3
X87DIV ir t2 t1
</pre></div>
</div>
</li>
<li><p class="first"><strong>CX87CMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>x87 80-bit extended precision complex comparison.</p>
<p><em>Attributes</em>: spec x87cmplx</p>
</li>
<li><p class="first"><strong>CX87FUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call long double complex function returning x87 80-bit extended precision
complex.</p>
<p><em>Attributes</em>: spec x87cmplx</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">BEGINATOMIC</span></code></dt>
<dd><p class="first">Start marker for an ACC Atomic statement.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDATOMIC</span></code></dt>
<dd><p class="first">End marker for an ACC Atomic statement.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BEGINATOMICREAD</span></code></dt>
<dd><p class="first">Start marker for an ACC Atomic Read statement.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDATOMICREAD</span></code></dt>
<dd><p class="first">End marker for an ACC Atomic Read statement.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BEGINATOMICWRITE</span></code></dt>
<dd><p class="first">Start marker for an ACC Atomic Write statement.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDATOMICWRITE</span></code></dt>
<dd><p class="first">End marker for an ACC Atomic Write statement.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BEGINATOMICCAPTURE</span></code></dt>
<dd><p class="first">Start marker for an ACC Atomic Capture block.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDATOMICCAPTURE</span></code></dt>
<dd><p class="first">End marker for an ACC Atomic Capture block.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MP_ATOMIC</span></code></dt>
<dd><p class="first">Begin atomic region.
Always matches a ENDATOMIC ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MP_ENDATOMIC</span></code></dt>
<dd><p class="first">End atomic region.
Always matches a MP_ATOMIC ilm.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>MP_ATOMICREAD</strong> lnk stc    <em>Type</em>: <em>SMP</em></p>
<p>Atomic read</p>
<div class="line-block">
<div class="line">lnk - link variable to be loaded</div>
<div class="line">stc - memory order</div>
<div class="line">.AT spec trm</div>
<div class="line">.IL MP_ATOMICWRITE SMP lnk lnk stc</div>
<div class="line">Atomic write</div>
<div class="line">.nf</div>
<div class="line">lnk1 - link to left hand side of atomic write</div>
<div class="line">lnk2 - link to right hand side of atomic write</div>
<div class="line">stc - memory order</div>
<div class="line">.AT spec trm</div>
<div class="line">.IL MP_ATOMICUPDATE SMP lnk lnk stc stc</div>
<div class="line">Atomic write</div>
<div class="line">.nf</div>
<div class="line">lnk1 - link to left hand side of atomic update</div>
<div class="line">lnk2 - link to rhs atomic update</div>
<div class="line">stc1 - memory order</div>
<div class="line">stc2 - aop</div>
<div class="line">.AT spec trm</div>
<div class="line">.IL MP_ATOMICCAPTURE SMP lnk lnk stc stc stc</div>
<div class="line">Atomic write</div>
<div class="line">.nf</div>
<div class="line">lnk1 - link to left hand side of atomic capture</div>
<div class="line">lnk2 - link to right hand side of capture statement</div>
<div class="line">stc1 - memory order</div>
<div class="line">stc2 - aop</div>
<div class="line">stc4 - bit vector(unused):</div>
<div class="line">0x01 - is update statment</div>
<div class="line">0x02 - need post operation on old value</div>
<div class="line">.AT spec trm</div>
<div class="line">.IL PRAGMADPSELIST misc n stc stc lnk stc lnk*</div>
<div class="line">Handles a pragma with a link to a symbol and a number of expression arguments.</div>
<div class="line">n is number of subscripts defined by this pragma</div>
<div class="line">First stc is the pragma identifier, 2nd stc is the scope, 3rd stc is the policy id.</div>
<div class="line">First link is the symbol link.</div>
<div class="line">Links point to the arguments.</div>
<div class="line">.AT spec trm</div>
<div class="line">.IL MP_TARGETMODE SMP stc lnk lnk lnk</div>
<div class="line">End of Target register.</div>
<div class="line">.nf</div>
<div class="line">stc Combined costruct mode</div>
<div class="line">lnk link to num_teams clause if exists</div>
<div class="line">lnk link to thread_limit clause if exists</div>
<div class="line">lnk link to num_threads clause if exists</div>
<div class="line">.AT spec trm</div>
<div class="line">.IL MP_TARGETLOOPTRIPCOUNT SMP sym</div>
<div class="line">loop trip count for target region</div>
<div class="line">.nf</div>
<div class="line">sym - trip count</div>
<div class="line">.AT spec trm</div>
<div class="line">.IL MP_MAP SMP lnk stc</div>
<div class="line">map with to map type</div>
<div class="line">.nf</div>
<div class="line">lnk - symbol to be mapped</div>
<div class="line">stc - map type</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>MP_REDUCTIONITEM</strong> sym sym stc    <em>Type</em>: <em>SMP</em></p>
<p>Begin of reduction clause.</p>
<div class="line-block">
<div class="line">sym - reduction shared symbol</div>
<div class="line">sym - reduction private symbol</div>
<div class="line">stc - reduction operation</div>
</div>
<p><em>Attributes</em>: spec trm</p>
</li>
</ol>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MP_BREDUCTION</span></code></dt>
<dd><p class="first">Begin of reduction clause.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MP_EREDUCTION</span></code></dt>
<dd><p class="first">End of reduction clause.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MP_EMAP</span></code></dt>
<dd><p class="first">End of map clause.</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MP_BEGIN_DIR</span></code></dt>
<dd><p class="first">Begin directive</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MP_END_DIR</span></code></dt>
<dd><p class="first">End directive</p>
<p class="last"><em>Attributes</em>: spec trm</p>
</dd>
</dl>
<ol class="arabic">
<li><p class="first"><strong>HFLD</strong> lnk    <em>Type</em>: <em>load</em></p>
<p>Load half precision</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>HFST</strong> lnk lnk    <em>Type</em>: <em>store</em></p>
<p>Store half precision</p>
<p><em>Attributes</em>: spec trm</p>
</li>
<li><p class="first"><strong>HFCON</strong> sym    <em>Type</em>: <em>cons</em></p>
<p>Half precision constant</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFCON r v1
</pre></div>
</div>
</li>
<li><p class="first"><strong>HFADD</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Add half precision</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFADD r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>HFMUL</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Multiply half precision</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFMUL r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>HFSUB</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Subtract half precision</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFSUB r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>HFDIV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Divide half precision</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFDIV r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>HFNEG</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Negate half precision</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFNEG r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>R2HF</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert single precision to half precision</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SP2HP r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>D2HF</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert double precision to half precision</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DP2HP r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>HF2R</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Convert half precision to single precision</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HP2SP r p1
</pre></div>
</div>
</li>
<li><p class="first"><strong>HFFUNC</strong> n lnk lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call half precision function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>HFFUNC</strong> n sym lnk*    <em>Type</em>: <em>proc</em></p>
<p>Call half precision function</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>HFCMP</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Compare half precision</p>
<p><em>Attributes</em>: spec</p>
</li>
<li><p class="first"><strong>HFAIF</strong> lnk sym1 sym2 sym3    <em>Type</em>: <em>branch</em></p>
<p><em>Attributes</em>: spec trm</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFCJMPZ null p1 le v2
HFCJMPZ null p1 eq v3
HFCJMPZ null p1 gt v4
</pre></div>
</div>
</li>
<li><p class="first"><strong>HFMAX</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFMAX r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>HFMIN</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HFMIN r p1 p2
</pre></div>
</div>
</li>
<li><p class="first"><strong>UXLNEQV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .LNEQV. operation for unixlogical</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p1 eq
ICMPZ t2 p2 eq
ICMP r t1 t2 ne
</pre></div>
</div>
</li>
<li><p class="first"><strong>UXLEQV</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .LEQV. operation for unixlogical</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p1 eq
ICMPZ t2 p2 eq
ICMP r t1 t2 eq
</pre></div>
</div>
</li>
<li><p class="first"><strong>UXLAND</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .LAND. operation for unixlogical</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ t1 p1 eq
ICMPZ t2 p2 eq
IADD t3 t1 t2
ICMPZ r t3 eq
</pre></div>
</div>
</li>
<li><p class="first"><strong>UXLNOT</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .LNOT. operation for unixlogical</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ICMPZ r p1 eq
</pre></div>
</div>
</li>
<li><p class="first"><strong>UXLNEQV8</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .LNEQV8. operation for unixlogical</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCMPZ t1 p1 eq
KCMPZ t2 p2 eq
IKMV t1 t1
IKMV t2 t2
KCMP kr t1 t2 ne
</pre></div>
</div>
</li>
<li><p class="first"><strong>UXLEQV8</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .LEQV8. operation for unixlogical</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCMPZ t1 p1 eq
KCMPZ t2 p2 eq
IKMV t1 t1
IKMV t2 t2
KCMP kr t1 t2 eq
</pre></div>
</div>
</li>
<li><p class="first"><strong>UXLAND8</strong> lnk lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .LAND8. operation for unixlogical</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCMPZ t1 p1 eq
KCMPZ t2 p2 eq
KADD t3 t1 t2
KCMPZ kr t3 eq
</pre></div>
</div>
</li>
<li><p class="first"><strong>UXLNOT8</strong> lnk    <em>Type</em>: <em>arth</em></p>
<p>Logical .LNOT8. operation for unixlogical</p>
<p><em>Attributes</em>: i8</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KCMPZ kr p1 eq
</pre></div>
</div>
</li>
</ol>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="symtab.html">Symbol Table</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ilitp.html">X86-64 ILI Definitions</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>