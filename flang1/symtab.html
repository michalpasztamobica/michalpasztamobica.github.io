
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Symbol Table &#8212; Flang 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Appendix VII - Intrinsics &amp; Generics" href="symini.html" />
    <link rel="prev" title="Data Initialization File" href="dinit.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Flang 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Symbol Table</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="dinit.html">Data Initialization File</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="symini.html">Appendix VII - Intrinsics &amp; Generics</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="symbol-table">
<h1>Symbol Table<a class="headerlink" href="#symbol-table" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The Symbol Table is used throughout the Fortran compiler to maintain information on
user defined and compiler created symbols, constants, and labels.</p>
<p>The Symbol Table is maintained in dynamic storage space which is extended
if necessary.
Each symbol table entry consists of
32 32-bit words
which are divided into fields of various lengths.
The layout of the <code class="docutils literal notranslate"><span class="pre">SYM</span></code> structure is strict
(see type <code class="docutils literal notranslate"><span class="pre">SYM</span></code> in <em>symacc.h</em>);
overlaying fields with fields of different types is not allowed.
Symbol table pointers
are integers (greater than zero) which are stored as ints
and used as relative pointers from a base pointer.</p>
<p>A second dynamic storage area, the symbol name area, is used to
store the text of symbol names and character string constants.</p>
<p>Symbols are added to the Symbol Table using a set of access
routines which are described later on in this section.</p>
<p>Symbol Table fields are accessed via a set of C macros.  These macros are
upper case and consist of the name of the field followed by either
“P”
for the put macro or
“G”
for the get macro.  The put macros take two arguments,
a symbol table pointer and the value to be inserted.  The get macros take
a single argument which is a symbol table pointer, and return the value
of the field.
For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>STYPEP(sptr, ST_VAR);     stype = STYPEG(sptr);
</pre></div>
</div>
<p>The macro definitions and the necessary C data declaration statements
required to access the Symbol Table are in the include file
<em>symtab.n</em>.</p>
<p>The Symbol Table initially contains entries for all of
the intrinsic and generic functions supported by the Fortran compiler.
This initial Symbol Table is created by the utility program SYMINI,
which is described later on in this section.
Appendix III contains the input file to SYMINI which
defines the intrinsics and generics.</p>
</div>
<div class="section" id="symbol-name-overloading">
<h2>Symbol Name Overloading<a class="headerlink" href="#symbol-name-overloading" title="Permalink to this headline">¶</a></h2>
<p>Because of symbol name overloading, and multiple scopes,
the Symbol Table will often contain more than one
entry for a given name.</p>
<p>The concept of
<em>overloading class</em>
is used by the compiler.
By definition, two entities in different overloading
classes are allowed to share the same name. The
context in which the name is used will always determine
which entity is being referred to.
The overloading class of a symbol is determined by its
stype,
<code class="docutils literal notranslate"><span class="pre">STYPE</span></code>;
the overloading classes are:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">OC_MEMBERS</span></code></dt>
<dd>Structure and union member names.  Actually, there is a separate overloading
class for each structure or union (i.e.,
two different structures or unions
are allowed to have identically named members).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">OC_STAG</span></code></dt>
<dd>Structure tags (structure template name).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">OC_CMBLK</span></code></dt>
<dd>Common block names.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">OC_OPERATOR</span></code></dt>
<dd>User-defined operator names.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">OC_CONSTRUCT</span></code></dt>
<dd>Names of constructs, such as block IFs, DO loops, etc.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">OC_OTHER</span></code></dt>
<dd>Other names.
This class includes variables, functions.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">OC_NONE</span></code></dt>
<dd>Overloading class is not applicable.</dd>
</dl>
</div>
<div class="section" id="symbol-table-fields">
<h2>Symbol Table Fields<a class="headerlink" href="#symbol-table-fields" title="Permalink to this headline">¶</a></h2>
<div class="section" id="shared-fields">
<h3>Shared Fields<a class="headerlink" href="#shared-fields" title="Permalink to this headline">¶</a></h3>
<p>In general, each type of symbol table entry (see STYPE below) has
a different set of fields associated with it.
This section describes those fields which are used by all or most
of the symbol types.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">STYPE</span></code></dt>
<dd><p class="first">This field defines the type of symbol table entry.  C constant (c
<a href="#id1"><span class="problematic" id="id2">``</span></a>#define``d)
symbols
are used for the various values which the stype may take on.
The different symbol types and their values are:</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ST_UNKNOWN</span></code></dt>
<dd>Symbol entered initially by scanner but not yet resolved by semantic analysis.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_IDENT</span></code></dt>
<dd>Identifier.  Used for symbols during semantic analysis until the true
type of the symbol can be determined.  See note below.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_LABEL</span></code></dt>
<dd>Statement label.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_CONST</span></code></dt>
<dd>Constant.  Includes integer, real, character, etc. constants.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_STAG</span></code></dt>
<dd>Structure template name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_MEMBER</span></code></dt>
<dd>Member of a struct, union, or derived type.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_VAR</span></code></dt>
<dd>Scalar variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_ARRAY</span></code></dt>
<dd>Array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_DESCRIPTOR</span></code></dt>
<dd>Internally-created descriptor variable, usually implemented as
an array; this symbol type is used so optimizations can avoid looking at it.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_STRUCT</span></code></dt>
<dd>Structure variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_UNION</span></code></dt>
<dd>Union variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_CMBLK</span></code></dt>
<dd>Common block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_NML</span></code></dt>
<dd>Namelist.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_ENTRY</span></code></dt>
<dd>Entry point to current subprogram unit.  i.e. name specified on
<code class="docutils literal notranslate"><span class="pre">SUBROUTINE</span></code>,
<code class="docutils literal notranslate"><span class="pre">FUNCTION</span></code>,
<code class="docutils literal notranslate"><span class="pre">BLOCKDATA</span></code>,
<code class="docutils literal notranslate"><span class="pre">PROGRAM</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">ENTRY</span></code>
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_PROC</span></code></dt>
<dd>External subprogram referenced by current subprogram.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_STFUNC</span></code></dt>
<dd>Statement function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_PARAM</span></code></dt>
<dd>Constant symbol defined in a
<code class="docutils literal notranslate"><span class="pre">PARAMETER</span></code>
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_INTRIN</span></code></dt>
<dd>Intrinsic function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_GENERIC</span></code></dt>
<dd>Generic function name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_USERGENERIC</span></code></dt>
<dd>Generic function name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_PD</span></code></dt>
<dd>Predeclared subroutine name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_PLIST</span></code></dt>
<dd>Argument list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_ARRDSC</span></code></dt>
<dd>Array descriptor symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_ALIAS</span></code></dt>
<dd>Alias symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_MODULE</span></code></dt>
<dd>Module.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_TYPEDEF</span></code></dt>
<dd>Derived type.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_OPERATOR</span></code></dt>
<dd>User-defined operator.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_MODPROC</span></code></dt>
<dd>Module procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_CONSTRUCT</span></code></dt>
<dd>Named construct.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_BLOCK</span></code></dt>
<dd>Lexical block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_CRAY</span></code></dt>
<dd>Cray intrinsics.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_ISOC</span></code></dt>
<dd>Iso_c intrinsic library routines</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_IEEEARITH</span></code></dt>
<dd>IEEE_ARITHMETIC module procedures</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_IEEEEXCEPT</span></code></dt>
<dd>IEEE_EXCEPTIONS module procedures</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_ISOFTNENV</span></code></dt>
<dd>Iso_Fortran_env intrinsic library routines</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ST_DPNAME</span></code></dt>
<dd>Deepcopy Name for shape and policy construct</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC</span></code></dt>
<dd><p class="first">Storage class of a variable.
Indicates storage class/psect containing this variable.
The following values are allowed:</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SC_NONE</span></code></dt>
<dd>No storage class yet defined.  This is used internally until the
storage class of a symbol is determined.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC_LOCAL</span></code></dt>
<dd>local variables not initialized.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC_STATIC</span></code></dt>
<dd>local variables which are initialized or saved.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC_DUMMY</span></code></dt>
<dd>variables which are dummy arguments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC_CMBLK</span></code></dt>
<dd>common block variables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC_EXTERN</span></code></dt>
<dd>external subprograms</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC_BASED</span></code></dt>
<dd>pointer-based variables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC_PRIVATE</span></code></dt>
<dd>private variables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b3</span></code></dt>
<dd>Always an unsigned 8-bit field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b4</span></code></dt>
<dd>Always an unsigned 8-bit field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DTYPE</span></code></dt>
<dd>Data type of symbol.
Relative pointer into the data type area to a record or list of records
which define the type of symbol
(see <em>Data Type Lists</em> of the <em>Auxiliary Data Structures</em> section).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HASHLK</span></code></dt>
<dd>Hash link.  This field is used to link together those symbols
which hash to the same value, and is used only by the
symbol look-up routines.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Field used to create a list of symbols.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCOPE</span></code></dt>
<dd>Symbol scope.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NMPTR</span></code></dt>
<dd>Name pointer.  Relative pointer into the symbol name storage
to the null terminated character string for the symbol name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LINENO</span></code></dt>
<dd>The line number where the symbol was defined.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>Flags per symbol (named f1 through f32).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags2</span></code></dt>
<dd>Flags per symbol (named f33 through f64).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UNAME</span></code></dt>
<dd>Name pointer.  Relative pointer into the symbol name storage
to the null terminated character string for the name of the
symbol as specified in the subprogram.
If mangling of a user name occurs, such as for MODULE-contained subprograms,
the <code class="docutils literal notranslate"><span class="pre">NMPTR</span></code> field will locate the mangled name, and the <code class="docutils literal notranslate"><span class="pre">UNAME</span></code>
field will locate the original name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags3</span></code></dt>
<dd>Flags per symbol (named f65 through f96).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags4</span></code></dt>
<dd>Flags per symbol (named f97 through f128).
Other Fields
<em>.nr II n(iiu</em></dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p><strong>NOTE</strong>
A symbol is entered in the symbol table initially by the scanner.  Its
stype is set to
<code class="docutils literal notranslate"><span class="pre">ST_UNKNOWN.</span></code>
The semantic analysis phase will change the
stype field as it interprets the source code.  The stype field will change
to
<code class="docutils literal notranslate"><span class="pre">ST_IDENT</span></code>
when a type declaration is analyzed.  The stype field is not
immediately set to
<code class="docutils literal notranslate"><span class="pre">ST_VAR</span></code>
on a type declaration because the type
declaration alone is not enough information to conclude that the intended
use of the identifier is as a variable.  For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INTEGER\*2 IMIN
</pre></div>
</div>
<p>In this example the source line could be reaffirming the declaration of
an intrinsic or could actually be defining a local variable called
<code class="docutils literal notranslate"><span class="pre">IMIN.</span></code>
It will not be known until the first reference to
<code class="docutils literal notranslate"><span class="pre">IMIN</span></code>
is analyzed.  At this time the stype of
<code class="docutils literal notranslate"><span class="pre">IMIN</span></code>
is either confirmed as an intrinsic use or as a variable use.  This
would not be a problem if the declaration of
<code class="docutils literal notranslate"><span class="pre">IMIN</span></code>
was an array or if
<code class="docutils literal notranslate"><span class="pre">IMIN</span></code>
was in common or an equivalence.  These cases clearly set the stype of
<code class="docutils literal notranslate"><span class="pre">IMIN</span></code>
to ST_VAR, overriding its intrinsic properties.</p>
</div>
<div class="section" id="fields-by-symbol-type">
<h3>Fields by Symbol Type<a class="headerlink" href="#fields-by-symbol-type" title="Permalink to this headline">¶</a></h3>
<div class="section" id="st-unknown">
<h4>ST_UNKNOWN<a class="headerlink" href="#st-unknown" title="Permalink to this headline">¶</a></h4>
<p><em>OC_NONE</em> unknown</p>
<p>Symbol entered by the scanner but not yet resolved.</p>
<p><em>Flags (By convention, flags declared here are shared for all symbol types)</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_f77</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CCSYM</span></code></dt>
<dd>Compiler created symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Set if the data type of the variable, if it becomes a variable,
has been explicitly declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NODESC</span></code></dt>
<dd>no descriptor exists for this data item.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VISIT</span></code></dt>
<dd>Flag, initialized to zero, to mark a symbol table entry
as
<em>visited</em>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HCCSYM</span></code></dt>
<dd>If set, variable is a temporary created by the compiler (e.g., getcctmp(),
transformer, etc.).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IGNORE</span></code></dt>
<dd>The variable, if this symbol even becomes a variable,
should be ignored by the rest of the compiler,
e.g., if it was deleted by some phase.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYP8</span></code></dt>
<dd>Set if the data type of the variable, if it eventually is a variable,
is implicitly declared as a
<code class="docutils literal notranslate"><span class="pre">real\*8</span></code>
in the presence of the
<code class="docutils literal notranslate"><span class="pre">-r8</span></code>
switch.</dd>
</dl>
<p><em>Flags2</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">VISIT2</span></code></dt>
<dd>Second <em>visit</em> flag, initialized to zero, to mark a symbol table
entry as
<em>visited</em>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>Usually used when
the symbol is renamed (aliased) by a USE, ONLY alias=&gt;oldname
clause, and therefore is visible only by its alias name.
For the parser/semantic analyzer, HIDDEN symbols should be ignored;
for most of the rest of the compiler, HIDDEN symbols should be treated
just like other symbols.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTERNAL</span></code></dt>
<dd>This flag is defined for all symbols.
If set, the symbol was declared in an internal procedure.</dd>
</dl>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ENCLFUNC</span></code></dt>
<dd>Symbol table pointer to the enclosing function, module, or block for this
symbol.  Zero for symbols with
<code class="docutils literal notranslate"><span class="pre">SCOPE</span></code>
equal to 0.</dd>
</dl>
</div>
<div class="section" id="st-label">
<h4>ST_LABEL<a class="headerlink" href="#st-label" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> label</p>
<p>The names of user labels are formed by prepending the label’s decimal
number with ‘.L’; compiler-created labels are prepended ‘%L’.
<em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DEFD</span></code></dt>
<dd>Set by the scanner when label definition has been processed.
(This flag is overloaded with PTRV).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CCSYM</span></code></dt>
<dd>Compiler created label.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSN</span></code></dt>
<dd>If set, label appeared in an <code class="docutils literal notranslate"><span class="pre">ASSIGN</span></code> statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TARGET</span></code></dt>
<dd>If set, the user label is a branch target.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VOL</span></code></dt>
<dd>Set if we want the label to never be deleted.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Flags4</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CONSTRUCTSYM</span></code></dt>
<dd>Variable is a construct entity.  Set for BLOCK and DO CONCURRENT construct
entities; might be useful for variables in other constructs.</dd>
</dl>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">RFCNT</span></code></dt>
<dd>Number of references of this label.
This includes references in
<code class="docutils literal notranslate"><span class="pre">ASSIGN</span></code>
and assigned
<code class="docutils literal notranslate"><span class="pre">GOTO</span></code>
statements, and references of FORMAT statement labels.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>For user-defined labels which are referenced, the Semantic Analyzer
links together these labels using this field.
The head of the list is pointed to by
<code class="docutils literal notranslate"><span class="pre">sem.flabels</span></code>
and the list is terminated by
<code class="docutils literal notranslate"><span class="pre">0</span></code>.
A value of
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
indicates that the label has not been added to the list.
For variable format expressions,
the Semantic Analyzer links together these compiler created labels
using this field.
The head of the list is pointed to by
<code class="docutils literal notranslate"><span class="pre">sem.vf_expr.labels</span></code>
and the list is terminated by
<code class="docutils literal notranslate"><span class="pre">0</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code></dt>
<dd>Byte address relative to beginning of code psect.
Set by Code Scheduler.
For compiler-created labels, this field, if non-zero, locates the
actual label which will appear in the output.
Compiler-created labels are entered into the symbol by the symbol
table utility function,
<code class="docutils literal notranslate"><span class="pre">getlab()</span></code>.
When astout first sees a compiler-created label,
astout will create the
label for the output, ensuring that it doesn’t conflict with user-defined
labels, and set this field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ILIBLK</span></code></dt>
<dd>Number of the ILI block which defines this label.
For the label of a variable format expression,
the Semantic Analyzer uses this field as the index of
the ILMs for the expression;
the field is cleared at the end of semantic processing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FMTPT</span></code></dt>
<dd>Zero if this label is not on a
<code class="docutils literal notranslate"><span class="pre">FORMAT</span></code>
statement, else is a symbol table pointer to compiler created array containing
the encoded form of the
<code class="docutils literal notranslate"><span class="pre">FORMAT</span></code>
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AGOTO</span></code></dt>
<dd>assigned goto index value, from 1 to number of labels appearing in an ASSIGN</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LABSTD</span></code></dt>
<dd>For the STARTLAB or ENDLAB of an ST_BLOCK, the index of the STD with the label.</dd>
</dl>
</div>
<div class="section" id="st-stag">
<h4>ST_STAG<a class="headerlink" href="#st-stag" title="Permalink to this headline">¶</a></h4>
<p><em>OC_STAG</em> struct tag</p>
<p>Structure template name.</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Set if
<code class="docutils literal notranslate"><span class="pre">STRUCTURE-ENDSTRUCTURE</span></code>
statement block has defined this structure tag.
The
<code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code>
statement effects the creation of the tag.  When the matching
<code class="docutils literal notranslate"><span class="pre">ENDSTRUCTURE</span></code>
statement is seen, the tag’s
<code class="docutils literal notranslate"><span class="pre">DCLD</span></code>
is set.
If a
<code class="docutils literal notranslate"><span class="pre">RECORD</span></code>
statement references a symbol without
<code class="docutils literal notranslate"><span class="pre">DCLD</span></code>
set, an error is generated and
<code class="docutils literal notranslate"><span class="pre">DCLD</span></code>
is set to avoid further error messages on subsequent references to this tag.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NEST</span></code></dt>
<dd>Set if a nested structure.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
</div>
<div class="section" id="st-member">
<h4>ST_MEMBER<a class="headerlink" href="#st-member" title="Permalink to this headline">¶</a></h4>
<p><em>OC_MEMBERS</em> member</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">PTRV</span></code></dt>
<dd>If set, variable is a <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> variable.
(This flag is overloaded with DEFD).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code></dt>
<dd>Member’s access attribute is <code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">REF</span></code></dt>
<dd>Set if variable is referenced.  Set by sym_is_refd - for local
variables, indicates that address has been assigned.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FNML</span></code></dt>
<dd>Set if member (a structure) is declared in a field namelist.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOC</span></code></dt>
<dd>Variable (array) is allocatable; its shape is
<em>deferred</em>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DESCARRAY</span></code></dt>
<dd>Set if this is really a section descriptor array
(overloaded with flags <code class="docutils literal notranslate"><span class="pre">RECUR</span></code> and <code class="docutils literal notranslate"><span class="pre">VAX</span></code>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DESCUSED</span></code></dt>
<dd>If set, the symbol’s descriptor is used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOCDESC</span></code></dt>
<dd>The allocatable needs the full descriptor when passed as an argument.</dd>
</dl>
<p><em>Flags2</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NONOVER</span></code></dt>
<dd>This is set when this member is a type bound procedure and it has the
NON_OVERRIDABLE sttribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CLASS</span></code></dt>
<dd>This is set when this member is a type bound procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">POINTER</span></code></dt>
<dd>If set, the variable has the <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOCATTR</span></code></dt>
<dd>This flag is set if and only if the symbol was declared
to have the ALLOCATABLE attribute (unlike the ALLOC flag
which may be set for a number of reasons).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SDSCCONTIG</span></code></dt>
<dd>For descriptors only, this is set if the associated array will always
have a byte-length field equal to the byte-length of the data type of
the associated object.
This is true for descriptors of assumed-shape dummy arrays and
Fortran 90 allocatable objects.
For pointers, in particular, this is NOT true, since they might point to
noncontiguous data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">F90POINTER</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SDSCS1</span></code></dt>
<dd>This is set in an F90 program for the descriptor for an array
with only stride-1 leading dimension;
in this case, the leftmost subscript must be multiplied by the
stride in the section descriptor (set and referenced by lower).
It is also set for assumed-shape dummy arguments if they are guaranteed to
be stride-1 in the leading dimension.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LNRZD</span></code></dt>
<dd>If the variable is an array and this flag is set, the array’s subscripts
must be linearized by the backend (astout).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOPASS</span></code></dt>
<dd>Member is a procedure pointer and has the NOPASS attribute.</dd>
</dl>
<p><em>Flags3</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">USEDEFER</span></code></dt>
<dd>This is set when this component uses a deferred length parameter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEFERLEN</span></code></dt>
<dd>This is set when this component’s type parameter has deferred length</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASZ</span></code></dt>
<dd>This is set when this component’s type parameter has assumed size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TPALLOC</span></code></dt>
<dd>This is set when this component has its ALLOC set due to its use of a length type parameter.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LENPARM</span></code></dt>
<dd>This is set when this component is a length type parameter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">USELEN</span></code></dt>
<dd>This is set when component uses a length type parameter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARMFIN</span></code></dt>
<dd>This is set when this is a type parameter and we’re all done setting its PARMINIT flag as a result of data initialization.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SETKIND</span></code></dt>
<dd>This is set when this member is a kind type parameter and the KIND field represents the user defined value for this parameter. When this is not set, KIND is either 0 (not set), -1 (preset), or represents the type parameter’s position in the declaration list of type parameters.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">USEKIND</span></code></dt>
<dd>This is set when this member uses a kind type parameter. When set, the KIND field equals the offset of the kind parameter.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INITKIND</span></code></dt>
<dd>This is set when this member has a kind parameter in its initialization expression.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FINALIZED</span></code></dt>
<dd>This is set when it is a member that must be finalized. Currently, this is
only set when the member is an allocatable derived type member.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CONTIGATTR</span></code></dt>
<dd>This variable was declared with the CONTIGUOUS attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TLS</span></code></dt>
<dd>This variable is in thread local storage.</dd>
</dl>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">KINDAST</span></code></dt>
<dd>Set to the AST of the kind expression for a derived type component that uses a kind type parameter.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LEN</span></code></dt>
<dd>Set to the type parameter number (e.g., 1 for the first type parameter, 2 for the second type parameter, etc.) that specifies the length of this member. If this is a length type parameter (i.e., LENPARM flag is set), then this field holds the ast of the length expression.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARMINIT</span></code></dt>
<dd>Set for a member that uses a type parameter with a data initialization. The value is the value of the initialize value of the type parameter.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KIND</span></code></dt>
<dd>Set when this member is a kind type parameter for parameterized derived types. The value is the constant integer value for this parameter.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FINAL</span></code></dt>
<dd>If &gt; 0, this member is a final subroutine. The value is the rank of the
dummy argument + 1 (e.g., 1 is for a scalar, 2 is for a rank 1
array, 3 is for a rank 2 array, etc.). FINAL can also have a value
of -1. In this case, FINAL indicates that a forward reference to the final
subroutine has been seen, but we have not yet processed a final subroutine
interface or function definition. In other words, we do not yet know the rank
of the dummy argument so we set FINAL initially to -1.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARENT</span></code></dt>
<dd>Set to sptr of the ST_MEMBER when this member is a derived type’s parent member.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VTABLE</span></code></dt>
<dd>When this member is a type bound procedure, this field will hold the sptr of the ST_PROC implementation.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFACE</span></code></dt>
<dd>When this member is a type bound procedure, this field will hold the sptr of the interface-name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BIND</span></code></dt>
<dd>Contains the sptr of the binding-name proc for this type bound procedure (which stores additional information for this type bound procedure).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Members of each struct or union type are linked together using
this field.  The end of the list has a value of
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code></dt>
<dd>Byte offset from the beginning of the struct (its parent) for this member.
For a
<code class="docutils literal notranslate"><span class="pre">DERIVED</span></code>
type,
the compiler creates a ST_MEMBER whose
<code class="docutils literal notranslate"><span class="pre">DTYPE</span></code>
field will locate an array of
<code class="docutils literal notranslate"><span class="pre">TY_DERIVED</span></code>
or
<code class="docutils literal notranslate"><span class="pre">TY_DERIVED</span></code>.
For a
<code class="docutils literal notranslate"><span class="pre">UNION</span></code>,
the compiler creates a ST_MEMBER whose
<code class="docutils literal notranslate"><span class="pre">DTYPE</span></code>
field will locate a data type record of type
<code class="docutils literal notranslate"><span class="pre">TY_UNION</span></code>.
For a
<code class="docutils literal notranslate"><span class="pre">MAP</span></code>,
the compiler creates a ST_MEMBER whose
<code class="docutils literal notranslate"><span class="pre">DTYPE</span></code>
field will locate a data type record of type
<code class="docutils literal notranslate"><span class="pre">TY_STRUCT</span></code>.
The members of a
<code class="docutils literal notranslate"><span class="pre">UNION</span></code>
are the compiler-created structures representing the
<code class="docutils literal notranslate"><span class="pre">MAP``s.</span>
<span class="pre">The</span> <span class="pre">members</span> <span class="pre">of</span> <span class="pre">a</span>
<span class="pre">``MAP</span></code>
are the variables which appear in the
<code class="docutils literal notranslate"><span class="pre">MAP</span></code>
body.
Since the offset of the structure representing a
<code class="docutils literal notranslate"><span class="pre">MAP</span></code>
is zero,
the offsets of the members in the map are actually relative
to the beginning of the
<code class="docutils literal notranslate"><span class="pre">MAP</span></code>’s
<code class="docutils literal notranslate"><span class="pre">UNION</span></code>
(note the first member of each
<code class="docutils literal notranslate"><span class="pre">MAP</span></code>
has an offset of zero).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLNK</span></code></dt>
<dd>Miscellaneous link field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTROFF</span></code></dt>
<dd>If set, this field is the sptr of the variable representing the offset
of this symbol from a known base;
the sum of the base and the offset is the address of this symbol.
This field is only used for certain cases of allocatable arrays (e.g.,
<code class="docutils literal notranslate"><span class="pre">DYNAMIC</span></code>
arrays
and their descriptors).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MIDNUM</span></code></dt>
<dd>Not valid for f77 derived type implementation.
If set, this field is the sptr of the variable’s pointer variable.
This occurs if the variable’s storage class is
<code class="docutils literal notranslate"><span class="pre">SC_BASED</span></code>,
or if the variable has the <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DESCR</span></code></dt>
<dd>If an array is distributed, this field is a pointer to the aligment
symbol (see
<code class="docutils literal notranslate"><span class="pre">ST_ARRDSC</span></code>
symbol).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SDSC</span></code></dt>
<dd>If the symbol is an array and has the <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> attribute, this field
locates its section descriptor (TBD).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VARIANT</span></code></dt>
<dd>Field used by the Semantic Analyzer to link together, in reverse order,
the members of a
<code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code>
which appear at the same naming (scope) level.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PSMEM</span></code></dt>
<dd>This field exists for compatibility with PGC.
In Fortran, it normally would point to this symbol
table entry.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENCLDTYPE</span></code></dt>
<dd>This field points to the datatype of which this is a member.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BYTELEN</span></code></dt>
<dd>For descriptors (DESCARRAY is set) only; if
the SDSCCONTIG flag is set, then this field contains
the byte length of the associated object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PASS</span></code></dt>
<dd>If CLASS is not set, then Member is a procedure pointer and
this field is the sptr of the passed-object dummy argument. Otherwise, this
field holds the sptr of the binding name (an ST_PROC) for the type bound
procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ETLS</span></code></dt>
<dd>Extended TLS levels</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSOC_PTR</span></code></dt>
<dd>When set, this is the sptr of a pointer that is initialized with this member.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTR_TARGET</span></code></dt>
<dd>When set, this symbol is a place holder for a pointer target. This field holds the sptr of the original pointer target.</dd>
</dl>
</div>
<div class="section" id="st-ident-st-var-st-array-st-struct-st-union-st-descriptor">
<h4>ST_IDENT, ST_VAR, ST_ARRAY, ST_STRUCT, ST_UNION, ST_DESCRIPTOR<a class="headerlink" href="#st-ident-st-var-st-array-st-struct-st-union-st-descriptor" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> ident variable array structure union static descriptor</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">IS_PROC_DESCR</span></code></dt>
<dd>Set if this is a descriptor associated with a procedure dummy argument or a
procedure pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LENPH</span></code></dt>
<dd>This symbol is used as a place holder for a length type parameter name in
an array bounds expression. Eventually this name is replaced with the
actual length type parameter which is an ST_MEMBER in the array bounds
expression (i.e., it’s replaced with a parent%member expression where
parent is an instance of the parameterized derived type (PDT) and member is
the length type parameter component). A place holder is required
because the array bounds are built up before the full PDT is defined.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Set if the data type of the variable has been explicitly declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYP8</span></code></dt>
<dd>Set if the data type of the variable is implicitly declared as a
<code class="docutils literal notranslate"><span class="pre">real\*8</span></code>
in the presence of the
<code class="docutils literal notranslate"><span class="pre">-r8</span></code>
switch.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RVALLOC</span></code></dt>
<dd>This flag is set when this variable is a pointer for an allocatable return
variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DINIT</span></code></dt>
<dd>Set if the variable has been data initialized.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CCSYM</span></code></dt>
<dd>Indicates that this variable is a compiler created variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SAVE</span></code></dt>
<dd>Set if the variable is referenced in a
<code class="docutils literal notranslate"><span class="pre">SAVE</span></code>
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">REF</span></code></dt>
<dd>Set if variable is referenced.  Set by sym_is_refd - for local
variables, indicates that address has been assigned.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDRTKN</span></code></dt>
<dd>Variable has appeared as a subprogram argument or in a %LOC.
Set by Expander.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASUMSZ</span></code></dt>
<dd>Assumed size array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADJARR</span></code></dt>
<dd>Adjustable array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_f12</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOCATTR</span></code></dt>
<dd>This flag is set if and only if the symbol was declared
to have the ALLOCATABLE attribute (unlike the ALLOC flag
which may be set for a number of reasons).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOCDESC</span></code></dt>
<dd>The allocatable (or pointer) needs the full descriptor when passed as an argument.
(This flag is overloaded with PURE).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DESCARRAY</span></code></dt>
<dd>Set if this is really a section descriptor array
(overloaded with flags <code class="docutils literal notranslate"><span class="pre">RECUR</span></code> and <code class="docutils literal notranslate"><span class="pre">VAX</span></code>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSUMRANK</span></code></dt>
<dd>Assumed-rank array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSUMSHP</span></code></dt>
<dd>Assumed-shape array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AFTENT</span></code></dt>
<dd>Set if an adjustable array and its declaration occurs after an
ENTRY statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EQV</span></code></dt>
<dd>Set for a variable which was added to a common block
due to an equivalence.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VOL</span></code></dt>
<dd>Variable appeared in a
<code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code>
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOC</span></code></dt>
<dd>Variable (array) is allocatable; its shape is
<em>deferred</em>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARG</span></code></dt>
<dd>Variable appears as an argument to a function or subroutine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSN</span></code></dt>
<dd>Variable is assigned a value explicitly (left-hand side of an
assignment statement or in an i/o statement) or
implicitly (namelist I/O item).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SEQ</span></code></dt>
<dd>Sequential variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DOVAR</span></code></dt>
<dd>when set, the variable (ST_VAR) is a do loop index variable of
a do loop currently being processed by semant (used only by semant).
Overloaded with FORALLNDX, which
is set TEMPORARILY for FORALL index variables
while processing the statements of a program sequentially;
if set, the statement being processed is within a FORALL or block FORALL
where this variable is a FORALL index.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NODESC</span></code></dt>
<dd>no descriptor exists for this data item.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code></dt>
<dd>Variable’s access attribute is <code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NML</span></code></dt>
<dd>Variable is a member of a namelist group.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DESCUSED</span></code></dt>
<dd>If set, the symbol’s descriptor is used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">OPTARG</span></code></dt>
<dd>If set, variable is an
<code class="docutils literal notranslate"><span class="pre">OPTIONAL</span></code>
dummy argument.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HCCSYM</span></code></dt>
<dd>If set, variable is a temporary created by the compiler (e.g., getcctmp(),
transformer, etc.).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VCSYM</span></code></dt>
<dd>If set, variable is a vectorizer-created temporary.
(This flag is overloaded with EXPST).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTRV</span></code></dt>
<dd>If set, variable is a <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> variable.
(This flag is overloaded with DEFD).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></dt>
<dd>If set, the variable is a CUDA <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PINNED</span></code></dt>
<dd>If set, the variable is a CUDA <code class="docutils literal notranslate"><span class="pre">PINNED</span></code> variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INITIALIZER</span></code></dt>
<dd>If set, the variable is a compiler-generated instance of a
derived type to be used as the right-hand side of an assignment
that initializes arbitrary storage, e.g. an INTENT(OUT) dummy argument.</dd>
</dl>
<p><em>Flags2</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MDALLOC</span></code></dt>
<dd>If set, the variable is an allocatable array which was declared
in the specification part of a module; the allocatable array is
<em>global</em>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SHARED</span></code></dt>
<dd>If set, the variable is a CUDA <code class="docutils literal notranslate"><span class="pre">SHARED</span></code> variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">POINTER</span></code></dt>
<dd>If set, the variable has the <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TARGET</span></code></dt>
<dd>If set, the variable has the <code class="docutils literal notranslate"><span class="pre">TARGET</span></code> attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LNRZD</span></code></dt>
<dd>If the variable is an array and this flag is set, the array’s subscripts
must be linearized by the backend (astout).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOMDCOM</span></code></dt>
<dd>If set, the variable is not added to the common block created for the
variables in the specification part of a module.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CONSTANT</span></code></dt>
<dd>If set, the variable is a CUDA <code class="docutils literal notranslate"><span class="pre">CONSTANT</span></code> variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTRRHS</span></code></dt>
<dd>If set, variable occurred as the target of a pointer assignment.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The variable is renamed (aliased) by a USE, ONLY alias=&gt;oldname
clause, and therefore is visible only by its alias name.
For the parser/semantic analyzer, HIDDEN variables should be ignored;
for most of the rest of the compiler, HIDDEN variables should be treated
just like other variables.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASYNC</span></code></dt>
<dd>If set, the F2003 dummy parameter has the ASYNCHRONOUS attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PASSBYVAL</span></code></dt>
<dd>If set, this f90 dummy parameter or subroutine(parameter
default) is pass by value: cDEC$ ATTRIBUTES VALUE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PASSBYREF</span></code></dt>
<dd>If set, this f90 dummy parameter or subroutine(parameter
default) is pass by reference: cDEC$ ATTRIBUTES REFERENCE
This is required because string paramters may or may not have a
length, depending on PASSBYREF set on the variable or subroutine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CFUNC</span></code></dt>
<dd>If set, function/subroutine’s name linkage name follows C conventions</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSUMLEN</span></code></dt>
<dd>If set, the character variable is an assumed-length argument.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADJLEN</span></code></dt>
<dd>If set, the character variable has adjustable length.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EARLYSPEC</span></code></dt>
<dd>Set if the variable is compiler generated variable used to hold
the value of an array dimension or string length and the
assignment to set its value was done early (in bblock.c).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAM</span></code></dt>
<dd>If set, this (derived type or array) variable was declared as a PARAMETER,
and its constant value is available as an A_INIT tree via the
PARAMVAL field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESULT</span></code></dt>
<dd>Set if this is a function result variable,
either created by default with the same name as the function,
or added with the name given in the ‘RESULT(name)’ clause of the FUNCTION
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SDSCCONTIG</span></code></dt>
<dd>For ST_DESCRIPTOR only, this is set if the associated array will always
have a byte-length field equal to the byte-length of the data type of
the associated object.
This is true for descriptors of assumed-shape dummy arrays and
Fortran 90 allocatable objects.
For pointers, in particular, this is NOT true, since they might point to
noncontiguous data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TQALN</span></code></dt>
<dd>For the pointer variables created for F90 pointers, this flag is set if the
compiler can determine that the target is always quad-aligned.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">THREAD</span></code></dt>
<dd>If set, the variable is a member of a common block and the common block
is <code class="docutils literal notranslate"><span class="pre">THREADPRIVATE</span></code> (overloaded with L3F); see <code class="docutils literal notranslate"><span class="pre">ST_CMBLK</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">F90POINTER</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_f62</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">QALN</span></code></dt>
<dd>If set, the variable is aligned on a cache-line boundary; also the flag
applies to common blocks.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SDSCS1</span></code></dt>
<dd>This is set in an F90 program for the descriptor for an array
with only stride-1 leading dimension;
in this case, the leftmost subscript must be multiplied by the
stride in the section descriptor (set and referenced by lower).
It is also set for assumed-shape dummy arguments if they are guaranteed to
be stride-1 in the leading dimension.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCFXD</span></code></dt>
<dd>Storage class has been set by AUTOMATIC or STATIC; it cannot be
changed by SAVE, -Mrecursive, etc.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTRSTORE</span></code></dt>
<dd>If set, the object (for now a structure), contains a pointer component
that’s stored.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTRSAFE</span></code></dt>
<dd>This variable is pointer-safe, meaning no pointers ever target it.
This is computed in the front end and passed to the back end.</dd>
</dl>
<p><em>Flags3</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">PROTECTED</span></code></dt>
<dd>If set, the variable has the <code class="docutils literal notranslate"><span class="pre">PROTECTED</span></code> attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOALLOOPT</span></code></dt>
<dd>If set, the variable cannot be optimized in allocate statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">REFLECTED</span></code></dt>
<dd>This variable is a dummy argument which is reflected on the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MIRRORED</span></code></dt>
<dd>This variable is mirrored on the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICECOPY</span></code></dt>
<dd>This variable is a pointer to a device copy of a host variable.
This might come from the reflected clause, mirror clause, copy clause, local clause,</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICESD</span></code></dt>
<dd>This variable is a pointer to a device copy of a section descriptor.
It is reached from a DEVICECOPY variable using the SDSC field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TEXTURE</span></code></dt>
<dd>If set, the variable is a CUDA <code class="docutils literal notranslate"><span class="pre">TEXTURE</span></code> variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESHAPED</span></code></dt>
<dd>If set, the variable (temp) is SC_BASED and represents a different
shape of an array expression.
The variable can be created for an optimized case of the RESHAPE intrinsic
where the result is expressed as the address of the source argument with a
different shape.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TASK</span></code></dt>
<dd>Set if this private variable was declared within the scope of an OMP TASK</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOEXTENT</span></code></dt>
<dd>This variable is a compiler-created allocatable array temp whose
extent temp variables, as presented in the array <code class="docutils literal notranslate"><span class="pre">DTYPE</span></code> record,
are not assigned values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DATACONST</span></code></dt>
<dd>Set if this variable is data-initialized (its <code class="docutils literal notranslate"><span class="pre">DINIT</span></code> flag is
also set) and can be presented as a  <code class="docutils literal notranslate"><span class="pre">PARAMETER</span></code>.
The front-end has replaced all of the variable’s uses with its
dinit value and the backend can elide the dinit.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TLS</span></code></dt>
<dd>This variable is in thread local storage.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCCREATE</span></code></dt>
<dd>This variable was in a ‘declare create’ clause for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCRESIDENT</span></code></dt>
<dd>This variable was in a ‘declare device_resident’ clause for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCLINK</span></code></dt>
<dd>This variable was in a ‘declare link’ clause for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CONTIGATTR</span></code></dt>
<dd>This variable was declared with the CONTIGUOUS attribute.</dd>
</dl>
<p><em>Flags4</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MANAGED</span></code></dt>
<dd>If set, the variable is a CUDA <code class="docutils literal notranslate"><span class="pre">MANAGED</span></code> variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCCOPYIN</span></code></dt>
<dd>This variable was in a ‘declare copyin’ clause for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTERNREF</span></code></dt>
<dd>Set if the uplevel symbol is referenced in internal subroutine.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MONOMORPHIC</span></code></dt>
<dd>This variable is a compiler-created temporary for a TYPE IS
statement in a SELECT TYPE construct, and it should
be treated as monomorphic for error-checking purposes even though
its CLASS flag is also set to elicit correct descriptor creation.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOT_IN_USEONLY</span></code></dt>
<dd>This flag is set for variables that are not on the “USE ONLY” list.</dd>
</dl>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DSCAST</span></code></dt>
<dd>When this ST_VAR has a descriptor that’s a member of a derived type (e.g., this is an associate name in a select type statement), set this field to the ast of the fully qualified descriptor expression (e.g., parent%member).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UFIO</span></code></dt>
<dd>This is set on a derived type tag when the derived type has a user defined I/O function associated with it. The value is a bitmask, 1 =&gt; READ(FORMATTED),
2=&gt; READ(UNFORMATTED), 4=&gt; WRITE(FORMATTED), 8=&gt; WRITE(UNFORMATTED)</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">DTYPE</span></code></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>For common block variables, this field is used to link together
all of the elements of the common block (including variables
added to the common block by
<code class="docutils literal notranslate"><span class="pre">EQUIVALENCE</span></code>
statements).
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
is used to mark the end of the list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NEWARG</span></code></dt>
<dd><p class="first">For dummy variables,
this field is the sptr of a symbol which will replace the
dummy argument in the output.</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NEWDSC</span> <span class="pre">(ADDRESS)</span></code></dt>
<dd>For dummy variables,
this field is the sptr of the section descriptor for the argument.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code></dt>
<dd><p class="first">Address assigned to the variable.</p>
<ul class="simple">
<li>For nondummy variables,
it is the byte address, beginning at zero,
relative to the psect containing the variable.
For common block elements, this value is computed at the end
of semantic analysis, and for local variables it is
computed during Assembler initialization for just those
variables which were found to be referenced by the Code Scheduler.
(local variables will actually have addresses assigned during Scheduling? ).</li>
<li>Those local variables which are determined to be referenced by the
Code Scheduler are linked into a single list using this field.
The list head is pointed to by
<code class="docutils literal notranslate"><span class="pre">gbl.locals</span></code>.</li>
</ul>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ALTNAME</span></code></dt>
<dd>Set if the common block has DVF’s
also set for common blocks, module variables, subroutines , functions
declares BIND(c,name=’foo’) C visible</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MIDNUM</span></code></dt>
<dd>If set, this field is the sptr of the variable’s pointer variable.
This occurs if the variable’s storage class is
<code class="docutils literal notranslate"><span class="pre">SC_BASED</span></code>,
or if the variable has the <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCPTR</span></code></dt>
<dd><p class="first">Pointer to storage overlap chain (see auxiliary data structures)
for variables involved in equivalences.</p>
<ul class="simple">
<li>Also, during semantic analysis is used to mark
currently active DO-control variables.</li>
</ul>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">BYTELEN</span></code></dt>
<dd>For ST_DESCRIPTOR only; if
the SDSCCONTIG flag is set, then this field contains
the byte length of the associated object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DESCR</span></code></dt>
<dd>If an array is distributed, this field is a pointer to the aligment
symbol (see
<code class="docutils literal notranslate"><span class="pre">ST_ARRDSC</span></code>
symbol).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AUTOBJ</span></code></dt>
<dd><p class="first">If the variable is an
automatic data object (a local array whose bounds are not
constants or a character object whose length is not constant),
this field is a non-zero value.
This field is used to link together automatic data
objects.
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
marks the end of the list.
The head of the list is stored in
<code class="docutils literal notranslate"><span class="pre">gbl.autobj</span></code>.</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ARGINFO</span> <span class="pre">(AUTOBJ)</span></code></dt>
<dd>Used by the semantic analyzer if the variable is a dummy argument to
a statement function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMBLK</span></code></dt>
<dd><p class="first">If the variable belongs to a common block, this field locates its
corresponding
<code class="docutils literal notranslate"><span class="pre">ST_CMBLK</span></code>
symbol (set by the Semantic Analyzer).</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">INTENT</span> <span class="pre">(b3)</span></code></dt>
<dd>If the variable is a dummy argument, this field indicates the
<em>intent</em> of the argument in the subprogram:
<code class="docutils literal notranslate"><span class="pre">INTENT_IN</span></code>, <code class="docutils literal notranslate"><span class="pre">INTENT_OUT</span></code>, <code class="docutils literal notranslate"><span class="pre">INTENT_INOUT</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_w18</span></code></dt>
<dd><p class="first">reserved</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">PDALN</span> <span class="pre">(b4)</span></code></dt>
<dd>If the value, v,  of this field is nonzero,
used to pad and align the object with respect to 2^v bytes.
For example, if v is 3, the size of the object is
a multiple of 8 (2^3) bytes and will be aligned
on an 8-byte boundary.
This field uses the least signficant 4 bits of b4.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLNK</span></code></dt>
<dd>Miscellaneous link field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IGNORE_TKR</span></code></dt>
<dd>If the variable is a dummy argument, this field is a bitmask indicating
that any combination of type, kind, and rank can be ignored when
checking argument association including during generic resolution.
The possible bit values in the mask are
<code class="docutils literal notranslate"><span class="pre">INGORE_T</span></code>, <code class="docutils literal notranslate"><span class="pre">INGORE_K</span></code>, <code class="docutils literal notranslate"><span class="pre">INGORE_R</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CVLEN</span></code></dt>
<dd>If the symbol is an adjustable length character, this field is the sptr
of the variable containing its length.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SDSC</span></code></dt>
<dd>If the symbol is an array and has the <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> attribute, this field
locates its section descriptor (TBD).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADJSTRLK</span></code></dt>
<dd>Field is used to link together all adjustable length strings.
List head is pointed to by
<code class="docutils literal notranslate"><span class="pre">gbl.p_adjstr</span></code>
and
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
marks the end of the list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAMVAL</span></code></dt>
<dd>For derived type or array variables, if the PARAM bit is set, this field
holds an AST pointer to an A_INIT tree of values for the variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTROFF</span></code></dt>
<dd>If set, this field is the sptr of the variable representing the offset
of this symbol from a known base;
the sum of the base and the offset is the address of this symbol.
This field is only used for certain cases of allocatable arrays (e.g.,
<code class="docutils literal notranslate"><span class="pre">DYNAMIC</span></code>
arrays
and their descriptors).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NMCNST</span></code></dt>
<dd>If the variable represents the compiler-created temporary for
a named array or structure constant, this field is the sptr
of the corresponding ST_PARAM.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARENT</span></code></dt>
<dd>Contains sptr of parent of the type extension (ST_TYPEDEF). To mark an ST_MEMBER that represents the type’s parent, we will set it to the sptr of the ST_MEMBER. When this is an ST_DESCRIPTOR used with a derived type’s final subroutines, it
holds the DTYPE of the defining derived type.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVCOPY</span></code></dt>
<dd>For a variable with the DEVICECOPY flag set, this field will tell which host
variable or array this variable is a device copy of.
For a host variable (DEVICECOPY flag not set), this field will give the
symbol number of the device copy currently being used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TEXREF</span></code></dt>
<dd>If the symbol is an array and has the <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> and <code class="docutils literal notranslate"><span class="pre">TEXTURE</span></code>
attributes, this field contains the symbol number of its texture reference.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ETLS</span></code></dt>
<dd>Extended TLS levels</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSOC_PTR</span></code></dt>
<dd>When set, this is the sptr of a pointer that is initialized with this variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTR_TARGET</span></code></dt>
<dd>When set, this symbol is a place holder for a pointer target. This field holds the sptr of the original pointer target.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="st-cmblk">
<h4>ST_CMBLK<a class="headerlink" href="#st-cmblk" title="Permalink to this headline">¶</a></h4>
<p><em>OC_CMBLK</em> common block</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DINIT</span></code></dt>
<dd>Common block has been data initialized.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SAVE</span></code></dt>
<dd>Common block referenced in a
<code class="docutils literal notranslate"><span class="pre">SAVE</span></code>
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BLANKC</span></code></dt>
<dd>this common block is blank common.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VOL</span></code></dt>
<dd>Common block appeared in a
<code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code>
statement.</dd>
</dl>
<p><em>Flags2</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MODCMN</span></code></dt>
<dd>If set, common block is a compiler-created module common block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">THREAD</span></code></dt>
<dd>If set, common block is <code class="docutils literal notranslate"><span class="pre">THREADPRIVATE</span></code> (overloaded with L3F)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_f62</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">STDCALL</span></code></dt>
<dd>Set if this common block has DVF’s
<code class="docutils literal notranslate"><span class="pre">STDCALL</span></code>
attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The common block is hidden.</dd>
</dl>
<p><em>Flags3</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ACCCREATE</span></code></dt>
<dd>This common block was in a ‘declare create’ clause for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCRESIDENT</span></code></dt>
<dd>This common block was in a ‘declare device_resident’ clause for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCLINK</span></code></dt>
<dd>This common block was in a ‘declare link’ clause for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCCOPYIN</span></code></dt>
<dd>This common block was in a ‘declare copyin’ clause for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TLS</span></code></dt>
<dd>This common block is in thread local storage.</dd>
</dl>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Field is used to link together all common blocks.
List head is pointed to by
<code class="docutils literal notranslate"><span class="pre">gbl.cmblks</span></code>
and
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
marks the end of the list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NMPTR</span></code></dt>
<dd><p class="first">For blank common, this points to the compiler created name, “.blank.”.</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">PDALN</span> <span class="pre">(b4)</span></code></dt>
<dd>If nonzero, the value indicates the method used to perform
additional padding of arrays in module commons.  For example, 1 says
the arrays with PDALN set are padded with a multiple of 64 bytes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SIZE</span></code></dt>
<dd>Size in bytes of common block.
Computed at the end of semantic processing and possibly
updated by equivalence processing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMEMF</span></code></dt>
<dd>Pointer to first element of linked list of common block members.
A value of zero indicates that the common block has not yet been defined.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMEML</span></code></dt>
<dd>Pointer to last element of linked list of common block members.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMBLK</span></code></dt>
<dd>Use by Semantic Analyzer during equivalence processing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARRAY</span></code></dt>
<dd>After common blocks are rewritten, if this is a mapped common block, then
the ARRAY field points to the original array symbol (which is now the only
element in the new common block).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_w18</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALTNAME</span></code></dt>
<dd>Set if the common block has DVF’s
also set for common blocks, module variables, subroutines , functions
declares BIND(c,name=’foo’) C visible
<code class="docutils literal notranslate"><span class="pre">ALIAS</span></code>
attribute.
If set, this field is a
symbol table pointer to character constant representing
the alternate name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ETLS</span></code></dt>
<dd>Extended TLS levels</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="st-nml">
<h4>ST_NML<a class="headerlink" href="#st-nml" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> namelist</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">REF</span></code></dt>
<dd>The namelist group has been referenced in a
<code class="docutils literal notranslate"><span class="pre">READ</span></code>
or
<code class="docutils literal notranslate"><span class="pre">WRITE</span></code>
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Field is used to link together all namelist groups.
List head is pointed to by
<code class="docutils literal notranslate"><span class="pre">sem.nml</span></code>
and
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
marks the end of the list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code></dt>
<dd>Locates the
<code class="docutils literal notranslate"><span class="pre">ST_PLIST</span></code>
symbol which represents the namelist descriptor for this namelist
group; if the namelist I/O using this group name occurs,
the plist will be data initialized.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMEMF</span></code></dt>
<dd>Relative pointer into the namelist auxiliary data structure to
the first element of the linked list of entities belonging to this
name list group.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMEML</span></code></dt>
<dd>Relative pointer into the namelist auxiliary data structure to
the last element of the linked list of entities belonging to this
name list group.</dd>
</dl>
</div>
<div class="section" id="st-entry">
<h4>ST_ENTRY<a class="headerlink" href="#st-entry" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> entry</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">IS_INTERFACE</span></code></dt>
<dd>Set if the entry symbol is in an interface block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Set if currently processing a function subprogram and the
data type of this entry has been explicitly declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYP8</span></code></dt>
<dd>Set if the data type of the function is implicitly declared as a
<code class="docutils literal notranslate"><span class="pre">real\*8</span></code>
in the presence of the
<code class="docutils literal notranslate"><span class="pre">-r8</span></code>
switch.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADJARR</span></code></dt>
<dd>Set if entry has one or more adjustable array arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AFTENT</span></code></dt>
<dd>Set if entry has adjustable array arguments which are declared after
an ENTRY statement. This flag is always set for an entry which appeared
in an ENTRY statement (and it has adjustable array arguments).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSUMSHP</span></code></dt>
<dd>Set if entry has one or more assumed-shape array arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSUMRANK</span></code></dt>
<dd>Set if entry has one or more assumed-rank array arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IMPURE</span></code></dt>
<dd>Subprogram has the IMPURE attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PURE</span></code></dt>
<dd>This subprogram is a <em>pure</em> subroutine/function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code></dt>
<dd>This external is a <em>elemental</em> subroutine/function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FUNC</span></code></dt>
<dd>This external is a function subprogram.
This flag is used for semantic error checking,
object file LSD blocks (potentially), and the
Cross Reference Listing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYPD</span></code></dt>
<dd>Set if subroutine/function appeared in an external statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RECUR</span></code></dt>
<dd>This subprogram is <em>recursive</em> (overloaded with flags <code class="docutils literal notranslate"><span class="pre">VAX</span></code> and
<code class="docutils literal notranslate"><span class="pre">DESCARRAY</span></code>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ABSTRACT</span></code></dt>
<dd>Set if subroutine/function is an abstract interface.</dd>
</dl>
<p><em>Flags2</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">PTRARG</span></code></dt>
<dd>Set if entry has one or more pointer arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESULT</span></code></dt>
<dd>Set if a ‘RESULT(name)’ clause was specified on the FUNCTION line.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INMODULE</span></code></dt>
<dd>Set if this is a module procedure.
This flag also applies to ST_PROCs and any variable which is a pointer to
a function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">STDCALL</span></code></dt>
<dd>Set if this ST_ENTRY has DVF’s
<code class="docutils literal notranslate"><span class="pre">STDCALL</span></code>
attribute.
If this flag is set, then
<code class="docutils literal notranslate"><span class="pre">MSCALL</span></code>
is also set.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CREF</span></code></dt>
<dd>Set if this procedure is defined to use the MS cref calling sequence.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOMIXEDSTRLEN</span></code></dt>
<dd>Set if the character length arguments are to be passed after all of the
the other arguments (i.e., unix-style). If this flag is set, then
either
<code class="docutils literal notranslate"><span class="pre">MSCALL</span></code>
or
<code class="docutils literal notranslate"><span class="pre">CREF</span></code>
is also set.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DECORATE</span></code></dt>
<dd>Set if this ST_ENTRY has DVF’s
<code class="docutils literal notranslate"><span class="pre">DECORATE</span></code>
attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CFUNC</span></code></dt>
<dd>If set, function/subroutine’s name linkage name follows C conventions
(i.e., underscore is not appended to name).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_f62</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">US</span></code></dt>
<dd>reserved</dd>
</dl>
<p><em>Flags3</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DFLT</span></code></dt>
<dd>This function returns a type of default kind.</dd>
</dl>
<p><em>Flags4</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MVDESC</span></code></dt>
<dd>When an array-valued function requires a descriptor for its result, the
descriptor is normally the first descriptor added to the argument list;
if
<code class="docutils literal notranslate"><span class="pre">MVDESC</span></code>
is set, the descriptor is the last descriptor added to the list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTERFACE</span></code></dt>
<dd>Set if the symbol is in the interface.  We need interface symbols for llvm target.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTERNREF</span></code></dt>
<dd>Set if the uplevel symbol is referenced in internal subroutine.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARET</span></code></dt>
<dd>Subroutine contains alternate return arguments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARREF</span></code></dt>
<dd>Set if variable is shared in OpenMP parallel region.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVCOMP</span></code></dt>
<dd>Set if this routine was compiled with the -acc or -ta flag, meaning the
compiler was device-aware.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SEPARATEMP</span></code></dt>
<dd>MODULE SUBROUTINE, MODULE FUNCTION for a separate module procedure.</dd>
</dl>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Used to link together all entry symbols as their definitions
are processed.  List head pointed to by
<code class="docutils literal notranslate"><span class="pre">gbl.entries</span></code>.
The main entry is always the first in the list (also located
by <code class="docutils literal notranslate"><span class="pre">gbl.currsub</span></code>; the
order of the remaining entries is undefined.
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
is used to mark the end of the list.  The list is
empty if the current subprogram is a block data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENTSTD</span></code></dt>
<dd>Pointer to the STD after which ASTs representing the prologue for
the routine or block entry are added.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENTNUM</span></code></dt>
<dd>Integer value (zero based) which can be checked at run-time to determine
that the subprogram was entered through this entry.
This field may be used to denote the order in which an entry is processed;
this value may be used
to index a table which contains information for all of the entries
(such as target-specific information of an entry’s arguments).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_w18</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPDSC</span></code></dt>
<dd>Pointer to the dummy parameter descriptor for this entry (see
auxiliary data structures described below).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAMCT</span></code></dt>
<dd>Number of dummy parameters for this entry point.
This count also includes any implicit arguments required for the entry.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GSAME</span></code></dt>
<dd>Pointer to the generic with the same name as this subprogram.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">BIHNUM</span></code></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SLNK</span></code></dt>
<dd>Miscellaneous link field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FUNCLINE</span></code></dt>
<dd>Source line number of first line of subprogram definition.
The
<code class="docutils literal notranslate"><span class="pre">FG</span></code>
index
of the entry; used only by the Optimizer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FVAL</span></code></dt>
<dd>Prior to the cross reference phase, this field locates the compiler
created symbol which represents the return value if this entry is
a function.  Depending on the type and target, this symbol will
either have storage class local or dummy.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDLINE</span></code></dt>
<dd>Source line number of the last line of the subprogram definition.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALTNAME</span></code></dt>
<dd>Set if the ST_ENTRY has DVF’s
also set for common blocks, module variables, subroutines , functions
declares BIND(c,name=’foo’) C visible
<code class="docutils literal notranslate"><span class="pre">ALIAS</span></code>
attribute.
If set, this field is a
symbol table pointer to character constant representing
the alternate name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCROUT</span></code></dt>
<dd>Contains a pointer to the information from the ‘acc routine’ directive
for this symbol.</dd>
</dl>
</div>
<div class="section" id="st-proc">
<h4>ST_PROC<a class="headerlink" href="#st-proc" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> subroutine</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">IS_PROC_PTR_IFACE</span></code></dt>
<dd>This is set when this procedure symbol is used as an interface for a procedure
pointer. IS_INTERFACE should also be set in this case.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SEPARATEMP</span></code></dt>
<dd>MODULE SUBROUTINE, MODULE FUNCTION for a separate module procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TBP_BOUND_TO_SMP</span></code></dt>
<dd>At least one type bound procedure is bound to this separate module procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOT_IN_USEONLY</span></code></dt>
<dd>This flag is set for variables that are not on the “USE ONLY” list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IS_INTERFACE</span></code></dt>
<dd>Set if the procedure symbol is in an interface block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IS_PROC_DUMMY</span></code></dt>
<dd>This flag is set if this ST_PROC is used as a procedure dummy argument.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CLASS</span></code></dt>
<dd>This is set when this ST_PROC is a type bound procedure (i.e., a binding name)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSTRUCTRET</span></code></dt>
<dd>The first arg is a hidden argument that is the address of the structure return area.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Data type of this (function) subprogram has been explicitly declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYP8</span></code></dt>
<dd>Set if the data type of the function is implicitly declared as a
<code class="docutils literal notranslate"><span class="pre">real\*8</span></code>
in the presence of the
<code class="docutils literal notranslate"><span class="pre">-r8</span></code>
switch.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CCSYM</span></code></dt>
<dd>Set for compiler created functions (support routines) except for those
which are created for the procedural forms of the intrinsics.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code></dt>
<dd>Subprogram’s access attribute is <code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FUNC</span></code></dt>
<dd>This external is a function subprogram.
This flag is used for semantic error checking,
object file LSD blocks (potentially), and the
Cross Reference Listing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INDEP</span></code></dt>
<dd>Set if this is an internal routine allowed in INDEPENDENT loops.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NODESC</span></code></dt>
<dd>If set,
descriptors are not needed for the arguments passed to this subprogram.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PURE</span></code></dt>
<dd>This external is a <em>pure</em> subroutine/function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code></dt>
<dd>This external is a <em>elemental</em> subroutine/function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYPD</span></code></dt>
<dd>Set if subroutine/function appeared in an external statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RECUR</span></code></dt>
<dd>This subprogram is <em>recursive</em> (overloaded with flags <code class="docutils literal notranslate"><span class="pre">VAX</span></code> and
<code class="docutils literal notranslate"><span class="pre">DESCARRAY</span></code>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ABSTRACT</span></code></dt>
<dd>Set if subroutine/function is an abstract interface.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HCCSYM</span></code></dt>
<dd>If set, function is a compiler-created function.</dd>
</dl>
<p><em>Flags2</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">PTRARG</span></code></dt>
<dd>Set if subprogram has one or more pointer arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CFUNC</span></code></dt>
<dd>If set, function/subroutine’s name linkage name follows C conventions
(i.e., underscore is not appended to name).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOCOMM</span></code></dt>
<dd>If set,
communication is not necessary for the arguments passed to this subprogram.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INMODULE</span></code></dt>
<dd>Set if this is a module procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MSCALL</span></code></dt>
<dd>Set if this procedure is defined to use the MS stdcall calling sequence.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CREF</span></code></dt>
<dd>Set if this procedure is defined to use the MS cref calling sequence.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOMIXEDSTRLEN</span></code></dt>
<dd>Set if the character length arguments are to be passed after all of the
the other arguments (i.e., unix-style). If this flag is set, then
either
<code class="docutils literal notranslate"><span class="pre">MSCALL</span></code>
or
<code class="docutils literal notranslate"><span class="pre">CREF</span></code>
is also set.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L3F</span></code></dt>
<dd>If set, function is a LIB3F routine.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SEQUENT</span></code></dt>
<dd>If set, this function or subroutine call should be ‘sequentialized’
if any of its arguments are array arguments; this is used for F90 IO routines.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESULT</span></code></dt>
<dd>Set if a ‘RESULT(name)’ clause was specified on the FUNCTION line.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_f62</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">STDCALL</span></code></dt>
<dd>Set if this ST_PROC has DVF’s
<code class="docutils literal notranslate"><span class="pre">STDCALL</span></code>
attribute.
If this flag is set, then
<code class="docutils literal notranslate"><span class="pre">MSCALL</span></code>
is also set.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DECORATE</span></code></dt>
<dd>Set if this ST_PROC has DVF’s
<code class="docutils literal notranslate"><span class="pre">DECORATE</span></code>
attribute.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SDSCSAFE</span></code></dt>
<dd>Set if this procedure is known not to modify any section descriptor arguments
and does not modify any global section descriptors.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FWDREF</span></code></dt>
<dd>Symbol may have been created by a forward reference to a pure function.</dd>
</dl>
<p><em>Flags3</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">LIBM</span></code></dt>
<dd>This function is from the libm library</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LIBC</span></code></dt>
<dd>This function is from the libc library</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DFLT</span></code></dt>
<dd>This function returns a type of default kind.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GSCOPE</span></code></dt>
<dd>This flag is set on symbols declared in a host program that also appear in a
contains procedure. When this flag is set, we do not perform certain
front end optimizations and we set GSCOPE on the symbol in the back end.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UNFMT</span></code></dt>
<dd>This flag is set when this procedure is in a defined unformatted read/write
generic set.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOCASN</span></code></dt>
<dd>This flag is set when this external is a function that may assign its result
to an allocatable</dd>
</dl>
<p><em>Flags4</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MVDESC</span></code></dt>
<dd>When an array-valued function requires a descriptor for its result, the
descriptor is normally the first descriptor added to the argument list;
if
<code class="docutils literal notranslate"><span class="pre">MVDESC</span></code>
is set, the descriptor is the last descriptor added to the list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARET</span></code></dt>
<dd>Subroutine contains alternate return arguments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VARARG</span></code></dt>
<dd>The function has a variable number of arguments (aka varargs/variadic)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INVOBJINC</span></code></dt>
<dd>The INVOBJ field has been incremented to reflect the shift
in dummy argument positions caused by the conversion of a function
into a subroutine whose first argument is the original result.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVCOMP</span></code></dt>
<dd>Set if this routine was compiled with the -acc or -ta flag, meaning the
compiler was device-aware.</dd>
</dl>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>used to link together referenced externals, i.e. those that are
referenced in an
<code class="docutils literal notranslate"><span class="pre">EXTERNAL</span></code>
statement, or which are determined to be referenced by the Code Scheduler.
List head is pointed to by
<code class="docutils literal notranslate"><span class="pre">gbl.externs</span></code>.
The end of the list is denoted by
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code></dt>
<dd>Byte address relative to program code space of this entry
point, computed by Code Scheduler.
<code class="docutils literal notranslate"><span class="pre">MID</span></code>
block.  Computed by Assembler initialization phase.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLNK</span></code></dt>
<dd>Miscellaneous link field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPDSC</span></code></dt>
<dd>Pointer to the dummy parameter descriptor for this entry (see
auxiliary data structures described below).
Field is only set if the ST_PROC appeared in an interface block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RESERVED_w18</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FUNCLINE</span></code></dt>
<dd>Source line number of first line of subprogram definition.
The
<code class="docutils literal notranslate"><span class="pre">FG</span></code>
index
of the entry; used only by the Optimizer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDLINE</span></code></dt>
<dd>End line number of routine.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAMCT</span></code></dt>
<dd>Number of dummy parameters for this entry point.
This count also includes any implicit arguments required for the entry.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FVAL</span></code></dt>
<dd><p class="first">For array-valued functions, this field locates the compiler
created symbol representing the value returned by the function.</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">INTENT</span> <span class="pre">(b3)</span></code></dt>
<dd>If this procedure is an I/O routine which only read its arguments
(no INTENT(OUT) arguments), set the INTENT field to INTENT_IN.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GSAME</span></code></dt>
<dd>Pointer to the user-defined generic with the same name as this subprogram.
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
marks the end of the list; the head of the list is store in
<code class="docutils literal notranslate"><span class="pre">aux.list[ST_PROC]</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCROUT</span></code></dt>
<dd>Contains a pointer to the information from the ‘acc routine’ directive
for this symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INVOBJ</span></code></dt>
<dd>When this is a type bound procedure, this field will hold the argument number of the pass object
#.SE SDSC
This field is overloaded by TBPLNK, so it’s commented out for documentation
purposes. See TBPLNK below for more information.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TBPLNK</span></code></dt>
<dd>When this is a type bound procedure (i.e., an ST_PROC binding name), this field will hold the derived type tag that this type bound procedure is associated with. CLASS should also be set.
If the symbol is a procedure dummy argument, then this field locates its procedure argument descriptor (which is also a dummy argument). IS_PROC_DUMMY should also be set. Also in the procedure dummy case, this field is referenced with the SDSC macro.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VTOFF</span></code></dt>
<dd>When this is a type bound procedure (i.e., an ST_PROC binding name), this field will hold the offset into a virtual function table.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASSOC_PTR</span></code></dt>
<dd>When set, this is the sptr of a pointer that is initialized with this
procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PTR_TARGET</span></code></dt>
<dd>When set, this ST_PROC is a place holder for a pointer target. This field holds the sptr of the original pointer target.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALTNAME</span></code></dt>
<dd><p class="first">Set if the ST_PROC has DVF’s
also set for common blocks, module variables, subroutines , functions
declares BIND(c,name=’foo’) C visible
<code class="docutils literal notranslate"><span class="pre">ALIAS</span></code>
attribute.
If set, this field is a
symbol table pointer to character constant representing
the alternate name.</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">EXTR</span> <span class="pre">(b4)</span></code></dt>
<dd>Extrinsic type of the prodedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CUDA</span> <span class="pre">(b4)</span></code></dt>
<dd>CUDA attribute (HOST, DEVICE, GLOBAL) of the procedure.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="st-const">
<h4>ST_CONST<a class="headerlink" href="#st-const" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> constant</p>
<p>Note that constants of the partial word data types (c
<code class="docutils literal notranslate"><span class="pre">DT_BINT</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_SLOG</span></code>,
etc.) are not allowed;
the corresponding full-word data type (c
<code class="docutils literal notranslate"><span class="pre">DT_INT</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_LOG</span></code>)
is always used.</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">HOLL</span></code></dt>
<dd>If set, the character constant is also used as a Hollerith
constant.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Used to link together all referenced constants (i.e., those which
will be allocated memory).
List head is pointed to by
<code class="docutils literal notranslate"><span class="pre">gbl.consts</span></code>.
The end of the list is denoted by
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code></dt>
<dd>Relative byte address computed by Assembler initialization.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CONVAL1</span></code></dt>
<dd><p class="first">Constant value, depends on dtype of constant:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT</span></code></dt>
<dd>undefined.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_REAL</span></code></dt>
<dd>undefined.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DBLE</span></code></dt>
<dd>First 32-bit word of d.p. constant in
SC format.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_FLOAT128</span></code></dt>
<dd>First 32-bit word of quad constant.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_CMPLX</span></code></dt>
<dd>32-bit floating point value of real part.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DCMPLX</span></code></dt>
<dd>symbol table pointer to double precision constant for real part.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_QCMPLX</span></code></dt>
<dd>symbol table pointer to quad precision constant for real part.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_CMPLX128</span></code></dt>
<dd>symbol table pointer to quad precision constant for real part.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG</span></code></dt>
<dd>undefined.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_CHAR</span></code></dt>
<dd>relative, integer pointer to character text in symbol name storage area.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_NCHAR</span></code></dt>
<dd>relative, integer pointer to character text (EUC format) in symbol name storage area.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_HOLL</span></code></dt>
<dd>symbol table pointer to the equivalent character constant</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_PTR</span></code></dt>
<dd>symbol table pointer to array or variable symbol.  May be zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DWORD</span></code></dt>
<dd>Left 32-bits (most significant) of the 64-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT8</span></code></dt>
<dd>Left 32-bits (most significant) of the 64-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG8</span></code></dt>
<dd>0</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT128</span></code></dt>
<dd>First 32 bits (most significant) of the 128-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG128</span></code></dt>
<dd>0</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CONVAL2</span></code></dt>
<dd><p class="first">Second constant value:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT</span></code></dt>
<dd>32-bit integer value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_REAL</span></code></dt>
<dd>32-bit floating point value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DBLE</span></code></dt>
<dd>Second 32-bit word of double precision constant.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_FLOAT128</span></code></dt>
<dd>Second 32-bit word of quad constant.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_CMPLX</span></code></dt>
<dd>32-bit floating point value of imaginary part.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DCMPLX</span></code></dt>
<dd>symbol table pointer to double precision constant for imaginary part.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_QCMPLX</span></code></dt>
<dd>symbol table pointer to quad precision constant for imaginary part.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_CMPLX128</span></code></dt>
<dd>symbol table pointer to quad precision constant for imaginary part.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG</span></code></dt>
<dd>1 for TRUE, and 0 for FALSE.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_CHAR</span></code></dt>
<dd>undefined</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_NCHAR</span></code></dt>
<dd>undefined</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_HOLL</span></code></dt>
<dd>kind of Hollerith: ‘h’ (<em>H</em>: normal), ‘l’ (<em>L</em>: left-justified,
zero-filled), ‘r’ (<em>R</em>: right-justified, zero-filled).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_PTR</span></code></dt>
<dd>(signed) integer offset value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DWORD</span></code></dt>
<dd>Right 32-bits (least significant) of the 64-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT8</span></code></dt>
<dd>Right 32-bits (least significant) of the 64-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG8</span></code></dt>
<dd>1 for TRUE, and 0 for FALSE.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT128</span></code></dt>
<dd>Second 32 of the 128-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG128</span></code></dt>
<dd>0</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CONVAL3</span></code></dt>
<dd><p class="first">Third constant value:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_QUAD</span></code></dt>
<dd>Third 32-bit word of quad precision constant.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_FLOAT128</span></code></dt>
<dd>Third 32-bit word of quad constant.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT128</span></code></dt>
<dd>Third 32 bits of the 128-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG128</span></code></dt>
<dd>0</dd>
<dt>Otherwise</dt>
<dd>Undefined</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CONVAL4</span></code></dt>
<dd><p class="first">Fourth constant value:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_QUAD</span></code></dt>
<dd>Fourth 32-bit word of quad precision constant.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_FLOAT128</span></code></dt>
<dd>Fourth 32-bit word of quad constant.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT128</span></code></dt>
<dd>Fourth 32 bits (least significant) of the 128-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG128</span></code></dt>
<dd>1 for TRUE, and 0 for FALSE.</dd>
<dt>Otherwise</dt>
<dd>Undefined</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="st-stfunc">
<h4>ST_STFUNC<a class="headerlink" href="#st-stfunc" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> statement function</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Data type of this statement function has been explicitly declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYP8</span></code></dt>
<dd>Set if the data type of the statement function is implicitly declared as a
<code class="docutils literal notranslate"><span class="pre">real\*8</span></code>
in the presence of the
<code class="docutils literal notranslate"><span class="pre">-r8</span></code>
switch.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOT_IN_USEONLY</span></code></dt>
<dd>This flag is set for variables that are not on the “USE ONLY” list.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>This field is used to link together the statement functions which
are defined in the subprogram; the order of the statement functions
in the list reflects the order in which they were defined.
The head of the list is store in <code class="docutils literal notranslate"><span class="pre">gbl.stfuncs</span></code>;
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code> marks the end of the list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SFDSC</span></code></dt>
<dd>pointer to statement function descriptor. Set and used only by
the semantic analyzer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXCVLEN</span></code></dt>
<dd>If dtype of this statement function is
<code class="docutils literal notranslate"><span class="pre">DT_CHAR</span></code>
or
<code class="docutils literal notranslate"><span class="pre">DT_NCHAR</span></code>,
this is the character length of the expression on the right hand
side of the statement function definition.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SFAST</span></code></dt>
<dd>Pointer to the <code class="docutils literal notranslate"><span class="pre">A_STFUNC</span></code> ast which defines the statement
function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAMCT</span></code></dt>
<dd>Number of dummy parameters for this statement function.</dd>
</dl>
</div>
<div class="section" id="st-param">
<h4>ST_PARAM<a class="headerlink" href="#st-param" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> parameter</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Always set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYPD</span></code></dt>
<dd>Set if the data type of this parameter has been explictly declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code></dt>
<dd>Parameter’s access attribute is <code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VAX</span></code></dt>
<dd>Set if the parameter is defined using the vax-style (no parentheses)
syntax (overloaded with flags <code class="docutils literal notranslate"><span class="pre">RECUR</span></code> and <code class="docutils literal notranslate"><span class="pre">DESCARRAY</span></code>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">END</span></code></dt>
<dd>Marks the end of a group of parameters declared by one parameter
statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAM</span></code></dt>
<dd>Should be set if PARAMVAL holds an AST pointer to an A_INIT tree of values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">REF</span></code></dt>
<dd>This constant parameter is referenced.
Set by Scanner and used only for the -debug ref option.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOT_IN_USEONLY</span></code></dt>
<dd>This flag is set for variables that are not on the “USE ONLY” list.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CONVAL1</span></code></dt>
<dd>If the named constant is a scalar, symbol table pointer to a
<code class="docutils literal notranslate"><span class="pre">ST_CONST</span></code>
entry, except when dtype equals
<code class="docutils literal notranslate"><span class="pre">DT_INT</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_WORD</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_REAL</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">DT_LOG</span></code>,
in which case is the actual 32-bit constant value.
If the named constant is an array, symbol table pointer to a
<code class="docutils literal notranslate"><span class="pre">ST_ARRAY</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CONVAL2</span></code></dt>
<dd>If the named constant is a scalar,
Ast pointer of the expression defining the value of the parameter.
If the named constant is an array,
ACL pointer representing the value of the array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Used to link parameters into 4 separate lists implied by the combinations of
ansi-style vs vax-style syntax and constant syntax vs expression syntax
for the defining values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAMVAL</span></code></dt>
<dd>For derived type or array variables, if the PARAM bit is set, this field
holds an AST pointer to an A_INIT tree of values for the variable.</dd>
</dl>
</div>
<div class="section" id="st-intrin">
<h4>ST_INTRIN<a class="headerlink" href="#st-intrin" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> intrinsic</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Data type of this intrinsic has been explicitly declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXPST</span></code></dt>
<dd>Stype of this intrinsic has been frozen.
Set when a symbol is declared in an
<code class="docutils literal notranslate"><span class="pre">INTRINSIC</span></code>
statement, or is used as an intrinsic.
(This flag is overloaded with VCSYM).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NATIVE</span></code></dt>
<dd>Set if this intrinsic should only be recognized for ‘native-mode’ compilers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYPD</span></code></dt>
<dd>Set if intrinsic appeared in an intrinsic statement.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DTYPE</span></code></dt>
<dd>Has a value of <code class="docutils literal notranslate"><span class="pre">DT_NONE</span></code> if intrinsic did not occur in a type
declaration.  If it did occur in a type declaration this field contains the
data type value specified in the type declaration statement.  This data
type will be used if it happens that the symbol for this intrinsic is used
as a Fortran variable, array, or external function instead of an intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARGTYP</span></code></dt>
<dd>Data type of arguments to this intrinsic.
Used by Semantic Analyzer to do type checking on
intrinsic arguments.
Two special values are allowed,
<code class="docutils literal notranslate"><span class="pre">DT_NUMERIC</span></code>
and
<code class="docutils literal notranslate"><span class="pre">DT_ANY</span></code>.
<code class="docutils literal notranslate"><span class="pre">DT_NUMERIC</span></code>
means the arguments can be either
<code class="docutils literal notranslate"><span class="pre">DT_INT</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_REAL</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_DBLE</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_CMPLX</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">DT_DCMPLX</span></code>.
<code class="docutils literal notranslate"><span class="pre">DT_WORD</span></code>
means the argument must be one of the 32-bit data types,
<code class="docutils literal notranslate"><span class="pre">DT_INT</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_REAL</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">DT_LOG</span></code>.
<code class="docutils literal notranslate"><span class="pre">DT_ANY</span></code>
means any data type is allowed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTTYP</span></code></dt>
<dd>Data type of the result returned by this intrinsic.  The <code class="docutils literal notranslate"><span class="pre">DTYPE</span></code>
field won’t necessarily be the same as the <code class="docutils literal notranslate"><span class="pre">INTTYP</span></code>
field.  The <code class="docutils literal notranslate"><span class="pre">DTYPE</span></code>
field will change if the intrinsic name occurs in a type declaration
statement.  The <code class="docutils literal notranslate"><span class="pre">DTYPE</span></code> and <code class="docutils literal notranslate"><span class="pre">INTTYP</span></code> fields are kept
separate because an intrinsic name can occur in a type declaration
statement and must not have any effect on the intrinsic unless later it
is determined that the intrinsic name loses its intrinsic properties
and becomes a normal user symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PNMPTR</span></code></dt>
<dd><p class="first">A value of zero indicates that the intrinsic may not
be passed as a subprogram argument.
Otherwise, the field is a
pointer (relative) into the symbol names area to the null terminated
text string used to determine the name to use when in the context
of passing the intrinsic as an argument or other contexts.
The name located by this field is one of:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;-&lt;name&gt;&quot;</span></code>: The intrinsic cannot be passed as an argument;
<code class="docutils literal notranslate"><span class="pre">&lt;name</span></code> is used when the intrinsic is referenced.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;&lt;name&gt;&quot;</span></code>: The intrinsic can be passed as an argument.
<code class="docutils literal notranslate"><span class="pre">&lt;name</span></code> is used when passing the intrinsic as an argument; in
other contexts, the name of the intrinsic is used.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;\*&quot;</span></code>: The intrinsic can be passed as an argument;
use the name of the intrinsic for all contexts.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;\*&lt;name&gt;&quot;</span></code>: The intrinsic can be passed as an argument;
<code class="docutils literal notranslate"><span class="pre">&lt;name</span></code> is used for the intrinsic in all contexts.</li>
</ul>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">INTAST</span></code></dt>
<dd>A manifest constant representing the intrinsic when referenced
by the ASTs.
These manifest constants are #define’d in ast.h;
the names of the constants are derived by prefixing the name of the
intrinsic with
<code class="docutils literal notranslate"><span class="pre">\_</span></code>.
The ast utility creates the #define’s.
Note that this field is not defined for generics; when a generic
is processed, its specific intrinsic is located and then the
<code class="docutils literal notranslate"><span class="pre">INTAST</span></code>
value is extracted from the specific.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAMCT</span></code></dt>
<dd>Number of arguments for this intrinsic.
A value of 11 is used to mark the 2 intrinsics which convert
to complex and double complex, which take either 1 or 2 arguments.
A value of 12 or 13 marks the max and min intrinsics, which
take two or more arguments.  13 marks the max/min intrinsics
for which a type conversion must be performed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ILM</span></code></dt>
<dd>ILM opcode number for this intrinsic.
Equals zero if this is a type conversion intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARRAYF</span></code></dt>
<dd>ILM opcode number for this intrinsic when argument is an array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INKIND</span></code></dt>
<dd><p class="first">Kind of the intrinsic:</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">IK_ELEMENTAL</span></code></dt>
<dd>intrinsic is an elemental function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IK_INQUIRY</span></code></dt>
<dd>intrinsic is an inquiry function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IK_TRANSFORM</span></code></dt>
<dd>intrinsic is a transformation function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IK_SUBROUTINE</span></code></dt>
<dd>intrinsic is a subroutine.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KWDARG</span></code></dt>
<dd>Index into the
<code class="docutils literal notranslate"><span class="pre">intrinsic_kwd</span></code>
array.
An element of the array is a string which constains a blank-separated
list of the names of the keyword arguments for the intrinsic.
The order of the names in the list is in <em>positional</em> order.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KWDCNT</span></code></dt>
<dd>Number of keyword arguments for the intrinsic;
this count does not include the
<em>variable</em>
arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GNRINTR</span></code></dt>
<dd>For newer specifics of older generic intrinsics,
this field contains the symbol table pointer of
encompassing generic intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXTSYM</span></code></dt>
<dd>If set, this field is the symbol table pointer of the
<code class="docutils literal notranslate"><span class="pre">ST_PROC</span></code>
symbol representing the function which is called
by the generated code.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="st-generic">
<h4>ST_GENERIC<a class="headerlink" href="#st-generic" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> generic</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Set if a data type is declared for this symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXPST</span></code></dt>
<dd>Stype of this symbol is frozen at
<code class="docutils literal notranslate"><span class="pre">ST_GENERIC.</span></code>
Set when generic name is declared in an
<code class="docutils literal notranslate"><span class="pre">INTRINSIC</span></code>
statement or when it is used as a generic name.
(This flag is overloaded with CCTMP).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYPD</span></code></dt>
<dd>Set if intrinsic appeared in an intrinsic statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DTYPE</span></code></dt>
<dd>Has a value of <code class="docutils literal notranslate"><span class="pre">DT_NONE</span></code> if generic did not occur in a type
declaration.  If it did occur in a type declaration this field contains the
data type value specified in the type declaration statement.  This data
type will be used if it happens that the symbol for this intrinsic is used
as a Fortran variable, array, or external function instead of an generic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GINT</span></code></dt>
<dd>Symbol table pointer to intrinsic for integer arguments.
Zero if there is no such intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTAST</span></code></dt>
<dd>See <code class="docutils literal notranslate"><span class="pre">ST_INTRIN</span></code> .</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GDBLE</span></code></dt>
<dd>Pointer to double precision intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GCMPLX</span></code></dt>
<dd>Pointer to complex intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GDCMPLX</span></code></dt>
<dd>Pointer to double complex intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GSAME</span></code></dt>
<dd>Pointer to the intrinsic with the same name as this generic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GSINT</span></code></dt>
<dd>Pointer to short integer intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GINT8</span></code></dt>
<dd>Pointer to 64-bit integer intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INKIND</span></code></dt>
<dd>Kind of the intrinsic:
<code class="docutils literal notranslate"><span class="pre">IK_ELEMENTAL</span></code>,
<code class="docutils literal notranslate"><span class="pre">IK_INQUIRY</span></code>,
<code class="docutils literal notranslate"><span class="pre">IK_TRANSFORM</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">IK_SUBROUTINE</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KWDARG</span></code></dt>
<dd>Index into the
<code class="docutils literal notranslate"><span class="pre">intrinsic_kwd</span></code>
array.
An element of the array is a string which constains a blank-separated
list of the names of the keyword arguments for the intrinsic.
The order of the names in the list is in <em>positional</em> order.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KWDCNT</span></code></dt>
<dd>Number of keyword arguments for the intrinsic;
this count does not include the
<em>variable</em>
arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KINDPOS</span></code></dt>
<dd>If this field is non-zero, the argument at the position indicated by
the field’s value is the optional
<code class="docutils literal notranslate"><span class="pre">KIND</span></code>
argument.
The position number is relative to one; one is the first argument, etc.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GQUAD</span></code></dt>
<dd>Pointer to 16-byte real intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GQCMPLX</span></code></dt>
<dd>Pointer to 32-byte complex intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GREAL</span></code></dt>
<dd>Pointer to real intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXTSYM</span></code></dt>
<dd>If set, this field is the symbol table pointer of the
<code class="docutils literal notranslate"><span class="pre">ST_PROC</span></code>
symbol representing the function which is called
by the generated code.</dd>
</dl>
</div>
<div class="section" id="st-usergeneric">
<h4>ST_USERGENERIC<a class="headerlink" href="#st-usergeneric" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> usergeneric</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Set if a data type is declared for this symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOT_IN_USEONLY</span></code></dt>
<dd>This flag is set for variables that are not on the “USE ONLY” list.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">GSAME</span></code></dt>
<dd>Pointer to the user function with the same name as this generic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GNDSC</span></code></dt>
<dd>This field locates a list of symbols
which maps the user generic to its overloaded functions.
This symbol list is represented by a list of <code class="docutils literal notranslate"><span class="pre">SYMI</span></code> items
(see auxiliary data structures described below).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GNCNT</span></code></dt>
<dd>Number of overloaded functions for the user-defined generic.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">VTOFF</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">TBPLNK</span></code></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">GTYPE</span></code></dt>
<dd>A generic name may be the same name as a a derived-type name.
If set, this field is the symbol table pointer to the
<code class="docutils literal notranslate"><span class="pre">ST_TYPEDEF</span></code>
representing the derived type.</dd>
</dl>
</div>
<div class="section" id="st-pd">
<h4>ST_PD<a class="headerlink" href="#st-pd" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> predeclared</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NATIVE</span></code></dt>
<dd>Set if this subroutine should only be recognized for ‘native-mode’ compilers.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DTYPE</span></code></dt>
<dd>Has a value of <code class="docutils literal notranslate"><span class="pre">DT_NONE</span></code> if predeclared did not occur in a type
declaration.  If it did occur in a type declaration this field contains the
data type value specified in the type declaration statement.  This data
type will be used if it happens that the symbol for this intrinsic is used
as a Fortran variable, array, or external function instead of an predeclared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTTYP</span></code></dt>
<dd>Data type of the result returned by this intrinsic. Required if the
predeclared’s name can appear as an argument.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PNMPTR</span></code></dt>
<dd>A value of zero indicates that the intrinsic may not
be passed as a subprogram argument.
Otherwise, the field is a
pointer (relative) into the symbol names area to the null terminated
text string used to determine the name to use when in the context
of passing the intrinsic as an argument or other contexts.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTAST</span></code></dt>
<dd>A manifest constant representing the predeclared when referenced
by the ASTs.
These manifest constants are #define’d in ast.h;
the names of the constants are derived by prefixing the name of the
intrinsic with
<code class="docutils literal notranslate"><span class="pre">\_</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PDNUM</span></code></dt>
<dd>Predeclared symbol number corresponding to one of the
<code class="docutils literal notranslate"><span class="pre">PD_xxx</span></code>
macros in the <code class="docutils literal notranslate"><span class="pre">pd.h</span></code> include file.
Used for special casing the code generation
for these symbols.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INKIND</span></code></dt>
<dd>Kind of the intrinsic:
<code class="docutils literal notranslate"><span class="pre">IK_ELEMENTAL</span></code>,
<code class="docutils literal notranslate"><span class="pre">IK_INQUIRY</span></code>,
<code class="docutils literal notranslate"><span class="pre">IK_TRANSFORM</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">IK_SUBROUTINE</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KWDARG</span></code></dt>
<dd>Index into the
<code class="docutils literal notranslate"><span class="pre">intrinsic_kwd</span></code>
array.
An element of the array is a string which constains a blank-separated
list of the names of the keyword arguments for the intrinsic.
The order of the names in the list is in <em>positional</em> order.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KWDCNT</span></code></dt>
<dd>Number of keyword arguments for the intrinsic;
this count does not include the
<em>variable</em>
arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXTSYM</span></code></dt>
<dd>If set, this field is the symbol table pointer of the
<code class="docutils literal notranslate"><span class="pre">ST_PROC</span></code>
symbol representing the function which is called
by the generated code.</dd>
</dl>
</div>
<div class="section" id="st-plist">
<h4>ST_PLIST<a class="headerlink" href="#st-plist" title="Permalink to this headline">¶</a></h4>
<p><em>OC_NONE</em> plist</p>
<p>Parameter list -
used for compiler-created one dimension arrays (i.e. format lists).</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DINIT</span></code></dt>
<dd>Set if the variable has been data initialized.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CCSYM</span></code></dt>
<dd>Indicates that this variable is a compiler created variable.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">REF</span></code></dt>
<dd>Set if this variable is referenced.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TLS</span></code></dt>
<dd>This common block is in thread local storage.</dd>
</dl>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DTYPE</span></code></dt>
<dd>Data type indicating size of each entry (i.e. when used for
format lists, each entry is 32 bits wide - <code class="docutils literal notranslate"><span class="pre">DT_INT</span></code>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Used to link plists into the local data area.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code></dt>
<dd>Address assigned to the parameter list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PLLEN</span></code></dt>
<dd>Number of entries in the parameter lists.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SWEL</span></code></dt>
<dd>If this plist is used to describe the
<code class="docutils literal notranslate"><span class="pre">COMPUTED</span> <span class="pre">GOTO</span></code>
list, this field is
is the index into the
<code class="docutils literal notranslate"><span class="pre">swel</span></code>
area (base is located by
<code class="docutils literal notranslate"><span class="pre">switch_base</span></code>)
representing where the its list of labels and values begins.
This field is only used by the expander and optimizer when
processing the
<code class="docutils literal notranslate"><span class="pre">JMPM</span></code>
ILI .</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEFLAB</span></code></dt>
<dd>If this plist is used to describe the
<code class="docutils literal notranslate"><span class="pre">COMPUTED</span> <span class="pre">GOTO</span></code>
list,
this field is is the default label for the
<code class="docutils literal notranslate"><span class="pre">COMPUTED</span> <span class="pre">GOTO</span></code>.
This field is only used by the expander and optimizer when
processing the
<code class="docutils literal notranslate"><span class="pre">JMPM</span></code></dd>
<dt><code class="docutils literal notranslate"><span class="pre">ETLS</span></code></dt>
<dd>Extended TLS levels
ILI .</dd>
</dl>
</div>
<div class="section" id="st-arrdsc">
<h4>ST_ARRDSC<a class="headerlink" href="#st-arrdsc" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> array descriptor</p>
<p>This symbol represents the align and distribution
descriptor created by the transformer
and used by the communication analyzer.
This symbol is pointed to by the
<code class="docutils literal notranslate"><span class="pre">DESCR</span></code>
field of an array (ST_ARRAY).
The align and distribution descriptors (see auxiliary data structures)
contain
information computed from the align target and distribution descriptors.</p>
<p><em>Flags</em></p>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ARRAY</span></code></dt>
<dd>Pointer to the
<code class="docutils literal notranslate"><span class="pre">ST_ARRAY</span></code>
for which this descriptor is created.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALND</span></code></dt>
<dd>Pointer to the align and distribution (see auxiliary data structures)
represented by the symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SECD</span></code></dt>
<dd>Pointer to the section descriptor (see auxiliary data structures)
which will be created to described the array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SECDSC</span></code></dt>
<dd>Pointer to the section descriptor created by the front-end (or any phase
before transform()).
If the field is non-zero, the transformer uses the descriptor located by
this field; the actual symbol located by this field is a based/allocatable
array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RENAME</span></code></dt>
<dd><p class="first">temporarily holds the symbol number to which the
AST for this symbol will be renamed.</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SDSCINIT</span></code></dt>
<dd>Indicates that the static descriptor (ST_DESRIPTOR)
in SECDSC has been initialized (and can be used
to initialize the other static descriptors).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLNK</span></code></dt>
<dd>Links together all alignment symbols.
<code class="docutils literal notranslate"><span class="pre">NOSYM</span></code>
marks the end of the list; the head of the list is store in
<code class="docutils literal notranslate"><span class="pre">aux.list[ST_ARRDSC]</span></code>.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="st-alias">
<h4>ST_ALIAS<a class="headerlink" href="#st-alias" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> alias</p>
<p>The symbol is an alias for another symbol; for example, the
result identifier for a function or entry is an alias for the
function or entry name.</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SEPARATEMP</span></code></dt>
<dd>MODULE SUBROUTINE, MODULE FUNCTION for a separate module procedure.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>The sptr for which this symbol is an alias; the scanner, upon seeing
an alias symbol, will return this symbol.</dd>
</dl>
</div>
<div class="section" id="st-module">
<h4>ST_MODULE<a class="headerlink" href="#st-module" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> module</p>
<p>The symbol is a MODULE or SUBMODULE program unit.</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ISSUBMODULE</span></code></dt>
<dd>Used to mark the submodule SUBROUTINE, submodule FUNCTION that is defined
inside interface and used by submodules. This is used to differentiate
the normal module SUBROUTINE, FUNCTION, and PROCEDURE.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HAS_TBP_BOUND_TO_SMP</span></code></dt>
<dd>This flag is set when this module has a derived type with a type bound
procedure that is implemented by a separate module procedure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HAS_SMP_DEC</span></code></dt>
<dd>This flag is set on modules that have a separate module procedure declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NEEDMOD</span></code></dt>
<dd>If set, an external reference to this module needs to be generated,
so a link error will occur if a program that USEs this module is linked
without the .o file containing the module.
In older versions of the compiler, this flag was set for all modules.
In current versions, this flag is set only if the module contains
dinits.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYPD</span></code></dt>
<dd>If set, the interpretation of
<code class="docutils literal notranslate"><span class="pre">NEEDMOD</span></code>
indicates that the module contains dinits.  When both flags are
set, the backend will
generate a hard reference to the global module name when USEd.</dd>
</dl>
<p><em>Flags2</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">FROMMOD</span></code></dt>
<dd>If set, this common block was defined in a module.
Used to inhibit output of debug information in a subroutine
that `use’s a module.</dd>
</dl>
<p><em>Flags3</em></p>
<p><em>Flags4</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DEVCOMP</span></code></dt>
<dd>Set if this routine was compiled with the -acc or -ta flag, meaning the
compiler was device-aware.</dd>
</dl>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ANCESTOR</span></code></dt>
<dd>Used for setting submodule’s ancestor module.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARENT</span></code></dt>
<dd>Used for setting a parent module for submodules.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMEMF</span></code></dt>
<dd>Used for imported modules to point to the first symbol imported for this module.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FUNCLINE</span></code></dt>
<dd>Source line number of first line</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDLINE</span></code></dt>
<dd>Source line number of the last line</dd>
</dl>
</div>
<div class="section" id="st-typedef">
<h4>ST_TYPEDEF<a class="headerlink" href="#st-typedef" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> typedef</p>
<p>The symbol is a derived type.</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Set for all ST_MODULE symbols.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DINIT</span></code></dt>
<dd>If set, this module appeared in a USE statement (was not
just from nested USES within a USEd module), needed for debug output.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DISTMEM</span></code></dt>
<dd>Set if it contains a distributed element, or member with the DISTMEM flag.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOCFLD</span></code></dt>
<dd>Set if the derived type has allocatable components</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOT_IN_USEONLY</span></code></dt>
<dd>This flag is set for variables that are not on the “USE ONLY” list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FROMMOD</span></code></dt>
<dd>The symbol is from a module</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CLASS</span></code></dt>
<dd>This is set when an object is polymorphic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UNLPOLY</span></code></dt>
<dd>This is set when this object is an unlimited polymorphic object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SEQ</span></code></dt>
<dd>If set, all components in the derived type are SEQUENCE types.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CFUNC</span></code></dt>
<dd>If set, the derived type has the BIND(C) attribute, i.e., it’s
interoperable with a C struct type.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ISOCTYPE</span></code></dt>
<dd>This is set when this object is an iso_c_binding type.
<em>Flags2</em></dd>
</dl>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">BASETYPE</span></code></dt>
<dd>If this variable is a tag for a parameterized derived type, then this stores
the original dtype in the tag.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VTOFF</span></code></dt>
<dd>Used in semant to keep track the number of type bound procedures associated with this derived type.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARENT</span></code></dt>
<dd>Contains sptr of parent of the type extension</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DTYPE</span></code></dt>
<dd>Pointer to a <code class="docutils literal notranslate"><span class="pre">TY_STRUCT</span></code> data type record.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYPDEF_INIT</span></code></dt>
<dd>Symbol table pointer to a compiler generated variable</dd>
</dl>
</div>
<div class="section" id="st-operator">
<h4>ST_OPERATOR<a class="headerlink" href="#st-operator" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OPERATOR</em> operator</p>
<p>User-defined operator.</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOT_IN_USEONLY</span></code></dt>
<dd>This flag is set for variables that are not on the “USE ONLY” list.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">PDNUM</span></code></dt>
<dd>If the operator is an intrinsic or assignment operator,
this value indicates the type of operation to perform and
corresponds to one of the
<code class="docutils literal notranslate"><span class="pre">OP_xxx</span></code>
macros in <code class="docutils literal notranslate"><span class="pre">ast.h</span></code> include file.
Semant maintains a table of <code class="docutils literal notranslate"><span class="pre">ST_OPERATOR</span></code> symbols
indexed by the
<code class="docutils literal notranslate"><span class="pre">OP_xxx</span></code>
value.
The table consists of
<code class="docutils literal notranslate"><span class="pre">ST_OPERATOR</span></code>
symbols corresponding to the intrinsic or assignment operators
specified in an interface.
To determine if an intrinsic or assignment operator was overloaded by
the user, semant accesses this table with the the operator’s
<code class="docutils literal notranslate"><span class="pre">OP_xxx</span></code>
value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INKIND</span></code></dt>
<dd>Kind of operator:
<code class="docutils literal notranslate"><span class="pre">0</span></code> (defined-operator),
<code class="docutils literal notranslate"><span class="pre">1</span></code> (intrinsic or assignment operator).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GNDSC</span></code></dt>
<dd>This field locates a list of symbols
which maps the operator to its overloaded functions.
This symbol list is represented by a list of <code class="docutils literal notranslate"><span class="pre">SYMI</span></code> items
(see auxiliary data structures described below).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GNCNT</span></code></dt>
<dd>Number of overloaded functions for the user-defined operator.</dd>
</dl>
</div>
<div class="section" id="st-modproc">
<h4>ST_MODPROC<a class="headerlink" href="#st-modproc" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> module procedure</p>
<p>Symbol which appears in the MODULE PROCEDURE statement whose declaration
will be completed by a <code class="docutils literal notranslate"><span class="pre">CONTAIN</span></code>’d subprogram.</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOT_IN_USEONLY</span></code></dt>
<dd>This flag is set for variables that are not on the “USE ONLY” list.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SYMLK</span></code></dt>
<dd>Symbol table pointer to the module procedure’s ST_ENTRY or ST_ALIAS; filled
in when its <code class="docutils literal notranslate"><span class="pre">CONTAIN</span></code>’d subprogram is seen.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SYMI</span></code></dt>
<dd>This field locates a list of symbols of the ST_USERGENERICs and/or
ST_OPERATORs which map to the module procedure.
This symbol list is represented by a list of <code class="docutils literal notranslate"><span class="pre">SYMI</span></code> items
(see auxiliary data structures described below).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GSAME</span></code></dt>
<dd><p class="first">Symbol table pointer to the module procedure’s ST_USERGENERIC if its name is the
same as the generic name.</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">EXTR</span> <span class="pre">(b4)</span></code></dt>
<dd>Extrinsic type of the prodedure.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="st-construct">
<h4>ST_CONSTRUCT<a class="headerlink" href="#st-construct" title="Permalink to this headline">¶</a></h4>
<p><em>OC_CONSTRUCT</em> construct name</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">HIDDEN</span></code></dt>
<dd>The symbol is hidden.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">FUNCLINE</span></code></dt>
<dd>Source line number of where the control structure begins.</dd>
</dl>
</div>
<div class="section" id="st-cray">
<h4>ST_CRAY<a class="headerlink" href="#st-cray" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> cray intrinsic</p>
<p>The symbol is an intrinsic valid for the Cray targets.
The predefined portion of the symbol table includes symbols for the
Cray intrinsics.
These procedures are not intrinsic to the language; however, it is
necessary that the semantic processing of these procedures be performed
as if they are predeclareds.
The lines in
<code class="docutils literal notranslate"><span class="pre">symini_ftn.n</span></code>
defining these symbols begin with
<code class="docutils literal notranslate"><span class="pre">.H4</span></code>.</p>
<p>The symbol table utility creates these symbols and defines the symbols’ fields
as if the symbols are
predeclared (<code class="docutils literal notranslate"><span class="pre">ST_PD</span></code>); the exception is that the stype of these symbols
is <code class="docutils literal notranslate"><span class="pre">ST_CRAY</span></code>.
If the target is a Cray,
the compiler scans the predefined portion of the symbol table and changes
the stype of these symbols from
to <code class="docutils literal notranslate"><span class="pre">ST_PD</span></code>.</p>
<p>If the target is a not a Cray,
the compiler, if a symbol is seen whose
name is the same as a craft intrinsic,  will create a new
(user) symbol whose stype is <code class="docutils literal notranslate"><span class="pre">ST_UNKNOWN</span></code>.</p>
<p><em>Flags</em></p>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
</div>
<div class="section" id="st-block">
<h4>ST_BLOCK<a class="headerlink" href="#st-block" title="Permalink to this headline">¶</a></h4>
<p><em>OC_NONE</em> block</p>
<p>A symbol is created for each lexical block.</p>
<p><em>Flags</em></p>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code></dt>
<dd>Unused (???).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">STARTLINE</span></code></dt>
<dd>Start line number of block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDLINE</span></code></dt>
<dd>End line number of block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">STARTLAB</span></code></dt>
<dd>Start label of block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AUTOBJ</span></code></dt>
<dd>Links together automatic data objects local to the function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARSYMSCT</span></code></dt>
<dd>Count number of contiguous items in the AUX parsyms field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARSYMS</span></code></dt>
<dd>Starting index into the AUX parsyms field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARUPLEVEL</span></code></dt>
<dd>Store uplevel sptr for openmp outlined function.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDLAB</span></code></dt>
<dd>End label of block.</dd>
</dl>
</div>
<div class="section" id="st-isoc">
<h4>ST_ISOC<a class="headerlink" href="#st-isoc" title="Permalink to this headline">¶</a></h4>
<p>See ST_INTRIN : Set up like an ST_INTRIN, these are the predefined
intrinsics that get loaded with the iso_c_binding module.  When activated,
they become ST_INTRIN
<em>OC_OTHER</em> iso c intrinsic</p>
<p><em>Flags</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DCLD</span></code></dt>
<dd>Data type of this intrinsic has been explicitly declared.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXPST</span></code></dt>
<dd>Stype of this intrinsic has been frozen.
Set when a symbol is declared in an
<code class="docutils literal notranslate"><span class="pre">INTRINSIC</span></code>
statement, or is used as an intrinsic.
(This flag is overloaded with VCSYM).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NATIVE</span></code></dt>
<dd>Set if this intrinsic should only be recognized for ‘native-mode’ compilers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TYPD</span></code></dt>
<dd>Set if intrinsic appeared in an intrinsic statement.</dd>
</dl>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DTYPE</span></code></dt>
<dd>Has a value of <code class="docutils literal notranslate"><span class="pre">DT_NONE</span></code> if intrinsic did not occur in a type
declaration.  If it did occur in a type declaration this field contains the
data type value specified in the type declaration statement.  This data
type will be used if it happens that the symbol for this intrinsic is used
as a Fortran variable, array, or external function instead of an intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARGTYP</span></code></dt>
<dd>Data type of arguments to this intrinsic.
Used by Semantic Analyzer to do type checking on
intrinsic arguments.
Two special values are allowed,
<code class="docutils literal notranslate"><span class="pre">DT_NUMERIC</span></code>
and
<code class="docutils literal notranslate"><span class="pre">DT_ANY</span></code>.
<code class="docutils literal notranslate"><span class="pre">DT_NUMERIC</span></code>
means the arguments can be either
<code class="docutils literal notranslate"><span class="pre">DT_INT</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_REAL</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_DBLE</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_CMPLX</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">DT_DCMPLX</span></code>.
<code class="docutils literal notranslate"><span class="pre">DT_WORD</span></code>
means the argument must be one of the 32-bit data types,
<code class="docutils literal notranslate"><span class="pre">DT_INT</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_REAL</span></code>,
or
<code class="docutils literal notranslate"><span class="pre">DT_LOG</span></code>.
<code class="docutils literal notranslate"><span class="pre">DT_ANY</span></code>
means any data type is allowed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INTTYP</span></code></dt>
<dd>Data type of the result returned by this intrinsic.  The <code class="docutils literal notranslate"><span class="pre">DTYPE</span></code>
field won’t necessarily be the same as the <code class="docutils literal notranslate"><span class="pre">INTTYP</span></code>
field.  The <code class="docutils literal notranslate"><span class="pre">DTYPE</span></code>
field will change if the intrinsic name occurs in a type declaration
statement.  The <code class="docutils literal notranslate"><span class="pre">DTYPE</span></code> and <code class="docutils literal notranslate"><span class="pre">INTTYP</span></code> fields are kept
separate because an intrinsic name can occur in a type declaration
statement and must not have any effect on the intrinsic unless later it
is determined that the intrinsic name loses its intrinsic properties
and becomes a normal user symbol.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PNMPTR</span></code></dt>
<dd><p class="first">A value of zero indicates that the intrinsic may not
be passed as a subprogram argument.
Otherwise, the field is a
pointer (relative) into the symbol names area to the null terminated
text string used to determine the name to use when in the context
of passing the intrinsic as an argument or other contexts.
The name located by this field is one of:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;-&lt;name&gt;&quot;</span></code>: The intrinsic cannot be passed as an argument;
<code class="docutils literal notranslate"><span class="pre">&lt;name</span></code> is used when the intrinsic is referenced.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;&lt;name&gt;&quot;</span></code>: The intrinsic can be passed as an argument.
<code class="docutils literal notranslate"><span class="pre">&lt;name</span></code> is used when passing the intrinsic as an argument; in
other contexts, the name of the intrinsic is used.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;\*&quot;</span></code>: The intrinsic can be passed as an argument;
use the name of the intrinsic for all contexts.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;\*&lt;name&gt;&quot;</span></code>: The intrinsic can be passed as an argument;
<code class="docutils literal notranslate"><span class="pre">&lt;name</span></code> is used for the intrinsic in all contexts.</li>
</ul>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">INTAST</span></code></dt>
<dd>A manifest constant representing the intrinsic when referenced
by the ASTs.
These manifest constants are #define’d in ast.h;
the names of the constants are derived by prefixing the name of the
intrinsic with
<code class="docutils literal notranslate"><span class="pre">\_</span></code>.
The ast utility creates the #define’s.
Note that this field is not defined for generics; when a generic
is processed, its specific intrinsic is located and then the
<code class="docutils literal notranslate"><span class="pre">INTAST</span></code>
value is extracted from the specific.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PARAMCT</span></code></dt>
<dd>Number of arguments for this intrinsic.
A value of 11 is used to mark the 2 intrinsics which convert
to complex and double complex, which take either 1 or 2 arguments.
A value of 12 or 13 marks the max and min intrinsics, which
take two or more arguments.  13 marks the max/min intrinsics
for which a type conversion must be performed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ILM</span></code></dt>
<dd>ILM opcode number for this intrinsic.
Equals zero if this is a type conversion intrinsic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARRAYF</span></code></dt>
<dd>ILM opcode number for this intrinsic when argument is an array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INKIND</span></code></dt>
<dd><dl class="first last docutils">
<dt>Kind of the intrinsic:</dt>
<dd>See ST_INTRIN</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KWDARG</span></code></dt>
<dd>Index into the
<code class="docutils literal notranslate"><span class="pre">intrinsic_kwd</span></code>
array.
An element of the array is a string which constains a blank-separated
list of the names of the keyword arguments for the intrinsic.
The order of the names in the list is in <em>positional</em> order.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KWDCNT</span></code></dt>
<dd>Number of keyword arguments for the intrinsic;
this count does not include the
<em>variable</em>
arguments.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXTSYM</span></code></dt>
<dd>If set, this field is the symbol table pointer of the
<code class="docutils literal notranslate"><span class="pre">ST_PROC</span></code>
symbol representing the function which is called
by the generated code.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="st-ieeearith">
<h4>ST_IEEEARITH<a class="headerlink" href="#st-ieeearith" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> IEEE_ARITHMETIC intrinsic</p>
<p>The symbol is an IEEE_ARITHMETIC module procedure.
The predefined portion of the symbol table includes symbols for the
IEEE_ARITHMETIC module procedures.
These procedures are not intrinsic to the language; however, it is
necessary that the semantic processing of these procedures be performed
as if they are predeclareds
The lines in
<code class="docutils literal notranslate"><span class="pre">symini_ftn.n</span></code>
defining these symbols begin with
<code class="docutils literal notranslate"><span class="pre">.H5</span></code>.</p>
<p>The symbol table utility creates these symbols and defines the symbols’ fields
as if the symbols are
predeclared (<code class="docutils literal notranslate"><span class="pre">ST_PD</span></code>); the exception is that the stype of these symbols
is <code class="docutils literal notranslate"><span class="pre">ST_IEEEARITH</span></code>.
If the statement <code class="docutils literal notranslate"><span class="pre">USE</span> <span class="pre">IEEE_ARITHMETIC</span></code> is seen,
the compiler scans the predefined portion of the symbol table and changes
the stype of these symbols from <code class="docutils literal notranslate"><span class="pre">ST_IEEEARITH</span></code>
to <code class="docutils literal notranslate"><span class="pre">ST_PD</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">USE</span></code> statement is not seen,
the compiler, if a symbol is seen whose
name is the same as a IEEE_ARITHMETIC procedure,  will create a new
(user) symbol whose stype is <code class="docutils literal notranslate"><span class="pre">ST_UNKNOWN</span></code>.</p>
<p><em>Flags</em></p>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
</div>
<div class="section" id="st-ieeeexcept">
<h4>ST_IEEEEXCEPT<a class="headerlink" href="#st-ieeeexcept" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> IEEE_EXCEPTIONS intrinsic</p>
<p>The symbol is an IEEE_EXCEPTIONS module procedure.
The predefined portion of the symbol table includes symbols for the
IEEE_EXCEPTIONS module procedures.
These procedures are not intrinsic to the language; however, it is
necessary that the semantic processing of these procedures be performed
as if they are predeclareds
The lines in
<code class="docutils literal notranslate"><span class="pre">symini_ftn.n</span></code>
defining these symbols begin with
<code class="docutils literal notranslate"><span class="pre">.H5</span></code>.</p>
<p>The symbol table utility creates these symbols and defines the symbols’ fields
as if the symbols are
predeclared (<code class="docutils literal notranslate"><span class="pre">ST_PD</span></code>); the exception is that the stype of these symbols
is <code class="docutils literal notranslate"><span class="pre">ST_IEEEEXCEPT</span></code>.
If the statement <code class="docutils literal notranslate"><span class="pre">USE</span> <span class="pre">IEEE_EXCEPTIONS</span></code> is seen,
the compiler scans the predefined portion of the symbol table and changes
the stype of these symbols from <code class="docutils literal notranslate"><span class="pre">ST_IEEEEXCEPT</span></code>
to <code class="docutils literal notranslate"><span class="pre">ST_PD</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">USE</span></code> statement is not seen,
the compiler, if a symbol is seen whose
name is the same as a IEEE_EXCEPTIONS procedure,  will create a new
(user) symbol whose stype is <code class="docutils literal notranslate"><span class="pre">ST_UNKNOWN</span></code>.</p>
<p><em>Flags</em></p>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
</div>
<div class="section" id="st-isoftnenv">
<h4>ST_ISOFTNENV<a class="headerlink" href="#st-isoftnenv" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> iso fortran env intrinsic</p>
<p>The symbol is an iso_Fortran_env module procedure.
The predefined portion of the symbol table includes symbols for the
iso_Fortran_env module procedures.
The entries are generated as (<code class="docutils literal notranslate"><span class="pre">ST_PD</span></code>) and,
when a <code class="docutils literal notranslate"><span class="pre">USE</span> <span class="pre">ISO_FORTRAN_ENV</span></code>) is seen
they are changed to (<code class="docutils literal notranslate"><span class="pre">ST_ISOFTNENV</span></code>).
Then, as the module is processed these entries are
changed to back (<code class="docutils literal notranslate"><span class="pre">ST_PD</span></code>) as appropriatec
for the particular  <code class="docutils literal notranslate"><span class="pre">USE</span></code>) statement.</p>
<p><em>Flags</em></p>
<p><em>Flags2</em></p>
<p><em>Flags3</em></p>
<p><em>Other Fields</em></p>
</div>
<div class="section" id="st-dpname">
<h4>ST_DPNAME<a class="headerlink" href="#st-dpname" title="Permalink to this headline">¶</a></h4>
<p><em>OC_OTHER</em> deep copy name</p>
<p>Flags</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">USED</span></code></dt>
<dd>Set if this name is referenced.</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="auxiliary-data-structures">
<h2>Auxiliary Data Structures<a class="headerlink" href="#auxiliary-data-structures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="data-type-lists">
<h3>Data Type Lists<a class="headerlink" href="#data-type-lists" title="Permalink to this headline">¶</a></h3>
<p>The data types of symbols (<code class="docutils literal notranslate"><span class="pre">DTYPE</span></code> field)
and expressions are
represented by an integer which is used as a relative pointer
into the data type area.
This area is a contiguous block in dynamic storage, consisting
of a series of variable length records.
Basic data types such as
“integer”
are represented by
a unique, single word record in this area.
Others, such as structure types,
are represented by a multi-word record.
Complex data types
are represented by linked lists of records.</p>
<p>The first word of each record defines the type of record.
The allowed values of this first word are covered by the
following macros:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_NONE</span></code> <code class="docutils literal notranslate"><span class="pre">none</span></code></dt>
<dd>— no type assigned</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_WORD</span></code> <code class="docutils literal notranslate"><span class="pre">word</span></code> INT BASIC SCALAR VEC WORD</dt>
<dd>— 32-bit value whose interpretation depends on context.
Used only for intrinsic symbols within Semantic Analyzer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DWORD</span></code> <code class="docutils literal notranslate"><span class="pre">dword</span></code> INT BASIC SCALAR VEC DWORD</dt>
<dd>— 64-bit value whose interpretation depends on context.
Internal to the Fortran compiler.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">TY_HOLL</span></code> <code class="docutils literal notranslate"><span class="pre">hollerith</span></code> BASIC SCALAR</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_BINT</span></code> <code class="docutils literal notranslate"><span class="pre">byte</span></code> INT BASIC SCALAR VEC WORD</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_SINT</span></code> <code class="docutils literal notranslate"><span class="pre">integer\*2</span></code> INT BASIC SCALAR VEC WORD</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_INT</span></code> <code class="docutils literal notranslate"><span class="pre">integer</span></code> INT BASIC SCALAR VEC WORD</dt>
<dd>or
<code class="docutils literal notranslate"><span class="pre">integer\*4</span></code>.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">TY_INT8</span></code> <code class="docutils literal notranslate"><span class="pre">integer\*8</span></code> INT BASIC SCALAR VEC DWORD</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_HALF</span></code> <code class="docutils literal notranslate"><span class="pre">real\*2</span></code> REAL BASIC SCALAR VEC WORD</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_REAL</span></code> <code class="docutils literal notranslate"><span class="pre">real</span></code> REAL BASIC SCALAR VEC WORD</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_DBLE</span></code> <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">precision</span></code> REAL BASIC SCALAR VEC DWORD</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_QUAD</span></code> <code class="docutils literal notranslate"><span class="pre">real\*16</span></code> REAL BASIC SCALAR VEC</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_HCMPLX</span></code> <code class="docutils literal notranslate"><span class="pre">half</span> <span class="pre">complex</span></code> CMPLX BASIC SCALAR VEC WORD</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_CMPLX</span></code> <code class="docutils literal notranslate"><span class="pre">complex</span></code> CMPLX BASIC SCALAR VEC DWORD</dt>
<dd>(2 x 32-bit).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DCMPLX</span></code> <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">complex</span></code> CMPLX BASIC SCALAR VEC</dt>
<dd>(2 x 64-bit).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_QCMPLX</span></code> <code class="docutils literal notranslate"><span class="pre">complex\*32</span></code> CMPLX BASIC SCALAR VEC</dt>
<dd>(2 x real*16).</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">TY_BLOG</span></code> <code class="docutils literal notranslate"><span class="pre">logical\*1</span></code> LOG BASIC SCALAR VEC WORD INT</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_SLOG</span></code> <code class="docutils literal notranslate"><span class="pre">logical\*2</span></code> LOG BASIC SCALAR VEC WORD INT</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_LOG</span></code> <code class="docutils literal notranslate"><span class="pre">logical</span></code> LOG BASIC SCALAR VEC WORD INT</dt>
<dd>or
<code class="docutils literal notranslate"><span class="pre">logical\*4</span></code>.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">TY_LOG8</span></code> <code class="docutils literal notranslate"><span class="pre">logical\*8</span></code> LOG BASIC SCALAR VEC DWORD INT</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_CHAR</span></code> <code class="docutils literal notranslate"><span class="pre">character</span></code> CHAR BASIC SCALAR VEC</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TY_NCHAR</span></code> <code class="docutils literal notranslate"><span class="pre">ncharacter</span></code> NCHAR BASIC SCALAR</dt>
<dd>— kanji character string).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_PTR</span></code> <code class="docutils literal notranslate"><span class="pre">pointer</span></code> BASIC SCALAR</dt>
<dd>— Pointer to … (internal)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_ARRAY</span></code> <code class="docutils literal notranslate"><span class="pre">array</span></code></dt>
<dd>— Array of …</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_STRUCT</span></code> <code class="docutils literal notranslate"><span class="pre">structure</span></code></dt>
<dd>— Struct x.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_UNION</span></code> <code class="docutils literal notranslate"><span class="pre">union</span></code></dt>
<dd>— UNION statement).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TY_DERIVED</span></code> <code class="docutils literal notranslate"><span class="pre">derived</span></code> VEC</dt>
<dd>— TYPE statement).</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">TY_NUMERIC</span></code> <code class="docutils literal notranslate"><span class="pre">numeric</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">TY_ANY</span></code> <code class="docutils literal notranslate"><span class="pre">any</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">TY_PROC</span></code> <code class="docutils literal notranslate"><span class="pre">procedure</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">TY_128</span></code> <code class="docutils literal notranslate"><span class="pre">128-bit</span></code> BASIC SCALAR VEC INT</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_256</span></code> <code class="docutils literal notranslate"><span class="pre">256-bit</span></code> BASIC SCALAR VEC INT</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_512</span></code> <code class="docutils literal notranslate"><span class="pre">512-bit</span></code> BASIC SCALAR VEC INT</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_INT128</span></code> <code class="docutils literal notranslate"><span class="pre">integer(16)</span></code> BASIC SCALAR VEC INT</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_LOG128</span></code> <code class="docutils literal notranslate"><span class="pre">logical(16)</span></code> LOG BASIC SCALAR VEC INT</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_FLOAT128</span></code> <code class="docutils literal notranslate"><span class="pre">real(16)</span></code> REAL BASIC SCALAR VEC</p>
<p><code class="docutils literal notranslate"><span class="pre">TY_CMPLX128</span></code> <code class="docutils literal notranslate"><span class="pre">complex(32)</span></code> CMPLX BASIC SCALAR VEC</p>
<p>Records of type
<code class="docutils literal notranslate"><span class="pre">TY_WORD</span></code>
through
<code class="docutils literal notranslate"><span class="pre">TY_LOG</span></code>
consist of a single word.
The format of other record types are as follows:
.DT TY_CHAR</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt>
<dd>length of character data in bytes. A length value of 0
indicates that the symbol is an assumed size or deferred size.
.DT TY_NCHAR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt>
<dd>Number of characters in the string. A length value of 0
indicates that the symbol is an assumed/deferred size dummy argument.
.DT TY_PTR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dtype</span></code></dt>
<dd>relative pointer to a record in the dtype area.
.DT TY_ARRAY</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dtype</span></code></dt>
<dd>relative pointer to a record in the dtype area.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt>
<dd>relative pointer to the array bounds descriptor
describing this array.
.DT TY_STRUCT TY_UNION TY_DERIVED</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sptr</span></code></dt>
<dd>symbol table pointer to the first member of this struct, union, or derived type.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd>size in bytes of this struct, union, or derived type.  32-bit quantity.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tag</span></code></dt>
<dd>symbol table pointer to struct or union tag;
symtol table pointer to the ST_TYPEDEF if derived.
0 if none was specified.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">align</span></code></dt>
<dd>alignment required for this struct, union, or derived.
0 — byte, 1 — halfword, 3 — word, or 7 — double word.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ict</span></code></dt>
<dd>initializer constant tree pointer (only for struct and union).
.DT TY_PROC</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dtype</span></code></dt>
<dd>relative pointer to a record in the dtype area; return type of the
procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interface</span></code></dt>
<dd>symbol table pointer to the interface, a SUBROUTINE or FUNCTION; could
be zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">paramct</span></code></dt>
<dd>Number of dummy parameters for this procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpdsc</span></code></dt>
<dd>Pointer to the dummy parameter descriptor for this procedure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fval</span></code></dt>
<dd>symbol table pointer to the FVAL if FUNCTION; could be zero.
.DT E</dd>
</dl>
<p>When the Symbol Table is initialized, the data type
area is allocated and a number of predefined
types are added to it.
The predefined types can be referenced via the following macros:</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_NONE</span></code> <code class="docutils literal notranslate"><span class="pre">none</span></code> TY_NONE</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DT_WORD</span></code> <code class="docutils literal notranslate"><span class="pre">word</span></code> TY_WORD</dt>
<dd>32-bit value whose interpretation depends
on context.  Used only for intrinsic
symbols within Semantic Analyzer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_DWORD</span></code> <code class="docutils literal notranslate"><span class="pre">dword</span></code> TY_DWORD</dt>
<dd>64-bit value whose interpretation depends
on context.  Internal to the Fortran compiler.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">DT_HOLL</span></code> <code class="docutils literal notranslate"><span class="pre">hollerith</span></code> TY_HOLL</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_BINT</span></code> <code class="docutils literal notranslate"><span class="pre">byte</span></code> TY_BINT</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_SINT</span></code> <code class="docutils literal notranslate"><span class="pre">integer\*2</span></code> TY_SINT</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_INT4</span></code> <code class="docutils literal notranslate"><span class="pre">integer</span></code> TY_INT</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_INT8</span></code> <code class="docutils literal notranslate"><span class="pre">integer\*8</span></code> TY_INT8</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_REAL2</span></code> <code class="docutils literal notranslate"><span class="pre">real\*2</span></code> TY_HALF</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_REAL4</span></code> <code class="docutils literal notranslate"><span class="pre">real</span></code> TY_REAL</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_REAL8</span></code> <code class="docutils literal notranslate"><span class="pre">real\*8</span></code> TY_DBLE</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_QUAD</span></code> <code class="docutils literal notranslate"><span class="pre">real\*16</span></code> TY_QUAD</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_CMPLX4</span></code> <code class="docutils literal notranslate"><span class="pre">half</span> <span class="pre">complex</span></code> TY_HCMPLX</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_CMPLX8</span></code> <code class="docutils literal notranslate"><span class="pre">complex</span></code> TY_CMPLX</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_CMPLX16</span></code> <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">complex</span></code> TY_DCMPLX</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_QCMPLX</span></code> <code class="docutils literal notranslate"><span class="pre">complex\*32</span></code> TY_QCMPLX</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_BLOG</span></code> <code class="docutils literal notranslate"><span class="pre">logical\*1</span></code> TY_BLOG</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_SLOG</span></code> <code class="docutils literal notranslate"><span class="pre">logical\*2</span></code> TY_SLOG</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_LOG4</span></code> <code class="docutils literal notranslate"><span class="pre">logical</span></code> TY_LOG</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_LOG8</span></code> <code class="docutils literal notranslate"><span class="pre">logical\*8</span></code> TY_LOG8</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_ADDR</span></code> <code class="docutils literal notranslate"><span class="pre">address</span></code> TY_PTR DT_ANY</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DT_CHAR</span></code> <code class="docutils literal notranslate"><span class="pre">character\*1</span></code> TY_CHAR 1</dt>
<dd>One byte character string.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_NCHAR</span></code> <code class="docutils literal notranslate"><span class="pre">ncharacter\*1</span></code> TY_NCHAR 1</dt>
<dd>One character kanji string.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_ANY</span></code> <code class="docutils literal notranslate"><span class="pre">any</span></code> TY_ANY</dt>
<dd>Any type (for intrinsics).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_NUMERIC</span></code> <code class="docutils literal notranslate"><span class="pre">numeric</span></code> TY_NUMERIC</dt>
<dd>Any numeric type (for intrinsics).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_ASSNCHAR</span></code> `` `` TY_NCHAR 0</dt>
<dd>Assumed size kanji string dummy argument.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_ASSCHAR</span></code> <code class="docutils literal notranslate"><span class="pre">assumed-size</span> <span class="pre">char</span></code> TY_CHAR 0</dt>
<dd>Assumed size character.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_IARRAY</span></code> <code class="docutils literal notranslate"><span class="pre">integer(1:1)</span></code> TY_ARRAY 0 0</dt>
<dd>Integer array (1:1); this predeclared data type is filled in by
ast_init().</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">DT_128F</span></code> <code class="docutils literal notranslate"><span class="pre">__m128</span></code> TY_128</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_128D</span></code> <code class="docutils literal notranslate"><span class="pre">__m128d</span></code> TY_128</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_128I</span></code> <code class="docutils literal notranslate"><span class="pre">__m128i</span></code> TY_128</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_256</span></code> <code class="docutils literal notranslate"><span class="pre">256-bit</span></code> TY_256</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_256F</span></code> <code class="docutils literal notranslate"><span class="pre">__m256</span></code> TY_256</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_256D</span></code> <code class="docutils literal notranslate"><span class="pre">__m256d</span></code> TY_256</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_256I</span></code> <code class="docutils literal notranslate"><span class="pre">__m256i</span></code> TY_256</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_512</span></code> <code class="docutils literal notranslate"><span class="pre">512-bit</span></code> TY_512</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_512F</span></code> <code class="docutils literal notranslate"><span class="pre">__m512</span></code> TY_512</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_512D</span></code> <code class="docutils literal notranslate"><span class="pre">__m512d</span></code> TY_512</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_512I</span></code> <code class="docutils literal notranslate"><span class="pre">__m512i</span></code> TY_512</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_INT128</span></code> <code class="docutils literal notranslate"><span class="pre">integer(16)</span></code> TY_INT128</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_LOG128</span></code> <code class="docutils literal notranslate"><span class="pre">logical(16)</span></code> TY_LOG128</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_FLOAT128</span></code> <code class="docutils literal notranslate"><span class="pre">real(16)</span></code> TY_FLOAT128</p>
<p><code class="docutils literal notranslate"><span class="pre">DT_CMPLX128</span></code> <code class="docutils literal notranslate"><span class="pre">complex(32)</span></code> TY_CMPLX128</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DT_DEFERNCHAR</span></code> `` `` TY_NCHAR 0</dt>
<dd>Deferred-length kanji character.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_DEFERCHAR</span></code> <code class="docutils literal notranslate"><span class="pre">deferred-length</span> <span class="pre">char</span></code> TY_CHAR 0</dt>
<dd>Deferred-length character.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_RSVD4</span></code> <code class="docutils literal notranslate"><span class="pre">rsvd4</span></code> TY_NONE</dt>
<dd>For future expansion; when a new data type is defined, a reserved data type
is deleted to keep the number of the predefined data types the same in
the .mod file.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_RSVD3</span></code> <code class="docutils literal notranslate"><span class="pre">rsvd3</span></code> TY_NONE</dt>
<dd>For future expansion; when a new data type is defined, a reserved data type
is deleted to keep the number of the predefined data types the same in
the .mod file.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_RSVD2</span></code> <code class="docutils literal notranslate"><span class="pre">rsvd2</span></code> TY_NONE</dt>
<dd>For future expansion; when a new data type is defined, a reserved data type
is deleted to keep the number of the predefined data types the same in
the .mod file.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DT_RSVD1</span></code> <code class="docutils literal notranslate"><span class="pre">rsvd1</span></code> TY_NONE</dt>
<dd><p class="first">For future expansion; when a new data type is defined, a reserved data type
is deleted to keep the number of the predefined data types the same in
the .mod file.</p>
<p class="last">.rr Sx.rr II.rr PS.rm OC.rm SF.rm ST.rm Sc.rm SM.rm SI.rm FL.rm SE.rm TY.rm DT.rm DE.rm PD</p>
</dd>
</dl>
<p>The data types which are used to represent the target’s default
integer, real, complex, and logical types are not predefined types;
the defaults are stored in the
<code class="docutils literal notranslate"><span class="pre">STB</span></code>
structure in members
<code class="docutils literal notranslate"><span class="pre">dt_int</span></code>,
<code class="docutils literal notranslate"><span class="pre">dt_real</span></code>,
<code class="docutils literal notranslate"><span class="pre">dt_cmplx</span></code>,
and
<code class="docutils literal notranslate"><span class="pre">dt_log</span></code>.
Macros which can be used to access the target’s defaults are
DT_INT ,
DT_REAL ,
DT_CMPLX ,
and
DT_LOG ,
respectively.
Each of these values will refer to one of the respective predefined
data types.
The default values, assigned by sym_init_first(), are
<code class="docutils literal notranslate"><span class="pre">DT_INT4</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_REAL4</span></code>,
<code class="docutils literal notranslate"><span class="pre">DT_CMPLX8</span></code>,
and
DT_LOG4 ,
respectively.
If the defaults must be changed, indicated by an option passed to the
compiler, new values are assigned in sym_init().</p>
</div>
<div class="section" id="array-bounds-descriptors">
<h3>Array Bounds Descriptors<a class="headerlink" href="#array-bounds-descriptors" title="Permalink to this headline">¶</a></h3>
<p>An array bounds descriptor is created for each array when the
declaration for the array is processed by the Semantic
Analyzer.
The descriptors specify the upper and lower bounds of the array,
and other information derived from the bounds which the Expander
uses to generate code for array references.
The descriptor is pointed to by the <code class="docutils literal notranslate"><span class="pre">desc</span></code> field of the
array dtype record.</p>
<p>Except for
<code class="docutils literal notranslate"><span class="pre">NUMDIM</span></code>,
<code class="docutils literal notranslate"><span class="pre">DEFER</span></code>,
<code class="docutils literal notranslate"><span class="pre">ADJARR</span></code>,
<code class="docutils literal notranslate"><span class="pre">ASSUMSHP</span></code>,
<code class="docutils literal notranslate"><span class="pre">ASSUMRANK</span></code>,
and
<code class="docutils literal notranslate"><span class="pre">ASSUMSZ</span></code>,
the fields of the descriptor
are symbol table pointers which point to an integer constant if
the particular value is known at compile time, or
point to a compiler created variable if the array is an
adjustable array and the particular value is known only at
run time.</p>
<p>When the Semantic Analyzer processes an adjustable array declaration,
it writes out the ILM’s necessary to assign the correct values to
the compiler created variables referenced in the descriptor.</p>
<p>Descriptors can be shared between two arrays with identical
bounds.  The Semantic Analyzer currently shares descriptors
for arrays with constant bounds.</p>
<p>The form of an array bounds descriptor is as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="15%" />
<col width="15%" />
<col width="16%" />
<col width="16%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>NUMDIM</td>
<td>FLAGS</td>
<td>ZBASE</td>
<td>not used</td>
<td colspan="2">not used</td>
</tr>
<tr class="row-even"><td>MLPYR(1)</td>
<td>LWBD(1)</td>
<td>UPBD(1)</td>
<td>LWAST(1)</td>
<td colspan="2">UPAST(1)</td>
</tr>
<tr class="row-odd"><td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="row-even"><td>MLPYR(DIM)</td>
<td>LWBD(DIM)</td>
<td>UPBD(DIM)</td>
<td>LWAST(DIM)</td>
<td>UPAST(DIM)</td>
<td>EXTNTAST(DIM)</td>
</tr>
<tr class="row-odd"><td>NUMELM</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NUMDIM:</span></code></dt>
<dd>Number of dimensions of the array.
Integer constant in the range 1 to 7.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LWBD(i):</span></code></dt>
<dd>Lower bound (AST) for the ith dimension of the array.
If a lower bound is non-constant or if the shape of the array is deferred,
this field is the AST of
a compiler created variable which is assigned a value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UPBD(i):</span></code></dt>
<dd>Upper bound (AST) for the ith dimension of the array.
This value is zero for the last dimension of an assumed size array.
This field is the AST of a compiler-created temporary if the upper bound
is adjustable or if the shape of the array is assumed or deferred.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LWAST(i):</span></code></dt>
<dd>The AST of the lower bound; zero if a lower bound is not specified.
This field is the AST of a compiler-created temporary if the upper bound
is adjustable or if the shape of the array is assumed or deferred.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UPAST(i):</span></code></dt>
<dd>The AST of the upper bound; zero if the upper bound is assumed
size (*).
This field is the AST of a compiler-created temporary if the upper bound
is adjustable or if the shape of the array is assumed or deferred.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MLPYR(i):</span></code></dt>
<dd><p class="first">Multiplier (AST) for the ith dimension of the array.
The multiplier is computed as follows:</p>
<ul>
<li><div class="first highlight-none notranslate"><div class="highlight"><pre><span></span>For i == 1,  MLPYR(i) == 1

For i &gt; 1,   MLPYR(i) = MLPYR(i-1) \*
                          (UPBD(i-1)-LWBD(i-1)+1)
</pre></div>
</div>
</li>
</ul>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">FLAGS:</span></code></dt>
<dd><p class="first">Eight consecutive (char) fields (2 unused):
<code class="docutils literal notranslate"><span class="pre">ASSUMSHP</span></code> (if set, array has assumed shape);
<code class="docutils literal notranslate"><span class="pre">ASSUMRANK</span></code> (if set, array has assumed rank);
<code class="docutils literal notranslate"><span class="pre">DEFER</span></code> (if set, array has deferred shape);
<code class="docutils literal notranslate"><span class="pre">ADJARR</span></code> (if set, array is adjustable);
<code class="docutils literal notranslate"><span class="pre">ASSUMSZ</span></code> (if set, array has assumed size);
and <code class="docutils literal notranslate"><span class="pre">NOBOUNDS</span></code> (array’s bounds are written as colons).</p>
<dl class="last docutils">
<dt>NUMELM:</dt>
<dd>Number of elements in the array.
Note that this value may be computed as the multiplier for
dimension
<code class="docutils literal notranslate"><span class="pre">NUMDIM+1.</span></code>
For an assumed size array, this value is zero.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>For example, the offset of an array element of the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>a(SUB(1), SUB(2), ..., SUB(NUMDIM))
</pre></div>
</div>
<p>is the summation of the terms:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(SUB(i) - LWBD(i)) \* MLPYR(i)
        for i = 1, ... NUMDIM.
</pre></div>
</div>
<p>or :</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(SUB(i) \* MLPYR(i) for i = 1, ... NUMDIM.) - ZBASE
</pre></div>
</div>
</div>
<div class="section" id="storage-overlap-chains">
<h3>Storage Overlap Chains<a class="headerlink" href="#storage-overlap-chains" title="Permalink to this headline">¶</a></h3>
<p>Storage overlap chains are created during equivalence processing
by the Semantic Analyzer, and specify for each variable or array
involved in an equivalence which other variables or arrays overlap
it in storage.</p>
<p>Storage overlap chains are pointed to by the
<code class="docutils literal notranslate"><span class="pre">SOCPTR</span></code>
field of variables and arrays.</p>
<p>The chains are used by the Expander and Optimizer to ensure
that the generated code is correct.</p>
<p>The easiest implementation of
<code class="docutils literal notranslate"><span class="pre">SOC's</span></code>
is as linked lists.</p>
</div>
<div class="section" id="namelist-group-lists">
<h3>Namelist Group Lists<a class="headerlink" href="#namelist-group-lists" title="Permalink to this headline">¶</a></h3>
<p>Namelist group lists are created by the Semantic Analyzer when
processing the
<code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code>
statement.  Each item in the list consists of the following fields:</p>
<dl class="docutils">
<dt>sptr:</dt>
<dd>relative pointer into the symtab area of the variable
or array representing the item which belongs
to the namelist group.</dd>
<dt>next:</dt>
<dd>relative pointer into the namelist area of the next item of
the list. A value of
<code class="docutils literal notranslate"><span class="pre">0</span></code>
marks the end of the list.</dd>
<dt>lineno:</dt>
<dd>line number of the
<code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code>
statement containing the item.</dd>
</dl>
<p>The
<code class="docutils literal notranslate"><span class="pre">CMEMF</span></code>
field of a namelist symbol (stype
<code class="docutils literal notranslate"><span class="pre">ST_NML</span></code>
locates the beginning of its group
list; the
<code class="docutils literal notranslate"><span class="pre">CMEML</span></code>
locates the end of its group list.</p>
<p>Each namelist group is processed at the end of the Semantic Analyzer.
If namelist I/O occurred for a group, its associated
<code class="docutils literal notranslate"><span class="pre">ST_PLIST</span></code>
(located by the field
<code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code>)
must be data initialized with the group’s namelist descriptor.
This descriptor is passed to the I/O library and controls the
namelist editing.</p>
<p>The namelist group descriptor is described by the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nml {
    char        group[32];
    int         ndesc;
    struct desc desc[];
};
</pre></div>
</div>
<p>The fields in the
<code class="docutils literal notranslate"><span class="pre">nml</span></code>
structure have the following meanings:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">group</span></code></dt>
<dd>Name of the group.  This is a null-terminated character string.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ndesc</span></code></dt>
<dd>Number of descriptors.  There is one descriptor for each item
in the group.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt>
<dd>Array of descriptors.  This is a variable length array with
<code class="docutils literal notranslate"><span class="pre">ndesc</span></code>
elements.</dd>
</dl>
<p>The item descriptor is described by the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct desc {
    char  sym[32];
    char \*addr;
    int   type;
    int   len;
    int   ndims;
    int   dims[];
};
</pre></div>
</div>
<p>The fields in the
<code class="docutils literal notranslate"><span class="pre">desc</span></code>
structure have the following meanings:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sym</span></code></dt>
<dd>Name of this item.  This is a null-terminated character string.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt>
<dd>Address of this item.
Note that dummy arguments may not appear in a <code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> statement.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt>
<dd>Type of this item.  The legal types are the same as those in the description
of
<code class="docutils literal notranslate"><span class="pre">fio$unf_read</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt>
<dd>Length of the item if it is a <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> variable; length of the
array element if it is a <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> array;
otherwise, it’s
<code class="docutils literal notranslate"><span class="pre">0</span></code>.
For type <code class="docutils literal notranslate"><span class="pre">NCHARACTER</span></code>, is number of <code class="docutils literal notranslate"><span class="pre">w_char</span></code> data items.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ndims</span></code></dt>
<dd>Number of dimensions of this item.  Zero if the item is not an array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dims</span></code></dt>
<dd>Dimension information.  If
<code class="docutils literal notranslate"><span class="pre">ndims</span></code>
is 0, then this information does not appear;
otherwise, it contains 2*c
<code class="docutils literal notranslate"><span class="pre">ndims</span></code>
words of information.
For
<code class="docutils literal notranslate"><span class="pre">1\(&lt;=i\(&lt;=ndims</span></code>,
<code class="docutils literal notranslate"><span class="pre">dims[2\*(i-1)]</span></code>
is the lower bound for dimension
<code class="docutils literal notranslate"><span class="pre">i</span></code>,
and
<code class="docutils literal notranslate"><span class="pre">dims[2\*(i-1)+1]</span></code>
is the upper bound for dimension
<code class="docutils literal notranslate"><span class="pre">i</span></code>.</dd>
</dl>
</div>
<div class="section" id="dummy-parameter-descriptors">
<h3>Dummy Parameter Descriptors<a class="headerlink" href="#dummy-parameter-descriptors" title="Permalink to this headline">¶</a></h3>
<p>A dummy parameter descriptor is built for each entry point in a program
unit.
The DPDSC field of the entry point’s symbol table entry points to the
dummy parameter descriptor.
The dummy parameter descriptor is simply a list (organized as a table)
of symbol table pointers, one for each dummy parameter.
If a dummy parameter denotes an alternate return, the symbol table
pointer is 0.</p>
</div>
<div class="section" id="symbol-list-items">
<h3>Symbol List Items<a class="headerlink" href="#symbol-list-items" title="Permalink to this headline">¶</a></h3>
<p>For certain situations, it’s necessary to create a list of symbols, such
as to represent the list of overloaded subprograms for user-defined
generics and operators.
A symbol list item (<code class="docutils literal notranslate"><span class="pre">SYMI</span></code> represents each item in the list and
has two fields:</p>
<dl class="docutils">
<dt>sptr:</dt>
<dd>relative pointer into the symtab area.</dd>
<dt>next:</dt>
<dd>relative pointer into the <code class="docutils literal notranslate"><span class="pre">SYMI</span></code> area locating the next item
in the list.
This field is zero for the last item in the list.</dd>
</dl>
<p>Macros used to access the fields of a symbol list item are:</p>
<p><code class="docutils literal notranslate"><span class="pre">SYMI_SPTR(i)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">SYMI_NEXT(i)</span></code></p>
</div>
<div class="section" id="section-descriptors">
<h3>Section Descriptors<a class="headerlink" href="#section-descriptors" title="Permalink to this headline">¶</a></h3>
<p>Section descriptors are created by the transformer for an array.
The descriptors are located via the
<code class="docutils literal notranslate"><span class="pre">SECD</span></code>
field of
<code class="docutils literal notranslate"><span class="pre">ST_ARRDSC</span></code>
symbols.</p>
<p>The form of a section descriptor is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="24%" />
<col width="24%" />
<col width="15%" />
<col width="12%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>DTYPE</td>
<td>NUMDIM</td>
<td>ALND</td>
<td>DESCR</td>
<td>FLAG</td>
</tr>
<tr class="row-even"><td>LWB(1)</td>
<td>UPB(1)</td>
<td>LOVLP(1)</td>
<td colspan="2">UOVLP(1)</td>
</tr>
<tr class="row-odd"><td>…</td>
<td>…</td>
<td>…</td>
<td colspan="2">…</td>
</tr>
<tr class="row-even"><td>LWB(<em>m</em>)</td>
<td>UPB(<em>m</em>)</td>
<td colspan="3">UOVLP(<em>m</em>)</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DTYPE:</span></code></dt>
<dd>Pointer to the data type record representing the element type of the
array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NUMDIM:</span></code></dt>
<dd>Rank (<em>m</em>) of the array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALND:</span></code></dt>
<dd>Pointer to the section’s align and distribute descriptor.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DESCR:</span></code></dt>
<dd>Pointer to the symbol table entry of the array which will appear
in the generated source output and represents the storage for
the descriptor.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FLAG:</span></code></dt>
<dd>Value indicating that the array is assumed-size, assumed-shape, or
sequential.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LWB(k):</span></code></dt>
<dd>Pointer to the AST representing the lower bound of the array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UPB(k):</span></code></dt>
<dd>Pointer to the AST representing the upper bound of the array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LOVLP(k):</span></code></dt>
<dd>Amount of overlap on the bottom (integer, not ast).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UOVLP(k):</span></code></dt>
<dd>Amount of overlap on the top (integer, not ast).
<code class="docutils literal notranslate"><span class="pre">-m</span></code>.</dd>
</dl>
<p>Macros used to access the fields of an align target descriptor are:</p>
<p><code class="docutils literal notranslate"><span class="pre">SECD_NUMDIM(i)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">SECD_DESCR(i)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">SECD_DTYPE(i)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">SECD_FLAG(i)</span></code></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SECD_LWB(i,j)</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">j</span></code> is the dimension relative to 0.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">SECD_UPB(i,j)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">SECD_LOVLP(i,j)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">SECD_UOVLP(i,j)</span></code></p>
</div>
</div>
<div class="section" id="program-units">
<h2>Program Units<a class="headerlink" href="#program-units" title="Permalink to this headline">¶</a></h2>
<p>The following routines make up the C module file, ‘symtab.c’.
In addition to being used by the Fortran compiler itself, this module is
used by the utility program SYMINI which sets up entries
for the intrinsics and generics.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void sym_init(symini)
</pre></div>
</div>
<p>Initialize symbol table:
allocate dynamic storage space, initialize implicit data type
arrays, initialize intrinsic and generic entries of symbol table,
and add entries for predefined constants.
The argument is a flag which indicates whether syminit is being called
from the utility program SYMINI, in which case the symbol table is
initialized to be completely empty (this flag is also used at compiler
startup).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int getsym(name, length)
</pre></div>
</div>
<ul>
<li><p class="first">Enter symbol with indicated name into symbol table,
initialize the new entry, and return pointer to it.
New symbols are initialized to a type of
<code class="docutils literal notranslate"><span class="pre">ST_UNKNOWN.</span></code>
If there is already a symbol with this name, return pointer
to it instead.  The overloading class of the symbol is determined
by the semantic analyzer using the semsym.c routines.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int getcon(value, dtype)
</pre></div>
</div>
</li>
<li><p class="first">Enter constant (symbol with stype ==
<code class="docutils literal notranslate"><span class="pre">ST_CONST)</span></code>
of given
dtype and value into the symbol table and return pointer to it.
If an entry for the constant already exists, return pointer to it
instead.</p>
</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int getstring(value, length)
</pre></div>
</div>
<ul class="simple">
<li>Enter character string constant into the symbol table and return
pointer to it.
If the string is already in the table, return pointer to existing
entry instead.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int putsname(name, length)
</pre></div>
</div>
<ul class="simple">
<li>Enter string of characters of indicated length into the
symbol names area and return pointer (relative to
name area base) to it.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void init_implicit(firstc, lastc, dtype)
</pre></div>
</div>
<ul class="simple">
<li>Initialize the default settings for the implicit data types.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void newimplicit(firstc, lastc, dtype)
</pre></div>
</div>
<ul class="simple">
<li>Change the current settings for implicit data types and
variable lengths for characters from firstc to lastc.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void setimplicit(sptr)
</pre></div>
</div>
<ul class="simple">
<li>Assign to the indicated symbol table entry, the current
implicit dtype, depending on the first character of its name.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void save_implicit()
</pre></div>
</div>
<ul class="simple">
<li>Save the current settings for implicit data types in a static
save area.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void restore_implicit()
</pre></div>
</div>
<ul class="simple">
<li>Restore the settings for implicit data types from the static
save area.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int getsname(sptr, ptr)
</pre></div>
</div>
<ul class="simple">
<li>Move name of symbol into the character buffer pointed to by ptr.
For constant symbols, a printable representation of the constant
value suitable for the Object Code Listing is created.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void getcctmp(letter, n stype, dtype)
</pre></div>
</div>
<ul class="simple">
<li>Create (or possibly reuse) a compiler created symbol whose name is
of the form
<code class="docutils literal notranslate"><span class="pre">z_&lt;letter&gt;_&lt;d&gt;</span></code>
where
<code class="docutils literal notranslate"><span class="pre">d&gt;``is</span> <span class="pre">the</span> <span class="pre">decimal</span> <span class="pre">representation</span>
<span class="pre">of</span> <span class="pre">n;</span> <span class="pre">the</span> <span class="pre">range</span> <span class="pre">of</span>
<span class="pre">``&lt;d&gt;</span></code>
is [0,9999].</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void getlab()
</pre></div>
</div>
<ul class="simple">
<li>Fetch the next available label (starting from 99999).</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void pop_scope()
</pre></div>
</div>
<ul class="simple">
<li>Scan all hash lists and remove symbols whose scope is greater than
or equal to the current scope.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void symdmp(file, full)
</pre></div>
</div>
<ul class="simple">
<li>For compiler debugging purposes, dump the symbol table in
readable form to the indicated file.
If full == 1, include the predefined symbols (intrinsics, generics,
and certain constants) in the dump, otherwise begin the dump
with the first user symbol.</li>
</ul>
<p>The following routines, in module semsym.c, are used to resolve
symbols according to overloading class:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int declref(sptr, stype, def)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to symbol with the same name and stype as sptr.
If one is not found, a new symbol is created if def is set to ‘d’;
otherwise, an error occurs.
If def is not set to ‘d’, the current and outer scopes are searched.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int declsym(sptr, stype, errflg)
</pre></div>
</div>
<ul class="simple">
<li>Return the pointer to the new symbol of the given stype.
If a symbol of the same overloading class is found,
an error occurs if errflag is true.
Note symbols declared in an outer scope are ignored.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int refsym(sptr, oclass)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to symbol with the same name as sptr and overloading class
oclass in the
the current or outer scope.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int refsym_inscope(sptr, oclass)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to symbol with the same name as sptr and overloading class
oclass possibly taking into consideration of the current scope.
If the the symbol is a subprogram and its scope immediately encloses the
current scope, the symbol is returned.
Otherwise, refsym_inscope() behaves the same as refsym().</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int declobject(sptr, stype)
</pre></div>
</div>
<ul class="simple">
<li>Declare and
return a pointer to a symbol which are non-data objects (e.g., TEMPLATE
and PROCESSOR).
For these symbols, it’s legal to specify the object’s shape before the
actual stype.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ref_ident(sptr)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to symbol where the current context requires an
<em>identifier</em>.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ref_int_scalar(sptr)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to symbol where the current context requires an
integer scalar variable.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ref_based_object(sptr)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to the symbol which is the pointer variable
of the based object represented by sptr.</li>
</ul>
<p>The following routines, in module dtypeutil.c, are used
to allocate dtype area records and perform certain
operations upon data types:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int get_type(n, v1, v2)
</pre></div>
</div>
<ul class="simple">
<li>Allocate a data type record of n words and assign the
values v1 (record id) and v2 to the first two elements.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void getdtype(dtype, ptr)
int dtype;
char \*ptr;
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOGICAL eq_dtype(d1, d2)
</pre></div>
</div>
<ul class="simple">
<li>Return
<code class="docutils literal notranslate"><span class="pre">TRUE</span></code>
if the two data types are equivalent, else
<code class="docutils literal notranslate"><span class="pre">FALSE.</span></code>
This may involve traversing two data type lists in parallel.
Arrays and pointers are considered equivalent.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INT size_of( dtype )
</pre></div>
</div>
<ul class="simple">
<li>Return the size in bytes of the indicated data type.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int alignment( dtype )
</pre></div>
</div>
<ul class="simple">
<li>Return the alignment requirement of the indicated data type.
0 for byte, 1 for halfword, or 3 for word alignment.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void dmp_dtype()
</pre></div>
</div>
<ul class="simple">
<li>Dump dtype area to debug file for compiler debugging purposes.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int get_array_dtype(numdim, eltype)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to an array data type record which has rank numdim
and element type eltype.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int dup_array_dtype(o_dt)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to an array data type record which duplicates
the array data type indicated by o_dt and its array descriptor.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int reduc_rank_dtype(o_dt, elem_dt, astdim, after)
</pre></div>
</div>
<ul class="simple">
<li>Return a pointer to an array data type record which has rank 1 less than
o_dt.
The dimension which is excluded is represented by the ast astdim.
If astdim is not a constant, then a run-time routine must be invoked
to collect the bounds of the other dimension; in this case, after indicates
where to append asts which calls this routine.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int rank_of(dtype)
</pre></div>
</div>
<ul class="simple">
<li>Return the rank of an array, given its array data type record.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int rank_of_sym(dtype)
</pre></div>
</div>
<ul class="simple">
<li>Return the rank of an array, given its symbol table pointer.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int lbound_of(dtype, dim)
</pre></div>
</div>
<ul class="simple">
<li>Return the lower bound of an array for the indicated dimension,
given its array data type record.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int lbound_of_sym(sptr, dim)
</pre></div>
</div>
<ul class="simple">
<li>Return the lower bound of an array for the indicated dimension,
given its symbol table pointer.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ubound_of(dtype, dim)
</pre></div>
</div>
<ul class="simple">
<li>Return the upper bound of an array for the indicated dimension,
given its array data type record.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ubound_of_sym(sptr, dim)
</pre></div>
</div>
<ul class="simple">
<li>Return the upper bound of an array for the indicated dimension,
given its symbol table pointer.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOGICAL conformable(d1, d2)
</pre></div>
</div>
<ul class="simple">
<li>Return true if the data types for two arrays are conformable
(have the same shape).  Shape is defined to be the rank and
the extents of each dimension.</li>
</ul>
</div>
<div class="section" id="symini-utility-program">
<h2>SYMINI Utility Program<a class="headerlink" href="#symini-utility-program" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>Overview<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>SYMINI is a utility program which reads the intrinsic/generic
definition file and writes a file of C code defining and
initializing the data structure for the initial symbol table,
which consists of predefined intrinsic functions and generic
names only.</p>
<p>This utility is built using Fortran compiler source files (most importantly
the symbol table access module) to guarantee that the
table it constructs is of the correct format.  The utility resides
in the <code class="docutils literal notranslate"><span class="pre">symtab.c</span></code> file using conditional assembly.  To compile it,
one must define the macro name <code class="docutils literal notranslate"><span class="pre">SYMINI</span></code>, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cc -c -DSYMINI symini.c
</pre></div>
</div>
<p>The command line to invoke symini is of the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>symini [-d] symini.n ilmtp.n -o syminidf.h pd.h [syminidf.dmp]
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="100%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>IMPORTANT</td>
</tr>
<tr class="row-even"><td>SYMINI must be run whenever an intrinsic or generic is modified,
when a change is made to the symbol table format,
or when a change to the ILM Definition File changes
ILM numbers.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="inputs">
<h3>Inputs<a class="headerlink" href="#inputs" title="Permalink to this headline">¶</a></h3>
<p>SYMINI reads two input files:</p>
<ol class="arabic">
<li><p class="first">The Intrinsic, Generic, and Predeclared
Definition File is in nroff format and
is used for Appendix III of this document.
It consists of an intrinsic definition line for each intrinsic
function supported by Fortran, followed by a generic definition line
for each generic name, followed by a predeclared definition line for
each predeclared symbol.</p>
<ul>
<li><p class="first">Intrinsic definition lines have the format:</p>
<div class="line-block">
<div class="line-block">
<div class="line">.IN name paramct atype dtype {ilm | “tc”} {pname | “-“} {arrayf}</div>
<div class="line"><br /></div>
</div>
<div class="line">name    Name of the intrinsic function.  If an intrinsic</div>
<div class="line-block">
<div class="line">name conflicts with a generic name, a “.” is</div>
<div class="line">appended to the intrinsic name.</div>
<div class="line"><br /></div>
</div>
<div class="line">paramct Number of parameters required by the intrinsic. A value</div>
<div class="line-block">
<div class="line">of 11 is used to mark the two intrinsics that convert</div>
<div class="line">to complex and double complex data types.  A value of 12</div>
<div class="line">or 13 marks the <code class="docutils literal notranslate"><span class="pre">MAX</span></code> and <code class="docutils literal notranslate"><span class="pre">MIN</span></code> intrinsics,</div>
<div class="line">which take two or more arguments.  The value 13 marks the</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">MAX</span></code> or <code class="docutils literal notranslate"><span class="pre">MIN</span></code> intrinsics that require a</div>
<div class="line">data type conversion.</div>
<div class="line"><br /></div>
</div>
<div class="line">atype   Data type of the intrinsic arguments.</div>
<div class="line-block">
<div class="line-block">
<div class="line">One of the following letters is used to</div>
<div class="line">specifiy the type:</div>
<div class="line"><br /></div>
<div class="line">W   - word (any 32-bit data type allowed).</div>
<div class="line">I   - integer.</div>
</div>
<div class="line">SI  - integer*2.</div>
<div class="line-block">
<div class="line">R   - real.</div>
<div class="line">D   - double precision.</div>
<div class="line">C   - complex.</div>
<div class="line">Z   - double complex.</div>
<div class="line">L   - logical.</div>
</div>
<div class="line">SL  - logical*2.</div>
<div class="line-block">
<div class="line">H   - character.</div>
<div class="line">N   - numeric.</div>
<div class="line">A   - any.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="line">dtype   Data type of the intrinsic return value.</div>
<div class="line-block">
<div class="line">The values allowed are the same as atype,</div>
<div class="line">except that N and A are not allowed.</div>
<div class="line"><br /></div>
</div>
<div class="line">ilm     ILM opcode number for this intrinsic.</div>
<div class="line-block">
<div class="line">If “tc” is specified instead, this</div>
<div class="line">intrinsic is a type conversion intrinsic</div>
<div class="line">and is special cased.</div>
<div class="line"><br /></div>
</div>
<div class="line">pname   Name of the external function (standard</div>
<div class="line-block">
<div class="line">entry) used when this intrinsic is passed as</div>
<div class="line">a subprogram argument.  “-” indicates that</div>
<div class="line">passing this intrinsic as an argument</div>
<div class="line">is not allowed.</div>
<div class="line"><br /></div>
</div>
<div class="line">arrayf  ILM opcode number for this intrinsic if</div>
<div class="line-block">
<div class="line">an array operand is allowed.  Zero otherwise.</div>
</div>
</div>
<div class="line-block">
<div class="line-block">
<div class="line">Generic definition lines are of the form:</div>
<div class="line"><br /></div>
<div class="line">.GN name iname rname dname cname dcname</div>
<div class="line"><br /></div>
</div>
<div class="line">name    Name of the generic.</div>
<div class="line"><br /></div>
<div class="line">xname   Names of the intrinsic functions for integer,</div>
<div class="line-block">
<div class="line">real, double precision, complex, and</div>
<div class="line">double complex arguments, respectively.</div>
<div class="line">“-” is specified when there is no such</div>
<div class="line">intrinsic.</div>
</div>
</div>
<div class="line-block">
<div class="line-block">
<div class="line">Predeclared definition lines are of the form:</div>
<div class="line"><br /></div>
<div class="line">.PD name class type</div>
<div class="line"><br /></div>
</div>
<div class="line">name  Name of the symbol</div>
<div class="line">class “generic”, “specific”, or “subroutine” (unused now)</div>
<div class="line">type  “reduction”, “array”, “scalar”, “elemental” (unused now)</div>
</div>
<div class="line-block">
<div class="line-block">
<div class="line">Each .IN, .GN, and .PD is followed by an attribute line:</div>
<div class="line"><br /></div>
<div class="line">.AT type args…</div>
<div class="line"><br /></div>
</div>
<div class="line">type  elemental, inquiry, transformational, subroutine.</div>
<div class="line">args  list of keyword names of the arguments. The names are</div>
<div class="line-block">
<div class="line">in positional order and are separated by a blank. An</div>
<div class="line">optional argument is denoted by prefixing the name with</div>
<div class="line">an ‘*’.</div>
</div>
</div>
</li>
</ul>
<ol class="arabic simple">
<li>ILM Definition File (see section 12).
This file is read just to determine the names and
opcode numbers of the ILM’s.</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="outputs">
<h3>Outputs<a class="headerlink" href="#outputs" title="Permalink to this headline">¶</a></h3>
<p>The primary output of SYMINI is the
Initial Symbol Table Definition File.
This file contains the C data definitions and initialization
code for the arrays containing the initial symbol table,
symbol names area, and hash table.</p>
<p>SYMINI also puts out the predeclared symbol definition file, containing
#define names for each predeclared symbol.  These names are of the form:
<code class="docutils literal notranslate"><span class="pre">PD_xxx</span></code>
where
<code class="docutils literal notranslate"><span class="pre">xxx</span></code>
is the predeclared name (in lower case, e.g.,
<code class="docutils literal notranslate"><span class="pre">PD_exit).</span></code></p>
<p>SYMINI also calls the ‘symdmp’ routine to write
a symbol table dump of the initial symbol table,
if desired.  The -d switch must immediately follow the program name if
This is desired.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="dinit.html">Data Initialization File</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="symini.html">Appendix VII - Intrinsics &amp; Generics</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>