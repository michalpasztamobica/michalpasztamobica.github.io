
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Parser &#8212; Flang 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Semantic Analyzer" href="semant.html" />
    <link rel="prev" title="Scanner" href="scanner.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Flang 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Parser</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="scanner.html">Scanner</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="semant.html">Semantic Analyzer</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="parser">
<h1>Parser<a class="headerlink" href="#parser" title="Permalink to this headline">¶</a></h1>
<p>The Parser (c
<em>parser.c</em>)
performs an LR(1) parse of the input source
using parse tables generated
by the Parse Table Generator utility
and tokens returned by the Scanner.
For a description of the LR parsing method used, see
references [6] and [7].</p>
<p>Refer to Appendix I for a listing of the grammar
which drives the Parser.</p>
<div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p><em>Parse Stack</em> — contains parse states and is maintained by the Parser.
When a ‘read transition’ occurs, a state is added to the stack.
When a reduction occurs, the stack is reduced by the number of
tokens on the right hand side of the reduction minus one.</p>
<p><em>Semantic Stack</em> — is maintained in parallel with the Parse Stack, and is
described in detail in section 5 since it is only used by the
Semantic Analyzer.
The variable,
<code class="docutils literal notranslate"><span class="pre">stktop</span></code>,
is used to point to the current top of the semantic stack.
Whenever a read transition occurs, the Parser adds to the
semantic stack, information on the current token (for example symbol table
pointer) which the Scanner passed to it.</p>
<p><em>Parse Tables</em> — tables created by the utility PRSTAB and which control the
parsing process.
These tables are described in the PRSTAB Maintenance and Operation
Document, [7].</p>
</div>
<div class="section" id="processing-overview">
<h2>Processing Overview<a class="headerlink" href="#processing-overview" title="Permalink to this headline">¶</a></h2>
<p>The Parser uses parse tables generated by the Parse Table Generator
utility (PRSTAB), and tokens returned by the Scanner.
As each parse reduction is made, the Semantic Analyzer is
called to perform the function associated with the
particular reduction.</p>
<p>The parser maintains the parse stack.
Semantic actions are done in parallel with reductions
involving the parse stack.
Figure 4-1 gives a pseudo-code description of the operation of the
Parser.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>loop for each statement in subprogram unit {

    parse_init();

    repeat  /\* once for each input token in the statement \*/   {
     get token;
     while (a reduction can be made using the current
            token as a look-ahead symbol)   {
         call Semantic Analyzer for this reduction;
         if (sem.ignore_stmt) {
             /\* skip this statement \*/
             goto next_statement;
         }
         replace on the parse stack, the right hand side
              symbols by the left hand side symbol for
              this reduction;

         current_state = new value determined from
                             Parse Tables;
         stack current_state on Parse Stack;
     }

     if (there is a valid read transition)  {
         current_state = new value determined using
              current_state, token, and Parse Tables;
         stack current_state information on
              Parse Stack.
     }
     else
         error;

     if (token == end_of_line) {
          if end-of-program-unit return;
          if at end-of-file { error; return; }
          break;
     }
    }
next_statement:;
}
</pre></div>
</div>
<p>Figure 4-1: Parser Operation</p>
<p>The
<code class="docutils literal notranslate"><span class="pre">parse_init</span></code>
routine sets the Parse Stack to its initial
state.
<code class="docutils literal notranslate"><span class="pre">parse_init</span></code>
calls the
<em>reset</em>
routine in the lexical analyzer to begin processing tokens
from the next statement.</p>
<p>During semantic analysis, the semantic analyzer,
while processing reductions, may detect an error for which it’s
useless to process the remaining tokens in the statement.
For example, if an executable statement appears in an interface,
there’s no need to semantically analyze the statement.
The semantic analyzer can direct the parser to ignore the
remaining portion of the statement and to move on to the
next statement;
the global variable (a flag) for effecting this is
<code class="docutils literal notranslate"><span class="pre">sem.ignore_stmt</span></code>.</p>
<p>The last token processed by the parser for a statement is
the
<em>end of line</em>
(
<code class="docutils literal notranslate"><span class="pre">TK_EOL</span></code>
)
token.
When this token is seen, the parser determines if the
<code class="docutils literal notranslate"><span class="pre">END</span></code>
statement is the current statement.
If it is, the parser returns to the caller (main)
since this represents the end of the current subprogram.</p>
</div>
<div class="section" id="parse-table-generator-prstab">
<h2>Parse Table Generator (PRSTAB)<a class="headerlink" href="#parse-table-generator-prstab" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>The main function of PRSTAB is to generate data initializations
for the Parse Tables used by the Parser.
In addition, it generates three files of C
<code class="docutils literal notranslate"><span class="pre">#define</span></code>
directives
used to coordinate the operation of the Scanner, Parser, and
Semantic Analyzer, and two files of static character information
used for error messages and debugging.
PRSTAB generates a listing and cross reference of the grammar
which is used as Appendix I of this document.</p>
</div>
<div class="section" id="inputs">
<h3>Inputs<a class="headerlink" href="#inputs" title="Permalink to this headline">¶</a></h3>
<p>PRSTAB requires two input files:</p>
<ol class="arabic">
<li><p class="first">Grammar Definition File.
This file defines the grammar used by <strong>Flang</strong>.
Reference [6] describes the format of this file;
a short example is given here:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;entry statement&gt; ::=    &lt;entry id&gt;  |
                   &lt;entry id&gt; ( ) |
                   &lt;entry id&gt; ( &lt;id list&gt; )

&lt;entry id&gt; ::=           ENTRY &lt;ident&gt;
</pre></div>
</div>
<p>If the semantic actions (see section 5) are divided into
multiple C source files, this file contains a
<code class="docutils literal notranslate"><span class="pre">.BR</span></code>
directive
at the points in the grammar where the breaks occur.</p>
</li>
<li><p class="first">Token Definition File.
This file contains one line for each terminal symbol of
the grammar (token).
Each line consists of the token name as it appears in the
grammar definition file, followed by the name which will be used
for the C constant symbol representing the token id number
within <strong>Flang</strong>.
These names must differ in the first 8 characters, and
begin with
<code class="docutils literal notranslate"><span class="pre">TK\_</span></code>.
Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;ident&gt; TK_IDENT
CALL    TK_CALL
+       TK_PLUS
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="outputs">
<h3>Outputs<a class="headerlink" href="#outputs" title="Permalink to this headline">¶</a></h3>
<p>There are six output files:</p>
<ol class="arabic simple">
<li>Parse Table Definition File.
This file contains the C data definitions and initialization
code for the Parse Tables.
It is included directly into the Parser source module.</li>
<li>Token Id Number Definition File.
This file contains a series of
<code class="docutils literal notranslate"><span class="pre">#define</span></code>
directives for the token
id numbers.
The symbol names used are those specified in the Token Definition File.</li>
<li>Semantic Actions Definition File.
This file contains a series of
<code class="docutils literal notranslate"><span class="pre">#define</span></code>
directives for the
semantic action case labels (see section 5).
There is one definition for each production of the grammar.
The names for these symbols are constructed from the
name of the symbol on the left hand side of each production,
using an algorithm described in [6].</li>
<li>Non-terminal Number Definition File.
This file contains a series of
<code class="docutils literal notranslate"><span class="pre">#define</span></code>
directives for the grammar’s non-terminal symbols.  The names for these
symbols are of the form
<code class="docutils literal notranslate"><span class="pre">NT_&lt;name&gt;</span></code>
where name is constructed from the symbol’s name in the grammar in an
obvious fashion.</li>
<li>Token Name Definition File.
This file contains a statically initialized array indexed by terminal and
non-terminal number giving the name (exactly as in the grammar) of each
terminal and non-terminal symbol.  It is used for error messages and
debugging.</li>
<li>Grammar Listing and Cross Reference File.
Lists grammar with alphabetic cross reference of grammar symbols
at end.  Used to create Appendix I of this document.</li>
</ol>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="scanner.html">Scanner</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="semant.html">Semantic Analyzer</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>