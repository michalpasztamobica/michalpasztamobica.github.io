

**********************
X86-64 ILI Definitions
**********************


===========================
Key to ILI Template Listing
===========================

*ILI Operand Types:*

.. code-block:: none

   irlnk

link to previous ili with result type ir.

.. code-block:: none

   splnk

link to previous ili with result type sp.

.. code-block:: none

   dplnk

link to previous ili with result type dp.

.. code-block:: none

   arlnk

link to previous ili with result type ar.

.. code-block:: none

   krlnk

link to previous ili with result type kr.

.. code-block:: none

   qplnk

link to previous ili with result type qp.

.. code-block:: none

   cslnk

link to previous ili with result type cs.

.. code-block:: none

   cdlnk

link to previous ili with result type cd.

.. code-block:: none

   cqlnk

link to previous ili with result type cq.

.. code-block:: none

   128lnk

link to previous ili with result type 128.

.. code-block:: none

   256lnk

link to previous ili with result type 256.

.. code-block:: none

   512lnk

link to previous ili with result type 512.

.. code-block:: none

   x87lnk

link to previous ili with result type x87.

.. code-block:: none

   lnk

link to previous ili with result type lnk.

.. code-block:: none

   ir

integer register number (for x86-64, one of the general purpose registers).

.. code-block:: none

   sp

floating-point register number.

.. code-block:: none

   dp

double-precision register.

.. code-block:: none

   kr

64 bit integer register.

.. code-block:: none

   cs

single(4+4 bytes) precision complex register.

.. code-block:: none

   cd

double(8+8 bytes) precision complex register.

.. code-block:: none

   cq

16x2 bytes complex register.

.. code-block:: none

   qp

16x2 bytes register.

.. code-block:: none

   128

128 bits register.

.. code-block:: none

   256

256 bits register.

.. code-block:: none

   512

512 bits register.

.. code-block:: none

   x87

80-bit x87 register.

.. code-block:: none

   ar

Address register (for x86-64, one of the general purpose registers).

.. code-block:: none

   stc

16 bit constant.  May be interpreted as either signed or unsigned depending
on the machine instruction operand which uses it.

.. code-block:: none

   nme

pointer to names table entry for a load or store.

.. code-block:: none

   sym

symbol table pointer.

*ILI Types (1st attribute of each ILI):*

``arth``
   arithmetic operation.

``branch``
   branch operation.

``cons``
   constant.

``load``

``store``

``define``
   register define.

``proc``
   function call.

``move``
   register move.

``other``

*Commutivity attribute (2nd attribute of each ILI):*
.CM comm
Commutative operation.
.CM null
Not commutative.

*ILI result type (3rd attribute of each ILI):*
.RT lnk
no result, but ili is pointed-to by link.
.RT ir
result goes into an integer register.
.RT sp
result goes into a floating-point register.
.RT dp
double-precision floating-point.
.RT ar
address register result.
.RT trm
this ili does not produce a value and cannot be pointed to by any
link operand of another ili.

*Other ILI Attributes:*
.IA dom
specifies that this ili is a dominator ili.
.IA cse
specifies that this ili is a candidate for constant subexpression elimination.
An ili is not allowed to have both the cse and the dom attributes.
.IA ssenme
indicates that this is an sse operation with operand 1 an arlnk field and
operand 3 a nme field.

*Code Generator ILI Attributes (x86-64 compilers):*
.CA notCG
ili opcode never used within the code generator, though it may process
such an ili while linearizing the shared ili form.
.CA CGonly
ili is created and used only by the code generator.
.CA notAILI
opcode which should not appear in the AILI (set automatically if notCG
is specified).
.CA replaceby
specifies opcode which replaces this one during linearization.
.CA terminal
specifies ili for which code_gen is called directly from cgmain.
.CA move
Indicates aili which can be eliminated if src1 is the same as dest.
.CA conditional_branch
.CA asm_special
during generation of assembly code by the code generator,
this opcode is treated as a special case.
.CA asm_nop
No assembly output is required for this aili.



===============
ILI Definitions
===============

``ICON``
   32-bit integer constant.

   The value is pulled from the CONVAL2 field of sym.

   *Attributes*: cons null ir cse
   .CG "mov" 'l'*direct* lat(1)



``ACON``
   Load address constant into address register.
   \'sym' must be a symtab ptr to an address constant.

   *Attributes*: cons null ar cse
   .CG notAILI

``ACON_PIC_EXTRN``
   Address constant used for PIC generation.  It represents the load
   of the address of an external variable from the GOTPCREL table.
   \'sym' is the symbol table pointer for the external variable, NOT
   an address constant symbol.

   *Attributes*: cons null ar cse
   .CG CGonly "mov" 'q' asm_special*direct* lat(1)



#. **ACON_STATIC** sym    *Type*: *sym*

   Used in the linear ili to represent an address constant with
   a full 64-bit offset.  The first sym points to a static or external
   variable, or a label, and the second to a symbol table 64-bit integer constant.

   *Attributes*: cons null ar cse
   .CG CGonly "lea" 'q'*direct* lat(2)



``ACON_TLS``
   Load a TLS immediate address
   \'sym' must be a symtab ptr to an address constant.

   *Attributes*: cons null ar
   .CG CGonly "lea" 'q' asm_special*direct* lat(1)



``ACON_TLS_PIC``
   Load a TLS address that is stored as a PIC value
   \'sym' is the symbol table pointer for the external variable, NOT
   an address constant symbol.

   *Attributes*: cons null ar
   .CG CGonly "lea" 'q' asm_special*direct* lat(1)



#. **ACON_AUTO** sym    *Type*: *sym*

   Same as ACON_STATIC, but the first sym is a stack variable.

   *Attributes*: cons null ar cse
   .CG CGonly "lea" 'q'*direct* lat(2)



``KCON``
   64-bit integer constant.  'sym' is a symbol table constant of type
   DT_INT or DT_INT8.

   *Attributes*: cons null kr cse
   .CG "mov" 'q'*direct* lat(1)



#. **ACEXT** nme    *Type*: *sym*

   Label address.
   \'sym' is address constant for label symbol.
   \'nme' is zero.

   *Attributes*: cons null ar cse
   .CG "mov"*direct* lat(1)



``FCON``
   Single-precision floating-point constant.

   *Attributes*: cons null sp cse
   .CG "movss" move avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



``DCON``
   Double-precision floating-point constant.

   *Attributes*: cons null dp cse
   .CG "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``SCMPLXCON``
   Single-precision complex constant.

   *Attributes*: cons null cs cse
   .CG "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``DCMPLXCON``
   Double-precision complex constant.

   *Attributes*: cons null cd cse
   .CG "movapd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LD** nme stc    *Type*: *arlnk*

   \'arlnk' points to an address expression.

   \'nme' points to the names table entry of the variable being referenced.

   \'stc' size modifier of the memory operation - one of the MSZ\_ macros
   defined in ili.h.
   For the code generator, possible values are:
           MSZ_SBYTE	signed byte
           MSZ_UBYTE	unsigned byte
           MSZ_SHWORD	signed half-word
           MSZ_UHWORD	unsigned half-word
           MSZ_SWORD	signed word (32-bit)
           MSZ_UWORD	unsigned word

   *Attributes*: load null ir
   .CG "mov" move*direct* lat(1)

   *ld* direct lat(3)

   *st* direct lat(3)



#. **LDSP** nme stc    *Type*: *arlnk*

   Load single-precision floating value.  'stc' is not used.

   *Attributes*: load null sp
   .CG "movss" move avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



#. **LDDP** nme stc    *Type*: *arlnk*

   Load double precision value.  'stc' is not used.

   *Attributes*: load null dp
   .CG "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LDSCMPLX** nme stc    *Type*: *arlnk*

   Load single precision complex value.  'stc' is not used.

   *Attributes*: load null cs
   .CG "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LDDCMPLX** nme stc    *Type*: *arlnk*

   Load double precision complex value.  'stc' is not used.

   *Attributes*: load null cd
   .CG "movupd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LDQ** nme stc    *Type*: *arlnk*

   Load an __m128 value.  'stc' is not used.

   *Attributes*: load null dp
   .CG "movapd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LDQU** nme stc    *Type*: *arlnk*

   Load an unaligned __m128 value.  'stc' is not used.

   *Attributes*: load null dp
   .CG "movupd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LD256** nme stc    *Type*: *arlnk*

   Load an __m256 value.  'stc' is not used.
   May generate a LD256U.

   *Attributes*: load null dp
   .CG "vmovapd" 'y' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LD256A** nme stc    *Type*: *arlnk*

   Load an aligned __m256 value.  'stc' is not used.
   Will generate the aligned case for LD256.

   *Attributes*: load null dp
   .CG notAILI

#. **LD256U** nme stc    *Type*: *arlnk*

   Load an unaligned __m256 value.  'stc' is not used.

   *Attributes*: load null dp
   .CG "vmovupd" 'y' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LD512** nme stc    *Type*: *arlnk*

   Load an __m512 value.  'stc' is not used.

   *Attributes*: load null 512
   .CG "vmovupd" 'z' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **LDA** nme    *Type*: *arlnk*

   Load address register from memory location whose address
   is represented by op1.
   For x86-64 compilers, LDA's are replaced by LDKR's by cgoptim1.

   *Attributes*: load null ar
   .CG notAILI

#. **LDKR** nme stc    *Type*: *arlnk*

   Load 64 bit integer value.  'stc' is not used.

   *Attributes*: load null kr
   .CG notAILI

``INEG``
   Signed integer32 negate.

   *Attributes*: arth null ir cse
   .CG memdest ccarith "neg" 'l'*direct* lat(4:1)



``UINEG``
   Unsigned integer32 negate.

   *Attributes*: arth null ir cse
   .CG notCG replaceby INEG

``KNEG``
   Signed integer64 negate.

   *Attributes*: arth null kr cse
   .CG memdest ccarith "neg" 'q'*direct* lat(4:1)



``UKNEG``
   Unsigned integer64 negate.

   *Attributes*: arth null kr cse
   .CG notCG replaceby KNEG

``FNEG``
   Real\*4 negation.  This LILI is replaced by an FXOR LILI in
   cgoptim1.c:lili_peephole_opts_2().

   *Attributes*: arth null sp cse
   .CG notAILI

``DNEG``
   Real\*8 negation.  This LILI is replaced by a DXOR LILI in
   cgoptim1.c:lili_peephole_opts_2().

   *Attributes*: arth null dp cse
   .CG notAILI

``SCMPLXNEG``
   Complex\*8 negation.  This LILI is replaced by an SCMPLXXOR LILI in
   cgoptim1.c:lili_peephole_opts_2().

   *Attributes*: arth null cs cse
   .CG notAILI

``DCMPLXNEG``
   Complex\*16 negation.  This LILI is replaced by a DCMPLXXOR LILI in
   cgoptim1.c:lili_peephole_opts_2().

   *Attributes*: arth null cd cse
   .CG notAILI

#. **FXOR** splnk    *Type*: *splnk*

   This only appears in the LILIs and AILIs, not in shared ILIs.  It is
   generated in cgoptim1.c:lili_peephole_opts_2() by transforming
   FNEG( op1 ) into an FXOR LILI in order to negate 'op1' by XORing its
   sign bit with 1.  This ILI is specified as non-commutative
   (i.e. 'null', not 'comm') for reasons explained in that function.

   *Attributes*: arth null sp cse
   .CG CGonly "xorps" sse_avx

#. **DXOR** dplnk    *Type*: *dplnk*

   This only appears in the LILIs and AILIs, not in shared ILIs.  It is
   generated in cgoptim1.c:lili_peephole_opts_2() by transforming
   DNEG( op1 ) into a DXOR LILI in order to negate 'op1' by XORing its
   sign bit with 1.  This ILI is specified as non-commutative
   (i.e. 'null', not 'comm') for reasons explained in that function.

   *Attributes*: arth null dp cse
   .CG CGonly "xorpd" sse_avx*double* fmul lat(5:3)



#. **SCMPLXXOR** cslnk    *Type*: *cslnk*

   This only appears in the LILIs and AILIs, not in shared ILIs.  It is
   generated in cgoptim1.c:lili_peephole_opts_2() by transforming
   SCMPLXNEG( op1 ) into an SCMPLXXOR LILI in order to negate 'op1' by
   XORing its sign bits with 1.  This ILI is specified as non-commutative
   (i.e. 'null', not 'comm') for reasons explained in that function.

   *Attributes*: arth null cs cse
   .CG CGonly "xorps" sse_avx

#. **DCMPLXXOR** cdlnk    *Type*: *cdlnk*

   This only appears in the LILIs and AILIs, not in shared ILIs.  It is
   generated in cgoptim1.c:lili_peephole_opts_2() by transforming
   DCMPLXNEG( op1 ) into a DCMPLXXOR LILI in order to negate 'op1' by
   XORing its sign bits with 1.  This ILI is specified as non-commutative
   (i.e. 'null', not 'comm') for reasons explained in that function.

   *Attributes*: arth null cd cse
   .CG CGonly "xorpd" sse_avx

``SCMPLXCONJG``
   Single-precision complex conjugate.

   *Attributes*: arth null cs cse
   .CG "xorps" sse_avx asm_special

``DCMPLXCONJG``
   Double-precision complex conjugate.

   *Attributes*: arth null cd cse
   .CG "xorpd" sse_avx asm_special

``IABS``
   Integer absolute value.  Expanded into shift-xor-sub sequence.

   *Attributes*: arth null ir cse
   .CG notCG

``KABS``
   Integer64 absolute value.  Expanded into shift-xor-sub sequence.

   *Attributes*: arth null kr cse
   .CG notCG

``FABS``
   Real (single-precision) absolute value.

   *Attributes*: arth null sp cse
   .CG notAILI

#. **FAND** splnk    *Type*: *splnk*

   This is generated either in iliutil.c:addarth() to implement an
   approximate scalar FSQRT or in cglinear.c:gen_lilis() to compute
   FABS( op1 ) by clearing 'op1's sign bit.  This ILI is specified as
   non-commutative (i.e. 'null', not 'comm') for the same reason that
   FXOR is non-commutative.

   *Attributes*: arth null sp cse
   .CG "andps" sse_avx*double* fmul lat(5:3)



``DABS``
   Double precision absolute value.

   *Attributes*: arth null dp cse
   .CG notAILI

#. **DAND** dplnk    *Type*: *dplnk*

   This only appears in the LILIs and AILIs, not in shared ILIs.  It is
   generated in cglinear.c:gen_lilis() by transforming a DABS( op1 ) ILI
   into a DAND LILI which computes the absolute value of 'op1' by
   clearing its sign bit.  This ILI is specified as non-commutative
   (i.e. 'null', not 'comm') for the same reason that DXOR is
   non-commutative.

   *Attributes*: arth null dp cse
   .CG CGonly "andpd" sse_avx*direct* fadd lat(5:3)



``NOT``
   32 bit bitwise not.

   *Attributes*: arth null ir cse
   .CG memdest "not" 'l'*direct* lat(4:1)



``UNOT``
   Unsigned bitwise negation of 32 bit bitwise not.

   *Attributes*: arth null ir cse
   .CG notCG replaceby NOT

``KNOT``
   64 bit bitwise not.

   *Attributes*: arth null kr cse
   .CG memdest "not" 'q'*direct* lat(4:1)



``UKNOT``
   64 bit bitwise not.

   *Attributes*: arth null kr cse
   .CG notCG replaceby KNOT

``FSQRT``
   Single-precision floating-point square root.

   *Attributes*: arth null sp cse
   .CG "sqrtss" avx_special*direct* fmul lat(21:19)



``DSQRT``
   Double-precision square root.

   *Attributes*: arth null dp cse
   .CG "sqrtsd" avx_special*direct* fmul lat(29:27)



``FRSQRT``
   Single-precision floating-point reciprocal square root.
   1.0/sqrt(x) -- will be replaced by the Newton's appx via the
   ALT field

   *Attributes*: arth null sp cse
   .CG notCG

``RCPSS``
   Single-precision approximation to reciprocal.

   *Attributes*: arth null sp cse
   .CG "rcpss" avx_special*direct* fmul lat(21:19)



``RSQRTSS``
   Single-precision approximation to reciprocal square root.

   *Attributes*: arth null sp cse
   .CG "rsqrtss" avx_special*direct* fmul lat(21:19)



#. **CMPNEQSS** splnk    *Type*: *splnk*

   Used for single-precision square root approximation.

   *Attributes*: arth null sp cse
   .CG "cmpneqss" sse_avx

``FNSIN``
   Utility ili: only referenced by the 'alt' field of an FSIN ili;
   always points to an FSINCOS ili.

   *Attributes*: arth null sp cse
   .CG notAILI

``DNSIN``
   Utility ili: only referenced by the 'alt' field of an DSIN ili;
   always points to an DSINCOS ili.

   *Attributes*: arth null dp cse
   .CG notAILI

``FSIN``
   Single precision floating point sine.  Implemented as a function call.

   *Attributes*: arth null sp cse
   .CG notAILI

``DSIN``
   Double precision sine.  Implemented as a function call.

   *Attributes*: arth null dp cse
   .CG notAILI

``FNCOS``
   Utility ili: only referenced by the 'alt' field of an FCOS ili;
   always points to an FSINCOS ili.

   *Attributes*: arth null sp cse
   .CG notAILI

``DNCOS``
   Utility ili: only referenced by the 'alt' field of an DCOS ili;
   always points to an DSINCOS ili.

   *Attributes*: arth null dp cse
   .CG notAILI

``FCOS``
   Single precision floating point cosine.  Implemented as library call.

   *Attributes*: arth null sp cse
   .CG notAILI

``DCOS``
   Double precision cosine.  Implemented as library call.

   *Attributes*: arth null dp cse
   .CG notAILI

``FSINCOS``
   Used to implement SINCOS optimization (single precision).

   *Attributes*: arth null sp cse
   .CG notAILI

``DSINCOS``
   Used to implement SINCOS optimization (double precision).

   *Attributes*: arth null dp cse
   .CG notAILI

``FTAN``
   Single-precision floating-point tangent.

   *Attributes*: arth null sp cse
   .CG notCG

``DTAN``
   Double-precision tangent.

   *Attributes*: arth null dp cse
   .CG notCG

``FLOG``
   Single-precision floating-point natural logarithm.

   *Attributes*: arth null sp cse
   .CG notCG

``DLOG``
   Double-precision natural logarithm.

   *Attributes*: arth null dp cse
   .CG notCG

``FLOG10``
   Single-precision floating-point common logarithm.

   *Attributes*: arth null sp cse
   .CG notCG

``DLOG10``
   Double-precision common logarithm.

   *Attributes*: arth null dp cse
   .CG notCG

``FEXP``
   Single-precision floating-point exponential.

   *Attributes*: arth null sp cse
   .CG notCG

``DEXP``
   Double-precision exponential.

   *Attributes*: arth null dp cse
   .CG notCG

``FACOS``
   Single-precision floating-point arccosine.

   *Attributes*: arth null sp cse
   .CG notCG

``DACOS``
   Double-precision  arccosine.

   *Attributes*: arth null dp cse
   .CG notCG

``FASIN``
   Single-precision floating-point arcsine.

   *Attributes*: arth null sp cse
   .CG notCG

``DASIN``
   Double-precision  arcsine.

   *Attributes*: arth null dp cse
   .CG notCG

``FATAN``
   Single-precision floating-point arctangent.

   *Attributes*: arth null sp cse
   .CG notCG

``DATAN``
   Double-precision  arctangent.

   *Attributes*: arth null dp cse
   .CG notCG

#. **FATAN2** splnk    *Type*: *splnk*

   Single-precision floating-point two-argument arctangent.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DATAN2** dplnk    *Type*: *dplnk*

   Double-precision two-argument arctangent.

   *Attributes*: arth null dp cse
   .CG notCG

``FSINH``
   Single-precision floating-point hyperbolic sin

   *Attributes*: arth null sp cse
   .CG notCG

``DSINH``
   Double-precision hyperbolic sin

   *Attributes*: arth null dp cse
   .CG notCG

``FCOSH``
   Single-precision floating-point hyperbolic cos

   *Attributes*: arth null sp cse
   .CG notCG

``DCOSH``
   Double-precision hyperbolic cos

   *Attributes*: arth null dp cse
   .CG notCG

``FTANH``
   Single-precision floating-point hyperbolic tan

   *Attributes*: arth null sp cse
   .CG notCG

``DTANH``
   Double-precision hyperbolic tan

   *Attributes*: arth null dp cse
   .CG notCG

#. **FNEWT** splnk splnk    *Type*: *splnk*

   Single-precision floating-point multiply used for single divides.
   Not used by the x86-64 compilers.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DNEWT** dplnk dplnk    *Type*: *dplnk*

   Double-precision floating-point multiply used for double divides.
   Not used by the x86-64 compilers.

   *Attributes*: arth null dp cse
   .CG notCG

``NINT``
   Real NINT.

   *Attributes*: arth null ir cse
   .CG notCG

``KNINT``
   Real NINT.

   *Attributes*: arth null kr cse
   .CG notCG

``IDNINT``
   Double NINT.

   *Attributes*: arth null ir cse
   .CG notCG

``KIDNINT``
   Double NINT.

   *Attributes*: arth null kr cse
   .CG notCG

#. **ISIGN** irlnk    *Type*: *irlnk*

   Integer sign intrinsic.

   *Attributes*: arth null ir cse
   .CG notCG

#. **SIGN** splnk    *Type*: *splnk*

   Real sign.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DSIGN** dplnk    *Type*: *dplnk*

   Double sign.

   *Attributes*: arth null dp cse
   .CG notCG

#. **IDIM** irlnk    *Type*: *irlnk*

   Integer dim intrinsic.

   *Attributes*: arth null ir cse
   .CG notCG

#. **FDIM** splnk    *Type*: *splnk*

   Real dim.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DDIM** dplnk    *Type*: *dplnk*

   Double dim.

   *Attributes*: arth null dp cse
   .CG notCG

``FFLOOR``
   Real FLOOR.

   *Attributes*: arth null sp cse
   .CG "roundss" sse_avx

``DFLOOR``
   Double FLOOR.

   *Attributes*: arth null dp cse
   .CG "roundsd" sse_avx

``FCEIL``
   Real CEILING.

   *Attributes*: arth null sp cse
   .CG "roundss" sse_avx

``DCEIL``
   Double CEILING.

   *Attributes*: arth null dp cse
   .CG "roundsd" sse_avx

``AINT``
   Single precision trunction.

   *Attributes*: arth null sp cse
   .CG notAILI

``DINT``
   Double precision trunction.

   *Attributes*: arth null dp cse
   .CG notAILI

``SCMPLXEXP``
   Single-precision complex exponential.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXEXP``
   Double-precision complex exponential.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXCOS``
   Single-precision complex cosine.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXCOS``
   Double-precision complex cosine.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXSIN``
   Single-precision complex sine.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXSIN``
   Double-precision complex sine.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXTAN``
   Single-precision complex tangent.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXTAN``
   Double-precision complex tangent.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXACOS``
   Single-precision complex arccosine.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXACOS``
   Double-precision complex arccosine.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXASIN``
   Single-precision complex arcsine.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXASIN``
   Double-precision complex arcsine.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXATAN``
   Single-precision complex arctangent.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXATAN``
   Double-precision complex arctangent.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXCOSH``
   Single-precision complex hyperbolic cos.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXCOSH``
   Double-precision complex hyperbolic cos.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXSINH``
   Single-precision complex hyperbolic sin.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXSINH``
   Double-precision complex hyperbolic sin.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXTANH``
   Single-precision complex hyperbolic tan.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXTANH``
   Double-precision complex hyperbolic tan.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXLOG``
   Single-precision complex natural logarithm.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXLOG``
   Double-precision complex natural logarithm.

   *Attributes*: arth null cd cse
   .CG notCG

``SCMPLXSQRT``
   Single-precision complex square root.

   *Attributes*: arth null cs cse
   .CG notCG

``DCMPLXSQRT``
   Double-precision complex square root.

   *Attributes*: arth null cd cse
   .CG notCG

#. **SCMPLXPOW** cslnk    *Type*: *cslnk*

   Single-precision complex raised to a single-precision complex power.

   *Attributes*: arth null cs cse
   .CG notCG

#. **DCMPLXPOW** cdlnk    *Type*: *cdlnk*

   Double-precision complex raised to a double-precision complex power.

   *Attributes*: arth null cd cse
   .CG notCG

#. **SCMPLXPOWI** irlnk    *Type*: *cslnk*

   Single-precision complex raised to an integer power.

   *Attributes*: arth null cs cse
   .CG notCG

#. **DCMPLXPOWI** irlnk    *Type*: *cdlnk*

   Double-precision complex raised to an integer power.

   *Attributes*: arth null cd cse
   .CG notCG

#. **SCMPLXPOWK** krlnk    *Type*: *cslnk*

   Single-precision complex raised to an integer power.

   *Attributes*: arth null cs cse
   .CG notCG

#. **DCMPLXPOWK** krlnk    *Type*: *cdlnk*

   Double-precision complex raised to an integer power.

   *Attributes*: arth null cd cse
   .CG notCG


``ITOUI``
   Integer to unsigned integer conversion.
   Treated as a nop by linearization.

   *Attributes*: arth null ir cse
   .CG notCG

``UITOI``
   Unsigned integer to integer conversion.
   Treated as a nop by linearization.

   *Attributes*: arth null ir cse
   .CG notCG


``IKMV``
   Signed integer\*4 to signed or unsigned integer\*8 type conversion.

   *Attributes*: move null kr cse
   .CG asm_special "movslq" 'q'*ld* direct lat(1)

   *st* direct lat(4)

   *direct* lat(1)



#. **PIKMV** xmm nme    *Type*: *arlnk*

   Convert 'N' packed signed integer\*4 values from 'arlnk' into 'N'
   packed signed or unsigned integer\*8 values in 'xmm', where 'N' is 2, 4
   or 8 if 'xmm' is an xmm (>= SSE4.1), ymm (>= AVX2) or zmm (AVX-512)
   register respectively.

   *Attributes*: other null trm ssenme
   .CG terminal "pmovsxdq" sse_avx

#. **PIKMVX** xmm    *Type*: *xmm*

   Convert 'N' packed signed integer\*4 values from 'xmm1' (an xmm or ymm
   register) into 'N' packed signed or unsigned integer\*8 values in
   'xmm2' (an xmm, ymm or zmm register), where 'N' is 2, 4 or 8 if 'xmm2'
   is an xmm (>= SSE4.1), ymm (>= AVX2) or zmm (AVX-512) register
   respectively.

   *Attributes*: other null trm
   .CG terminal "pmovsxdq" avx_special


``UIKMV``
   Unsigned integer\*4 to signed or unsigned integer\*8 type conversion.

   *Attributes*: move null kr cse
   .CG asm_special "movl" 'q'

#. **PUIKMV** xmm nme    *Type*: *arlnk*

   Convert 'N' packed unsigned integer\*4 values from 'arlnk' into 'N'
   packed signed or unsigned integer\*8 values in 'xmm', where 'N' is 2, 4
   or 8 if 'xmm' is an xmm (>= SSE4.1), ymm (>= AVX2) or zmm (AVX-512)
   register respectively.

   *Attributes*: other null trm ssenme
   .CG terminal "pmovzxdq" sse_avx

#. **PUIKMVX** xmm    *Type*: *xmm*

   Convert 'N' packed unsigned integer\*4 values from 'xmm1' (an xmm or
   ymm register) into 'N' packed signed or unsigned integer\*8 values in
   'xmm2' (an xmm, ymm or zmm register), where 'N' is 2, 4 or 8 if 'xmm2'
   is an xmm (>= SSE4.1), ymm (>= AVX2) or zmm (AVX-512) register
   respectively.

   *Attributes*: other null trm
   .CG terminal "pmovzxdq" avx_special


``KIMV``
   Signed or unsigned integer\*8 to signed or unsigned integer\*4 type
   conversion with truncation.  Note, we mustn't treat this as a move for
   the purposes of register allocation.

   *Attributes*: move null ir cse
   .CG "mov" 'l'*direct* lat(1)

   *ld* direct lat(3)

   *st* direct lat(3)



#. **PKIMVX** xmm    *Type*: *xmm*

   Truncate 'N' packed signed or unsigned integer\*8 values from 'xmm1'
   (an xmm, ymm or zmm register) into 'N' packed signed or unsigned
   integer\*4 values in 'xmm2' (an xmm or ymm register), where 'N' is 2, 4
   or 8 if 'xmm1' is an xmm, ymm or zmm register respectively.  This
   instruction requires support for AVX-512F and AVX-512VL, and the
   source operand must be a register (unusually for AVX instructions the
   destination can be a memory operand!).

   *Attributes*: other null trm
   .CG terminal "vpmovqd" avx_only avx_special


``IAMV``
   Move an integer reg into an address reg.
   Sign extension required?

   *Attributes*: move null ar cse
   .CG notCG replaceby IKMV

``AIMV``
   Move an address register to a integer register.
   Truncation required.

   *Attributes*: move null ir cse
   .CG notCG replaceby KIMV

``KAMV``
   Move an 64 bit integer reg into an address reg.
   Treated as a nop by Linearize.

   *Attributes*: move null ar cse
   .CG notCG

``AKMV``
   Move an address register to a 64 bit integer register.
   Treated as a nop in Linearize.

   *Attributes*: move null kr cse
   .CG notCG


``MOVSB``
   Load a signed byte into a 32 or 64 bit register.

   *Attributes*: move null ir
   .CG CGonly asm_special "movsb" 'l'

``MOVSBQ``
   Load a signed byte into a 64 bit register.  (JHM, 1 Oct 2013: Redundant?)

   *Attributes*: move null kr
   .CG CGonly asm_special "movsb" 'q'

#. **PMOVSB** xmm nme    *Type*: *arlnk*

   Convert 'N' packed signed byte values from 'arlnk' into 'N' packed
   integer\*4 values in 'xmm', where 'N' is 4, 8 or 16 if 'xmm' is an xmm
   (>= SSE4.1), ymm (>= AVX2) or zmm (AVX-512) register respectively.

   *Attributes*: other null trm ssenme
   .CG terminal "pmovsxbd" sse_avx

#. **PMOVSBX** xmm    *Type*: *xmm*

   Convert 'N' packed signed byte values from 'xmm1' (an xmm register)
   into 'N' packed integer\*4 values in 'xmm2' (an xmm, ymm or zmm
   register), where 'N' is 4, 8 or 16 if 'xmm2' is an xmm (>= SSE4.1),
   ymm (>= AVX2) or zmm (AVX-512) register respectively.

   *Attributes*: other null trm
   .CG terminal "pmovsxbd" avx_special


``MOVZB``
   Load an unsigned byte into a 32 or 64 bit register.

   *Attributes*: move null ir
   .CG CGonly asm_special "movzb" 'l'

``MOVZBQ``
   Load an unsigned byte into a 64 bit register.  (JHM, 1 Oct 2013: Redundant?)

   *Attributes*: move null kr
   .CG CGonly asm_special "movzb" 'q'

#. **PMOVZB** xmm nme    *Type*: *arlnk*

   Convert 'N' packed unsigned byte values from 'arlnk' into 'N' packed
   integer\*4 values in 'xmm', where 'N' is 4, 8 or 16 if 'xmm' is an xmm
   (>= SSE4.1), ymm (>= AVX2) or zmm (AVX-512) register respectively.

   *Attributes*: other null trm ssenme
   .CG terminal "pmovzxbd" sse_avx

#. **PMOVZBX** xmm    *Type*: *xmm*

   Convert 'N' packed unsigned byte values from 'xmm1' (an xmm register)
   into 'N' packed integer\*4 values in 'xmm2' (an xmm, ymm or zmm
   register), where 'N' is 4, 8 or 16 if 'xmm2' is an xmm (>= SSE4.1),
   ymm (>= AVX2) or zmm (AVX-512) register respectively.

   *Attributes*: other null trm
   .CG terminal "pmovzxbd" avx_special


``MOVSW``
   Load a signed integer\*2 value into a 32 or 64 bit register.

   *Attributes*: move null ir
   .CG CGonly asm_special "movsw" 'l'

``MOVSWQ``
   Load a signed integer\*2 value into a 64 bit register.
   (JHM, 1 Oct 2013: Redundant?)

   *Attributes*: move null kr
   .CG CGonly asm_special "movsw" 'q'

#. **PMOVSW** xmm nme    *Type*: *arlnk*

   Convert 'N' packed signed integer\*2 values from 'arlnk' into 'N'
   packed integer\*4 values in 'xmm', where 'N' is 4, 8 or 16 if 'xmm' is
   an xmm (>= SSE4.1), ymm (>= AVX2) or zmm (AVX-512) register
   respectively.

   *Attributes*: other null trm ssenme
   .CG terminal "pmovsxwd" sse_avx

#. **PMOVSWX** xmm    *Type*: *xmm*

   Convert 'N' packed signed integer\*2 values from 'xmm1' (an xmm or ymm
   register) into 'N' packed integer\*4 values in 'xmm2' (an xmm, ymm or
   zmm register), where 'N' is 4, 8 or 16 if 'xmm2' is an xmm (>= SSE4.1),
   ymm (>= AVX2) or zmm (AVX-512) register respectively.

   *Attributes*: other null trm
   .CG terminal "pmovsxwd" avx_special


``MOVZW``
   Load an unsigned integer\*2 value into a 32 or 64 bit register.

   *Attributes*: move null ir
   .CG CGonly asm_special "movzw" 'l'

``MOVZWQ``
   Load an unsigned integer\*2 value into a 64 bit register.
   (JHM, 1 Oct 2013: Redundant?)

   *Attributes*: move null kr
   .CG CGonly asm_special "movzw" 'q'

#. **PMOVZW** xmm nme    *Type*: *arlnk*

   Convert 'N' packed unsigned integer\*2 values from 'arlnk' into 'N'
   packed integer\*4 values in 'xmm', where 'N' is 4, 8 or 16 if 'xmm' is
   an xmm (>= SSE4.1), ymm (>= AVX2) or zmm (AVX-512) register
   respectively.

   *Attributes*: other null trm ssenme
   .CG terminal "pmovzxwd" sse_avx

#. **PMOVZWX** xmm    *Type*: *xmm*

   Convert 'N' packed unsigned integer\*2 values from 'xmm1' (an xmm or
   ymm register) into 'N' packed integer\*4 values in 'xmm2' (an xmm, ymm
   or zmm register), where 'N' is 4, 8 or 16 if 'xmm2' is an xmm (>= SSE4.1),
   ymm (>= AVX2) or zmm (AVX-512) register respectively.

   *Attributes*: other null trm
   .CG terminal "pmovzxwd" avx_special


``FLOAT``
   Integer\*4 to real\*4 type conversion.

   *Attributes*: arth null sp cse
   .CG "cvtsi2ss" 'l' sse_avx asm_special

``PFLOAT``
   Packed integer\*4 to real\*4 type conversion.  ONLY USED ON x86-64.
   WE SHOULD DELETE THIS AND USE PSFLOAT INSTEAD.

   *Attributes*: arth null sp cse
   .CG "cvtdq2ps" 'l' sse_avx asm_special

#. **PSFLOAT** xmm nme    *Type*: *arlnk*

   Convert 4 integer\*4 values from 'arlnk' into 4 real\*4 values in 'xmm'.

   *Attributes*: other null trm ssenme
   .CG terminal "cvtdq2ps" sse_avx

#. **PSFLOATX** xmm    *Type*: *xmm*

   Convert 4 integer\*4 values from 'xmm1' into 4 real\*4 values in 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "cvtdq2ps" sse_avx


``FLOATU``
   Unsigned integer\*4 to real\*4 type conversion.
   Equivalent to UIKMV + FLOATK combination.

   *Attributes*: arth null sp cse
   .CG notCG

``FLOATK``
   Integer\*8 to real\*4 type conversion.

   *Attributes*: arth null sp cse
   .CG "cvtsi2ss" 'q' avx_special

``FLOATUK``
   Unsigned integer\*8 to real\*4 type conversion.

   *Attributes*: arth null sp cse
   .CG notAILI


``DFLOAT``
   Integer\*4 to real\*8 type conversion.

   *Attributes*: arth null dp cse
   .CG "cvtsi2sd" 'l' sse_avx asm_special*ld* direct fst lat(6)

   *double* fst lat(11)



#. **PDFLOAT** xmm nme    *Type*: *arlnk*

   Convert 'N' packed signed integer\*4 values from 'arlnk' into 'N'
   packed real\*8 values in 'xmm', where 'N' is 2, 4 or 8 if 'xmm' is an
   xmm (>= SSE2), ymm (>= AVX) or zmm (AVX-512F) register respectively.

   *Attributes*: other null trm ssenme
   .CG terminal "cvtdq2pd" ssedp sse_avx

#. **PDFLOATX** xmm    *Type*: *xmm*

   Convert 'N' packed signed integer\*4 values from 'xmm1' (an xmm or ymm
   register) into 'N' packed real\*8 values in 'xmm2' (an xmm, ymm or zmm
   register), where 'N' is 2, 4 or 8 if 'xmm' is an xmm (>= SSE2), ymm
   (>= AVX) or zmm (AVX-512F) register respectively.

   *Attributes*: other null trm
   .CG terminal "cvtdq2pd" ssedp avx_special


``DFLOATU``
   Unsigned integer\*4 to real\*8 type conversion.
   Equivalent to UIKMV + DFLOATK combination.

   *Attributes*: arth null dp cse
   .CG notCG

``DFLOATK``
   Integer\*8 to real\*8 type conversion.

   *Attributes*: arth null dp cse
   .CG "cvtsi2sd" 'q' avx_special*ld* direct fst lat(6)

   *double* fst lat(11)



``DFLOATUK``
   Unsigned integer\*8 to real\*8 type conversion.

   *Attributes*: arth null dp cse
   .CG notAILI

#. **PDFLOATK** xmm nme    *Type*: *arlnk*

   AVX512-DQ instruction to convert packed integer\*8 values from 'arlnk'
   into real\*8 values in 'xmm'.

   *Attributes*: other null trm ssenme
   .CG terminal notAILI

#. **PDFLOATKX** xmm    *Type*: *xmm*

   AVX512-DQ instruction to convert packed integer\*8 values from 'xmm1'
   into real\*8 values in 'xmm2'.

   *Attributes*: other null trm
   .CG terminal notAILI


``FIX``
   Real\*4 to integer\*4 type conversion.

   *Attributes*: arth null ir cse
   .CG "cvttss2si" 'l' sse_avx asm_special*ld* vector fst lat(10)

   *double* fst lat(9)



``UFIX``
   Real\*4 to unsigned integer\*4 type conversion.  Equivalent to FIXK +
   KIMV combination.

   *Attributes*: arth null ir
   .CG notCG

#. **PSFIX** xmm nme    *Type*: *arlnk*

   Convert 4 real\*4 values from 'arlnk' into 4 integer\*4 values in 'xmm'.

   *Attributes*: other null trm ssenme
   .CG terminal "cvttps2dq" sse_avx

#. **PSFIXX** xmm    *Type*: *xmm*

   Convert 4 real\*4 values from 'xmm1' into 4 integer\*4 values in 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "cvttps2dq" sse_avx


``FIXK``
   Real\*4 to integer\*8 type conversion.

   *Attributes*: arth null kr cse
   .CG "cvttss2si" 'q' sse_avx asm_special*ld* vector fst lat(10)

   *double* fst lat(9)



``FIXUK``
   Real\*4 to unsigned integer\*8 type conversion.  Implemented as a QJSR.

   *Attributes*: arth null kr cse
   .CG notCG


``DFIX``
   Real\*8 to integer\*4 type conversion.

   *Attributes*: arth null ir cse
   .CG "cvttsd2si" 'l' sse_avx asm_special*double* fst lat(9)

   *ld* vector fadd fmul fstore lat(10)



``DFIXU``
   Real\*8 to unsigned integer\*4 type conversion.  Equivalent to DFIXK +
   KIMV combination.

   *Attributes*: arth null ir cse
   .CG notCG

#. **PDFIX** xmm nme    *Type*: *arlnk*

   Convert 2 real\*8 values from 'arlnk' into 2 integer\*4 values in the
   low half of 'xmm'.

   *Attributes*: other null trm ssenme
   .CG terminal "cvttpd2dq" avx_special

#. **PDFIXX** xmm    *Type*: *xmm*

   Convert 2 real\*8 values from 'xmm1' into 2 integer\*4 values in the low
   half of 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "cvttpd2dq" avx_special


``DFIXK``
   Real\*8 to to integer\*8 type conversion.

   *Attributes*: arth null kr cse
   .CG "cvttsd2si" 'q' sse_avx asm_special*double* fst lat(9)

   *ld* vector fadd fmul fstore lat(10)



``DFIXUK``
   Real\*8 to unsigned integer\*8 type conversion.  Implemented as a QJSR.

   *Attributes*: arth null kr cse
   .CG notCG


``SNGL``
   Real\*8 to real\*4 type conversion.

   *Attributes*: arth null sp cse
   .CG "cvtsd2ss" avx_special

#. **PSNGL** xmm nme    *Type*: *arlnk*

   Convert 2 real\*8 values from 'arlnk' into 2 real\*4 values in the low
   half of 'xmm'.

   *Attributes*: other null trm ssenme
   .CG terminal "cvtpd2ps" avx_special*vector* lat(10)



#. **PSNGLX** xmm    *Type*: *xmm*

   Convert 2 real\*8 values from 'xmm1' into 2 real\*4 values in the low
   half of 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "cvtpd2ps" avx_special*vector* lat(8)




``DBLE``
   Real\*4 to real\*8 type conversion.

   *Attributes*: arth null dp cse
   .CG "cvtss2sd" avx_special

#. **PDBLE** xmm nme    *Type*: *arlnk*

   Convert 'N' packed real\*4 values from 'arlnk' into 'N' packed real\*8
   values in 'xmm', where 'N' is 2, 4 or 8 if 'xmm' is an xmm (>= SSE2),
   ymm (>= AVX) or zmm (AVX-512F) register respectively.

   *Attributes*: other null trm ssenme
   .CG terminal "cvtps2pd" ssedp sse_avx*double* lat(5)



#. **PDBLEX** xmm    *Type*: *xmm*

   Convert 'N' packed real\*4 values from 'xmm1' (an xmm or ymm register)
   into 'N' packed real\*8 values in 'xmm2' (an xmm, ymm or zmm register),
   where 'N' is 2, 4 or 8 if 'xmm' is an xmm (>= SSE2), ymm (>= AVX) or
   zmm (AVX-512F) register respectively.

   *Attributes*: other null trm
   .CG terminal "cvtps2pd" ssedp avx_special*double* lat(3)




``IR2SP``
   Copy an integer\*4 value from a 'gp' register to an 'xmm' register without
   type conversion.  The upper 12 bytes of the 'xmm' register are zeroed.

   *Attributes*: arth null sp cse
   .CG "movd" 'l' sse_avx asm_special

``KR2SP``
   To be eliminated?

   *Attributes*: arth null sp
   .CG notCG

``KR2DP``
   Copy an integer\*8 value from a 'gp' register to an 'xmm' register without
   type conversion.  The upper 8 bytes of the 'xmm' register are zeroed.

   *Attributes*: arth null dp
   .CG 'q' sse_avx asm_special

``KR2CS``
   Copy an integer\*8 value from a 'gp' register to an 'xmm' register without
   type conversion.  The upper 8 bytes of the 'xmm' register are zeroed.

   *Attributes*: arth null cs
   .CG 'q' sse_avx asm_special

``SP2IR``
   Copy a real\*4 value from an 'xmm' register to a 'gp' register without
   type conversion.

   *Attributes*: arth null ir cse
   .CG "movd" 'l' sse_avx asm_special

``SP2KR``
   Not used.

   *Attributes*: arth null kr
   .CG notCG

``DP2KR``
   Copy a real\*8 value from an 'xmm' register to a 'gp' register without
   type conversion.

   *Attributes*: arth null kr
   .CG 'q' sse_avx asm_special

``CS2KR``
   Copy a single precision complex from an 'xmm' register to a 'gp' register
   without type conversion.

   *Attributes*: arth null kr
   .CG 'q' sse_avx asm_special

#. **ROTL** irlnk    *Type*: *irlnk*


   *Attributes*: arth null ir cse
   .CG ccarith "rol" 'l'

#. **ROTR** irlnk    *Type*: *irlnk*


   *Attributes*: arth null ir cse
   .CG ccarith "ror" 'l'

#. **IADD** irlnk    *Type*: *irlnk*

   Signed integer addition.

   *Attributes*: arth comm ir cse
   .CG memdest ccarith "add" 'l'*direct* lat(4:1)



#. **UIADD** irlnk    *Type*: *irlnk*

   Unsigned integer addition.

   *Attributes*: arth comm ir cse
   .CG memdest ccarith "add" 'l'*direct* lat(4:1)



#. **KADD** krlnk    *Type*: *krlnk*

   Signed integer64 addition.

   *Attributes*: arth comm kr cse
   .CG memdest ccarith "add" 'q'*direct* lat(4:1)



#. **UKADD** krlnk    *Type*: *krlnk*

   Unsigned integer64 addition.

   *Attributes*: arth comm kr cse
   .CG notCG replaceby KADD

#. **AADD** arlnk stc    *Type*: *arlnk*

   Address unit add.
   The stc operand is not used by the x86-64 code generator.

   *Attributes*: arth null ar cse
   .CG notCG replaceby KADD

#. **FADD** splnk    *Type*: *splnk*

   Single-precision floating-point addition.

   *Attributes*: arth comm sp cse
   .CG "addss" sse_avx*fadd* double lat(6:4)



#. **DADD** dplnk    *Type*: *dplnk*

   Double-precision floating-point addition.

   *Attributes*: arth comm dp cse
   .CG "addsd" sse_avx*fadd* direct lat(6:4)



#. **SCMPLXADD** cslnk    *Type*: *cslnk*

   Single-precision complex addition.

   *Attributes*: arth comm cs cse
   .CG "addps" sse_avx*double* fadd lat(5:7)



#. **DCMPLXADD** cdlnk    *Type*: *cdlnk*

   Double-precision complex addition.

   *Attributes*: arth comm cd cse
   .CG "addpd" sse_avx*double* fadd lat(5:7)



#. **ISUB** irlnk    *Type*: *irlnk*

   Signed 32-bit integer subtraction.

   *Attributes*: arth null ir cse
   .CG memdest ccarith "sub" 'l'*direct* lat(4:1)



#. **UISUB** irlnk    *Type*: *irlnk*

   Unsigned integer subtract.  op1 - op2.

   *Attributes*: arth null ir cse
   .CG memdest ccarith "sub" 'l'*direct* lat(4:1)



#. **KSUB** krlnk    *Type*: *krlnk*

   Signed integer64 subtraction.

   *Attributes*: arth null kr cse
   .CG memdest ccarith "sub" 'q'*direct* lat(4:1)



#. **UKSUB** krlnk    *Type*: *krlnk*

   Unsigned integer64 subtraction.

   *Attributes*: arth null kr cse
   .CG notCG replaceby KSUB

#. **ASUB** arlnk stc    *Type*: *arlnk*

   Address unit subtract.
   The stc operand is not used.

   *Attributes*: arth null ar cse
   .CG notCG replaceby KSUB

#. **FSUB** splnk    *Type*: *splnk*

   Single-precision floating-point subtraction.

   *Attributes*: arth null sp cse
   .CG "subss" sse_avx*direct* fadd lat(6:4)



#. **FSUBR** splnk    *Type*: *splnk*

   Single-precision floating-point subtraction - operands reversed
   (used by llvect.c as a convenience).

   *Attributes*: arth null sp cse
   .CG notCG

#. **DSUB** dplnk    *Type*: *dplnk*

   Double-precision floating-point subtraction.

   *Attributes*: arth null dp cse
   .CG "subsd" sse_avx*direct* fadd lat(6:4)



#. **SCMPLXSUB** cslnk    *Type*: *cslnk*

   Single-precision complex subtraction.

   *Attributes*: arth null cs cse
   .CG "subps" sse_avx*double* fadd lat(7:5)



#. **DCMPLXSUB** cdlnk    *Type*: *cdlnk*

   Double-precision complex subtraction.

   *Attributes*: arth null cd cse
   .CG "subpd" sse_avx*double* fadd lat(7:5)



#. **IMUL** irlnk    *Type*: *irlnk*

   Integer Multiply.  It'a a bug to give this opcode the 'cc' attribute.

   *Attributes*: arth comm ir cse
   .CG "imul" 'l' ccmod*direct* lat(7)



#. **UIMUL** irlnk    *Type*: *irlnk*

   Unsigned integer multiply. Same as signed.

   *Attributes*: arth comm ir cse
   .CG notCG replaceby IMUL

#. **IMULH** irlnk    *Type*: *irlnk*

   Integer multiply, high 32-bits of product as result

   *Attributes*: arth comm ir cse
   .CG "imul" 'l' ccmod*direct* lat(7)



#. **UIMULH** irlnk    *Type*: *irlnk*

   Integer multiply, high 32-bits of product as result

   *Attributes*: arth comm ir cse
   .CG "mul" 'l' ccmod*direct* lat(7)



#. **KMUL** krlnk    *Type*: *krlnk*

   Integer64 Multiply.

   *Attributes*: arth comm kr cse
   .CG "imul" 'q' ccmod*direct* lat(8)



#. **KMULH** krlnk    *Type*: *krlnk*

   Integer64 Multiply, high 64-bits of product returned.

   *Attributes*: other comm kr cse
   .CG "imul" 'q' ccmod*direct* lat(8)



#. **UKMUL** krlnk    *Type*: *krlnk*

   Unsigned integer64 Multiply.

   *Attributes*: arth comm kr cse
   .CG notCG replaceby KMUL

#. **UKMULH** krlnk    *Type*: *krlnk*

   Integer64 Multiply, high 64-bits of product returned.

   *Attributes*: other comm kr cse
   .CG "mul" 'q' ccmod*direct* lat(8)



#. **FMUL** splnk    *Type*: *splnk*

   Single-precision floating-point multiply.

   *Attributes*: arth comm sp cse
   .CG "mulss" sse_avx*direct* fmul lat(4)



#. **DMUL** dplnk    *Type*: *dplnk*

   Double-precision multiply.

   *Attributes*: arth comm dp cse
   .CG "mulsd" sse_avx*direct* fmul lat(6:4)



#. **SCMPLXMUL** cslnk    *Type*: *cslnk*

   Single-complex multiply.

   *Attributes*: arth comm cs cse
   .CG sse_avx asm_special

#. **DCMPLXMUL** cdlnk    *Type*: *cdlnk*

   Double-complex multiply.

   *Attributes*: arth comm cd cse
   .CG sse_avx asm_special

#. **IDIV** irlnk    *Type*: *irlnk*

   Signed integer divide.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UIDIV** irlnk    *Type*: *irlnk*

   Unsigned integer divide.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KDIV** krlnk    *Type*: *krlnk*

   Signed integer64 divide.

   *Attributes*: arth null kr cse
   .CG notCG

#. **UKDIV** krlnk    *Type*: *krlnk*

   Unsigned integer64 divide.

   *Attributes*: arth null kr cse
   .CG notCG

#. **IDIVZ** irlnk    *Type*: *irlnk*

   Signed integer divide where divide by zero does not fault.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UIDIVZ** irlnk    *Type*: *irlnk*

   Unsigned integer divide where divide by zero does not fault.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KDIVZ** krlnk    *Type*: *krlnk*

   Signed integer64 divide where divide by zero does not fault.

   *Attributes*: arth null kr cse
   .CG notCG

#. **UKDIVZ** krlnk    *Type*: *krlnk*

   Unsigned integer64 divide where divide by zero does not fault.

   *Attributes*: arth null kr cse
   .CG notCG

#. **IDIVZR** irlnk    *Type*: *irlnk*

   Signed integer divide where the remainder is zero

   *Attributes*: arth null ir cse
   .CG notCG

#. **KDIVZR** krlnk    *Type*: *krlnk*

   Signed integer64 divide where the remainder is zero

   *Attributes*: arth null kr cse
   .CG notCG

#. **QUOREM** irlnk    *Type*: *irlnk*

   Represents an integer divide and/or mod operation.  Use of this ili allows
   a single divide instruction to both a divide and mod result.

   *Attributes*: arth null ir cse
   .CG notAILI 'l'

#. **KQUOREM** krlnk    *Type*: *krlnk*

   Represents a long divide and/or mod operation.  Use of this ili allows
   a single divide instruction to both a divide and mod result.

   *Attributes*: arth null kr cse
   .CG notAILI 'q'

``NIDIV``
   Signed integer divide that points to QUOREM.  Result is in register %eax.

   *Attributes*: arth null ir cse
   .CG "idiv" 'l' ccmod

``NUIDIV``
   Unsigned integer divide that points to QUOREM.  Result is in register %eax.

   *Attributes*: arth null ir cse
   .CG "div" 'l' ccmod

``NKDIV``
   Signed integer64 divide that points to QUOREM.  Result is in register %rax.

   *Attributes*: arth null kr cse
   .CG "idiv" 'q' ccmod

``NUKDIV``
   Unsigned integer64 divide that points to QUOREM.  Result is in register %rax.

   *Attributes*: arth null kr cse
   .CG "div" 'q' ccmod

#. **FDIV** splnk    *Type*: *splnk*

   Single-precision divide.

   *Attributes*: arth null sp cse
   .CG "divss" sse_avx*direct* fmul lat(18:16)



#. **FDIVR** splnk    *Type*: *splnk*

   Single-precision divide - operands reversed (used by llvect.c
   as a convenience).

   *Attributes*: arth null sp cse
   .CG notCG

#. **DDIV** dplnk    *Type*: *dplnk*

   Double divide.

   *Attributes*: arth null dp cse
   .CG "divsd" sse_avx*direct* fmul lat(22:20)



#. **SCMPLXDIV** cslnk    *Type*: *cslnk*

   Single precision complex divide.

   *Attributes*: arth null cs cse
   .CG "divps" sse_avx

#. **DCMPLXDIV** cdlnk    *Type*: *cdlnk*

   Double precision complex divide.

   *Attributes*: arth null cd cse
   .CG "divpd" sse_avx

#. **MOD** irlnk    *Type*: *irlnk*

   Integer remainder.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UIMOD** irlnk    *Type*: *irlnk*

   Unsigned integer mod.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KMOD** krlnk    *Type*: *krlnk*

   Integer64 remainder.

   *Attributes*: arth null kr
   .CG notCG

#. **KUMOD** krlnk    *Type*: *krlnk*

   Integer64 remainder.

   *Attributes*: arth null kr
   .CG notCG

#. **MODZ** irlnk    *Type*: *irlnk*

   Integer remainder where divide by zero does not fault.

   *Attributes*: arth null ir cse
   .CG notCG

#. **UIMODZ** irlnk    *Type*: *irlnk*

   Unsigned integer mod where divide by zero does not fault.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KMODZ** krlnk    *Type*: *krlnk*

   Integer64 remainder where divide by zero does not fault.

   *Attributes*: arth null kr
   .CG notCG

#. **KUMODZ** krlnk    *Type*: *krlnk*

   Integer64 remainder where divide by zero does not fault.

   *Attributes*: arth null kr
   .CG notCG

``NMOD``
   Integer remainder that points to a QUOREM ili.  Result is in register %edx.

   *Attributes*: arth null ir cse
   .CG "idiv" 'l' ccmod

``NUIMOD``
   Unsigned integer mod that points to QUOREM ili.  Result is in register %edx.

   *Attributes*: arth null ir cse
   .CG "div" 'l' ccmod

``NKMOD``
   Integer remainder that points to a QUOREM ili.  Result is in register %rdx.

   *Attributes*: arth null kr cse
   .CG "idiv" 'q' ccmod

``NUKMOD``
   Unsigned integer mod that points to QUOREM ili.  Result is in register %rdx.

   *Attributes*: arth null kr cse
   .CG "div" 'q' ccmod

#. **FMOD** splnk    *Type*: *splnk*

   Single-precision mod.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DMOD** dplnk    *Type*: *dplnk*

   Double-precision mod.

   *Attributes*: arth null dp cse
   .CG notCG

#. **IMAX** irlnk    *Type*: *irlnk*

   Integer maximum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm ir cse
   .CG asm_special "cmpl" 'l' ccmod

#. **UIMAX** irlnk    *Type*: *irlnk*

   Unsigned integer maximum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm ir cse
   .CG notCG

#. **IMIN** irlnk    *Type*: *irlnk*

   Integer minimum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm ir cse
   .CG asm_special "cmpl" 'l' ccmod

#. **UIMIN** irlnk    *Type*: *irlnk*

   Unsigned integer minimum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm ir cse
   .CG notCG

#. **KMAX** krlnk    *Type*: *krlnk*

   Integer64 maximum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm kr cse
   .CG asm_special "cmpq" 'q' ccmod

#. **UKMAX** krlnk    *Type*: *krlnk*

   Unsigned integer64 maximum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm kr cse
   .CG notCG

#. **KMIN** krlnk    *Type*: *krlnk*

   Integer64 minimum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm kr cse
   .CG asm_special "cmpq" 'q' ccmod

#. **UKMIN** krlnk    *Type*: *krlnk*

   Unsigned integer64 minimum value.  Expanded in-line by Code Generator.

   *Attributes*: arth comm kr cse
   .CG notCG

#. **FMAX** splnk    *Type*: *splnk*

   Single precision maximum.

   *Attributes*: arth comm sp cse
   .CG "maxss" sse_avx*direct* fadd lat(4:2)



#. **FMIN** splnk    *Type*: *splnk*

   Single precision minimum.

   *Attributes*: arth comm sp cse
   .CG "minss" sse_avx*direct* fadd lat(4:2)



#. **DMAX** dplnk    *Type*: *dplnk*

   Double precision maximum.

   *Attributes*: arth comm dp cse
   .CG "maxsd" sse_avx*direct* fadd lat(4:2)



#. **DMIN** dplnk    *Type*: *dplnk*

   Double precison minimum.

   *Attributes*: arth comm dp cse
   .CG "minsd" sse_avx*direct* fadd lat(4:2)



#. **JN** splnk    *Type*: *irlnk*

   float bessel_jn

   *Attributes*: arth null sp cse
   .CG notCG

#. **DJN** dplnk    *Type*: *irlnk*

   double bessel_jn

   *Attributes*: arth null dp cse
   .CG notCG

#. **YN** splnk    *Type*: *irlnk*

   float bessel_yn

   *Attributes*: arth null sp cse
   .CG notCG

#. **DYN** dplnk    *Type*: *irlnk*

   double bessel_yn

   *Attributes*: arth null dp cse
   .CG notCG

#. **DFMA** dplnk dplnk    *Type*: *dplnk*

   This opcode is only used in AILIs, not shared or linear ILIs.  It
   represents a scalar double-precision FMA3 or FMA4 instruction which
   computes:
       dest = <sign> (src1 \* src2) <addop> src3

   Either 'src2' or 'src3', but not both, can be a memory operand, and
   the other operands are xmm register operands.  The values of <sign>
   (+/-) and <addop> (+/-) are specified by an 'FMA\_...' flag set in the
   cc field of the AILI.  Since AILIs allow at most 2 source operands,
   this AILI is always immediately preceded by a USE AILI which specifies
   the 'src1' operand.

   *Attributes*: arth null dp
   .CG CGonly asm_special

#. **FFMA** splnk splnk    *Type*: *splnk*

   This is the same as DFMA except that it represents a scalar single
   precision FMA3 or FMA4 instruction.

   *Attributes*: arth null sp
   .CG CGonly asm_special

#. **IPOWI** irlnk    *Type*: *irlnk*

   Integer raised to an integer power.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KPOWI** irlnk    *Type*: *krlnk*

   Integer raised to an integer power.

   *Attributes*: arth null kr cse
   .CG notCG

#. **KPOWK** krlnk    *Type*: *krlnk*

   Integer raised to an integer power.

   *Attributes*: arth null kr cse
   .CG notCG

#. **FPOWI** irlnk    *Type*: *splnk*

   Real raised to an integer power.

   *Attributes*: arth null sp cse
   .CG notCG

#. **FPOWK** krlnk    *Type*: *splnk*

   Real raised to an integer power.

   *Attributes*: arth null sp cse
   .CG notCG

#. **FPOWF** splnk    *Type*: *splnk*

   Real raised to a real power.

   *Attributes*: arth null sp cse
   .CG notCG

#. **DPOWI** irlnk    *Type*: *dplnk*

   Double raised to a integer power.

   *Attributes*: arth null dp cse
   .CG notCG

#. **DPOWK** krlnk    *Type*: *dplnk*

   Double raised to a integer power.

   *Attributes*: arth null dp cse
   .CG notCG

#. **DPOWD** dplnk    *Type*: *dplnk*

   Double raised to a double power.

   *Attributes*: arth null dp cse
   .CG notCG

#. **ICMP** irlnk stc    *Type*: *irlnk*

   Integer compare with result of true or false.
   For C the value of true is 1, and for Fortran, -1.
   \'stc' denotes condition code, as for the ICJMP ili.
   Due to problems when this operation is used with SELECT ili, it is
   not given the 'cse' attribute.

   *Attributes*: arth null ir cse
   .CG asm_special "cmpl" 'l' ccmod*direct* lat(4:1)



#. **UICMP** irlnk stc    *Type*: *irlnk*

   Unsigned integer compare.

   *Attributes*: arth null ir cse
   .CG notAILI 'l'

#. **KCMP** krlnk stc    *Type*: *krlnk*

   Integer64 compare with result of true or false.
   Conditions are same as ICJMP ILI.

   *Attributes*: arth null ir cse
   .CG notAILI "cmpq" 'q'*direct* lat(4:1)



#. **UKCMP** krlnk stc    *Type*: *krlnk*

   Integer compare with result of true or false.
   Conditions are same as ICJMP ILI.

   *Attributes*: arth null ir cse
   .CG notAILI 'q'

#. **ACMP** arlnk stc    *Type*: *arlnk*

   Address compare with result of true or false.
   The conditions (stc) are the same as for ICMP.

   *Attributes*: arth null ir cse
   .CG notCG replaceby UKCMP

#. **FCMP** splnk stc    *Type*: *splnk*

   Single float compare with result of true or false.

   *Attributes*: arth null ir cse
   .CG asm_special "ucomiss" ccmod sse_avx*vector* lat(6:4)



#. **DCMP** dplnk stc    *Type*: *dplnk*

   Double precision compare with result of true or false.

   *Attributes*: arth null ir cse
   .CG asm_special "ucomisd" ccmod sse_avx*vector* fadd lat(5:4)



#. **SCMPLXCMP** dplnk stc    *Type*: *dplnk*

   Single precision complex compare with result of true or false.

   *Attributes*: arth comm ir cse
   .CG asm_special "ucomisd" ccmod sse_avx*vector* fadd lat(5:4)



#. **DCMPLXCMP** dplnk stc    *Type*: *dplnk*

   Double precision complex compare with result of true or false.

   *Attributes*: arth comm ir cse
   .CG asm_special "ucomisd" ccmod sse_avx*vector* fadd lat(5:4)



#. **ICMPZ** stc    *Type*: *irlnk*

   Integer compare with zero.
   Conditions are same as ICJMP ILI.

   *Attributes*: arth null ir cse
   .CG notAILI 'l'

#. **UICMPZ** stc    *Type*: *irlnk*

   Unsigned integer compare with zero.

   *Attributes*: arth null ir cse
   .CG notAILI 'l'

#. **KCMPZ** stc    *Type*: *krlnk*

   Integer64 compare with zero; returns integer value.
   Conditions are same as ICJMP ILI.

   *Attributes*: arth null ir cse
   .CG notAILI 'q'

#. **UKCMPZ** stc    *Type*: *krlnk*

   Integer64 compare with zero.
   Conditions are same as ICJMP ILI.

   *Attributes*: arth null ir cse
   .CG notAILI 'q'

#. **ACMPZ** stc    *Type*: *arlnk*

   Address compare with zero.
   The conditions (stc) are the same as for ICMP.

   *Attributes*: arth null ir cse
   .CG notCG replaceby UKCMPZ

#. **FCMPZ** stc    *Type*: *splnk*

   Single float compare with zero; result is TRUE or FALSE.

   *Attributes*: arth null ir cse
   .CG notCG

#. **DCMPZ** stc    *Type*: *dplnk*

   Double precision compare with zero.

   *Attributes*: arth null ir cse
   .CG notCG

#. **TEST** irlnk    *Type*: *irlnk*

   Compare register value with 0.

   *Attributes*: arth comm ir cse
   .CG CGonly "testl" cclogical 'l' asm_special*direct* lat(4:1)



#. **KTEST** krlnk    *Type*: *krlnk*

   Compare register value with 0.

   *Attributes*: arth comm ir cse
   .CG CGonly "testq" cclogical 'q' asm_special*direct* lat(4:1)



#. **ISELECT** irlnk irlnk    *Type*: *irlnk*

   Select either the 2nd or 3rd operand value based on the comparison
   operation pointed to by the 1st operand.

   *Attributes*: other null ir cse
   .CG notAILI 'l'

#. **KSELECT** krlnk krlnk    *Type*: *irlnk*


   *Attributes*: other null kr cse
   .CG notAILI 'q'

#. **ASELECT** arlnk arlnk    *Type*: *irlnk*


   *Attributes*: other null ar cse
   .CG notCG replaceby KSELECT

#. **FSELECT** splnk splnk    *Type*: *irlnk*


   *Attributes*: other null sp cse
   .CG notAILI

#. **DSELECT** dplnk dplnk    *Type*: *irlnk*


   *Attributes*: other null dp cse
   .CG notAILI

#. **CSSELECT** cslnk cslnk    *Type*: *irlnk*


   *Attributes*: other null cs cse
   .CG notAILI

#. **CDSELECT** cdlnk cdlnk    *Type*: *irlnk*


   *Attributes*: other null cd cse
   .CG notAILI

#. **AND** irlnk    *Type*: *irlnk*

   Bitwise 32-bit 'and' operation.

   *Attributes*: arth comm ir cse
   .CG memdest cclogical "and" 'l'*direct* lat(4:1)



#. **KAND** krlnk    *Type*: *krlnk*

   Bitwise 64-bit 'and' operation.

   *Attributes*: arth comm kr
   .CG memdest cclogical "and" 'q'*direct* lat(4:1)



#. **OR** irlnk    *Type*: *irlnk*

   Bitwise 32-bit 'or' operation.

   *Attributes*: arth comm ir cse
   .CG memdest cclogical "or" 'l'*direct* lat(4:1)



#. **KOR** krlnk    *Type*: *krlnk*

   Bitwise 64-bit 'or' operation.

   *Attributes*: arth comm kr
   .CG memdest cclogical "or" 'q'*direct* lat(4:1)



#. **XOR** irlnk    *Type*: *irlnk*

   Bitwise exclusive-or operation.

   *Attributes*: arth comm ir cse
   .CG memdest cclogical "xor" 'l'*direct* lat(4:1)



#. **LEQV** irlnk    *Type*: *irlnk*

   Bitwise exclusive-or followed by not operation.

   *Attributes*: arth comm ir cse
   .CG memdest cclogical "notxor" 'l'*direct* lat(4:1)



#. **KXOR** krlnk    *Type*: *krlnk*

   Bitwise 64-bit exclusive-or operation.

   *Attributes*: arth comm kr
   .CG memdest cclogical "xor" 'q'*direct* lat(4:1)



#. **EQV** irlnk    *Type*: *irlnk*


   *Attributes*: arth comm ir cse
   .CG notCG

#. **JISHFT** irlnk    *Type*: *irlnk*

   Shift op1 by op2.  Left if op2 is > 0; else right (no sign extension).
   This ili only shows up for Fortran, specifically for the JISHFT intrinsic.
   If 2nd operand is compile time constant, this ili will have been
   replaced by either a left or right shift ili by the Expander.
   Otherwise, it is implemented as a call to a run-time function.

   *Attributes*: arth null ir cse
   .CG notCG

#. **KISHFT** krlnk    *Type*: *krlnk*

   Shift op1 by op2.  Left if op2 is > 0; else right (no sign extension).
   This ili only shows up for Fortran, specifically for the KISHFT intrinsic.
   If 2nd operand is compile time constant, this ili will have been
   replaced by either a left or right shift ili by the Expander.
   Otherwise, it is implemented as a call to a run-time function.

   *Attributes*: arth null kr cse
   .CG notCG

#. **USHIFT** irlnk    *Type*: *irlnk*

   Shift op1 logically by op2.  Left if op2 is > 0; else right.
   This ili should have been replaced before code generator.

   *Attributes*: arth null ir cse
   .CG notCG

#. **SHIFTA** arlnk    *Type*: *irlnk*

   Shift op1 logically by op2.  Left if op2 is > 0; else right.

   *Attributes*: arth null ir cse
   .CG notCG

#. **USHIFTA** arlnk    *Type*: *irlnk*

   Unsigned shift op1 logically by op2.  Left if op2 is > 0; else right.

   *Attributes*: arth null ir cse
   .CG notCG

#. **LSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 left logically by op2.

   *Attributes*: arth null ir cse
   .CG memdest ccarith shiftop asm_special "shl" 'l'*direct* lat(4:1)



#. **ULSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 left logically by op2.

   *Attributes*: arth null ir cse
   .CG notCG replaceby LSHIFT

#. **LSHIFTI** stc    *Type*: *irlnk*

   Shift left immediate.   This opcode used only in Code Generator.

   *Attributes*: arth null ir cse
   .CG memdest ccarith shiftop "shl" CGonly 'l'*direct* lat(4:1)



#. **KLSHIFTI** stc    *Type*: *krlnk*

   Shift left immediate of 64-bit value.

   *Attributes*: arth null kr cse
   .CG memdest ccarith shiftop "shl" CGonly 'q'*direct* lat(4:1)



#. **RSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 logically right by op2 (sign extended).

   *Attributes*: arth null ir cse
   .CG notCG replaceby ARSHIFT

#. **URSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 logically right by op2 (0 fill).

   *Attributes*: arth null ir cse
   .CG memdest ccarith shiftop asm_special "shr" 'l'*direct* lat(4:1)



#. **ARSHIFT** irlnk    *Type*: *irlnk*

   Shift op1 arithmetically (sign extended) right by op2.
   Used for right shifts (>> operator) of signed values.

   *Attributes*: arth null ir cse
   .CG memdest ccarith shiftop asm_special "sar" 'l'*direct* lat(4:1)



#. **KLSHIFT** irlnk    *Type*: *krlnk*

   Left shift of 64-bit value.

   *Attributes*: arth null kr cse
   .CG memdest ccarith shiftop asm_special "shl" 'q'*direct* lat(4:1)



#. **KURSHIFT** irlnk    *Type*: *krlnk*

   Zero-fill right shift of 64-bit value.

   *Attributes*: arth null kr cse
   .CG memdest ccarith shiftop asm_special "shr" 'q'*direct* lat(4:1)



#. **KARSHIFT** irlnk    *Type*: *krlnk*

   Sign-extended right shift of 64-bit value.

   *Attributes*: arth null kr cse
   .CG memdest ccarith shiftop asm_special "sar" 'q'*direct* lat(4:1)



#. **ILEADZI** stc    *Type*: *irlnk*

   8-/16- bit integer LEADZ intrinsic.
   The value, 0 or 1, of the second operand indicates
   8-bit or 16-bit, respectively.

   *Attributes*: arth null ir cse


``ILEADZ``
   32-bit integer LEADZ intrinsic.

   *Attributes*: arth null ir cse
   .CG "lzcnt" 'l'

``KLEADZ``
   64-bit integer LEADZ intrinsic.

   *Attributes*: arth null kr cse
   .CG "lzcnt" 'q'

#. **ITRAILZI** stc    *Type*: *irlnk*

   8-/16- bit integer TRAILZ intrinsic.
   The value, 0 or 1, of the second operand indicates
   8-bit or 16-bit, respectively.

   *Attributes*: arth null ir cse


``ITRAILZ``
   32-bit integer TRAILZ intrinsic.

   *Attributes*: arth null ir cse
   .CG "tzcnt" 'l'

``KTRAILZ``
   64-bit integer TRAILZ intrinsic.

   *Attributes*: arth null kr cse
   .CG "tzcnt" 'q'

#. **IPOPCNTI** stc    *Type*: *irlnk*

   8-/16- bit integer POPCNT intrinsic.
   The value of second operand indicates 8-bit if 0 and 16-bit
   if 1.

   *Attributes*: arth null ir cse


``IPOPCNT``
   32-bit integer POPCNT intrinsic.

   *Attributes*: arth null ir cse
   .CG "popcnt" 'l'

``KPOPCNT``
   64-bit integer POPCNT intrinsic.

   *Attributes*: arth null kr cse
   .CG "popcnt" 'q'

#. **IPOPPARI** stc    *Type*: *irlnk*

   8-/16- bit integer POPPAR intrinsic.
   The value of second operand indicates 8-bit if 0 and 16-bit
   if 1.

   *Attributes*: arth null ir cse


``IPOPPAR``
   32-bit integer POPPAR intrinsic.

   *Attributes*: arth null ir cse


``KPOPPAR``
   64-bit integer POPPAR intrinsic.

   *Attributes*: arth null kr cse


#. **EXTRACT** stc stc    *Type*: *irlnk*

   Note that this ILI is defined for machines with bit field extract
   HW support (e.g. 88000).
   The two stc operand definitions are architecture DEPENDENT.

   *Attributes*: arth null ir cse
   .CG notCG

``JMP``
   Unconditional jump to indicated label.

   *Attributes*: branch null trm dom
   .CG terminal "jmp"*direct* lat(4:1)



``JMPA``
   Branch indirect.  Fortran only.

   *Attributes*: branch null trm dom
   .CG terminal "jmp" asm_special*direct* lat(4:1)



#. **JMPM** irlnk sym sym    *Type*: *irlnk*

   Indexed jump from a memory table of jump addresses.
   irlnk1 - integer index expression.

   irlnk2 - table_size

   sym - label for memory table containing addresses

   sym  - default label

   *Attributes*: branch null trm dom
   .CG terminal asm_special 'l'

#. **JMPMK** irlnk sym sym    *Type*: *krlnk*

   Indexed jump using a 64-bit integer as index value.

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'q'

#. **JMPT** irlnk    *Type*: *irlnk*

   NOT USED.
   Indexed jump into a table of jump instructions.

   .. line-block::
       irlnk1 - integer index expression. The expression has
              already been normalized to 1 (the value 0 is
              reserved for the "default" jump). If the expression
              is not in the range 1:(n-1) where n is the jump table
              size, the default jump is taken.
       irlnk2 - table_size (includes the default label).


   *Attributes*: branch null trm dom
   .CG notCG

#. **QSWITCH** lnk stc    *Type*: *sym*


   *Attributes*: proc null lnk dom
   .CG notCG

#. **ICJMP** irlnk stc sym    *Type*: *irlnk*

   Integer compare and jump to the label 'sym'
   if the condition, denoted by stc, is true.
   Allowed values of stc:
       1 = CC_EQ   (jump if equal)
       2 = CC_NE   (jump if not equal)
       3 = CC_LT   (jump if less than)
       4 = CC_GE   (jump if greater than or equal to)
       5 = CC_LE   (jump if less than or equal to)
       6 = CC_GT   (jump if greater than)

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'l' conditional_branch

#. **UICJMP** irlnk stc sym    *Type*: *irlnk*

   Unsigned integer compare and jump to the label 'sym'
   if the condition, denoted by stc, is true.
   Conditions same as for ICJMP.

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'l' conditional_branch

#. **KCJMP** krlnk stc sym    *Type*: *krlnk*

   integer64 compare and jump to the label 'sym'
   if the condition, denoted by stc, is true:
   The same conditions as ICJMP

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'q' conditional_branch

#. **UKCJMP** krlnk stc sym    *Type*: *krlnk*

   unsigned integer64 compare and jump to the label 'sym'
   if the condition, denoted by stc, is true:
   The same conditions as ICJMP

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'q' conditional_branch

#. **ACJMP** arlnk stc sym    *Type*: *arlnk*

   Address compare and jump to the label 'sym'
   if the condition, denoted by stc, is true:
   Conditions same as for ICJMP.

   *Attributes*: branch null trm dom
   .CG notCG replaceby UKCJMP conditional_branch

#. **FCJMP** splnk stc sym    *Type*: *splnk*

   Single precision compare and jump to the label 'sym'
   if the condition, denoted by stc, is true.

   *Attributes*: branch null trm dom
   .CG terminal conditional_branch notAILI

#. **DCJMP** dplnk stc sym    *Type*: *dplnk*

   Double precision compare and jump to the label 'sym'
   if the condition, denoted by stc, is true.

   *Attributes*: branch null trm dom
   .CG terminal conditional_branch notAILI

#. **ICJMPZ** stc sym    *Type*: *irlnk*

   Integer compare with zero and branch to label 'sym' -
   the allowed values (and meanings) for stc are the same as
   for the ICJMP ILI.

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'l' conditional_branch

#. **UICJMPZ** stc sym    *Type*: *irlnk*

   Unsigned integer compare with zero and branch to label 'sym' -
   the allowed values (and meanings) for stc are the same as
   for the ICJMP ILI.

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'l' conditional_branch

#. **LCJMPZ** stc sym    *Type*: *irlnk*

   Logical compare with zero and branch to label 'sym' -
   the allowed values (and meanings) for stc are the same as
   for the ICJMP ILI.

   *Attributes*: branch null trm dom
   .CG notCG replaceby UICJMPZ conditional_branch

#. **KCJMPZ** stc sym    *Type*: *krlnk*

   Integer64 compare with zero and branch to label 'sym' -
   the allowed values (and meanings) for stc are the same as
   for the ICJMP ILI.

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'q' conditional_branch

#. **UKCJMPZ** stc sym    *Type*: *krlnk*

   Integer64 compare with zero and branch to label 'sym' -
   the allowed values (and meanings) for stc are the same as
   for the ICJMP ILI.

   *Attributes*: branch null trm dom
   .CG terminal notAILI 'q' conditional_branch

#. **ACJMPZ** stc sym    *Type*: *arlnk*

   Address compare with zero and branch to label 'sym' -
   the allowed values (and meanings) for stc are the same as
   for the ICJMP ILI.

   *Attributes*: branch null trm dom
   .CG notCG replaceby UKCJMPZ conditional_branch

#. **FCJMPZ** stc sym    *Type*: *splnk*

   Single compare with zero and branch to label 'sym'.

   *Attributes*: branch null trm dom
   .CG notCG conditional_branch

#. **DCJMPZ** stc sym    *Type*: *dplnk*

   Double compare with zero and branch to label 'sym'.

   *Attributes*: branch null trm dom
   .CG notCG conditional_branch

``JCC``
   Conditional jump based on immediately preceding compare operation.
   Used only in the AILI.

   *Attributes*: branch null trm dom
   .CG CGonly asm_special conditional_branch*direct* lat(1)



``CSEIR``
   Integer register cse (common subexpression). The ILI located by the cse
   ILI is one whose value is to be re-used (the ILI need not be "evaluated").
   This ILI is used when multiple references of an ILM occur in the same
   ILM block.
   The CSE ili are treated as a special case by the linearizer, and never
   appear in a linear ili block.

   *Attributes*: arth null ir
   .CG notCG

``CSESP``
   Single precision register cse.

   *Attributes*: arth null sp
   .CG notCG

``CSEDP``
   Double precision register cse.

   *Attributes*: arth null dp
   .CG notCG

``CSECS``
   Single precision complex register cse.

   *Attributes*: arth null cs
   .CG notCG

``CSECD``
   Double precision complex register cse.

   *Attributes*: arth null cd
   .CG notCG

``CSEAR``
   Address register cse.

   *Attributes*: arth null ar
   .CG notCG

``CSEKR``
   Integer64 register cse.

   *Attributes*: arth null kr
   .CG notCG

#. **CSE** stc    *Type*: *lnk*

   Complex cse (common subexpression). The ILI located by the cse
   ILI is one whose value is to be re-used (the ILI need not be "evaluated").
   This ILI is used when multiple references of an ILM occur in the same
   ILM block.
   This ili is seen by the code generator but never appears in the
   linear ili.

   *Attributes*: arth null ir
   .CG notCG

``APURE``
   Call a pure function with no arguments and returns an AR value.
   Will always have an ALT which is the actual call.
   arlnk is an ACON ili of the function being called.

   *Attributes*: arth null ar cse
   .CG notCG

#. **APUREA** arlnk    *Type*: *arlnk*

   Call a pure function with one AR argument and returns an AR value.
   Will always have an ALT which is the actual call.
   arlnk is an ACON ili of the function being called.

   *Attributes*: arth null ar cse
   .CG notCG

#. **APUREI** irlnk    *Type*: *arlnk*

   Call a pure function with one IR argument and returns an AR value.
   Will always have an ALT which is the actual call.
   arlnk is an ACON ili of the function being called.

   *Attributes*: arth null ar cse
   .CG notCG

``IPURE``
   Call a pure function with no arguments and returns an IR value.
   Will always have an ALT which is the actual call.
   arlnk is an ACON ili of the function being called.

   *Attributes*: arth null ir cse
   .CG notCG

#. **IPUREA** arlnk    *Type*: *arlnk*

   Call a pure function with one AR argument and returns an IR value.
   Will always have an ALT which is the actual call.
   arlnk is an ACON ili of the function being called.

   *Attributes*: arth null ir cse
   .CG notCG

#. **IPUREI** irlnk    *Type*: *arlnk*

   Call a pure function with one IR argument and returns an IR value.
   Will always have an ALT which is the actual call.
   arlnk is an ACON ili of the function being called.

   *Attributes*: arth null ir cse
   .CG notCG

``REP``
   Repeat prefix opcode for string operations (such as the following SMOVE).
   Emitted immediately before an SMOVE operation.

   *Attributes*: other null trm dom
   .CG CGonly "rep"

#. **GSMOVE** arlnk nme nme stc    *Type*: *arlnk*

   General structure copy.
   A structure store (SMOVE ILM) is expanded into the GSMOVE ILI; a phase, such as
   the ACC CG, needs to have the structure assignment presented as a first-class
   ILI operation.
   After the last phase requiring GSMOVE, GSMOVE will then be expanded into
   lower level ILI which will be dependent on target, alignment, small vs large,
   etc.
     \'op1' is the source address.
     \'op2' is the destination address.
     \'nme1' is the names table entry for source struct.
     \'nme2' is the names table entry for the destination struct.
     \'stc' is the dtype of the struct.

   *Attributes*: other null trm dom
   .CG notCG

#. **SMOVE** arlnk arlnk nme    *Type*: *arlnk*

   Structure copy.
     \'op1' is the source address.
     \'op2' is the destination address.
     \'op3' is number of 8-byte units to copy.
     \'nme' is names table entry for destination struct.

   *Attributes*: other null trm dom
   .CG terminal "movs"

#. **SMOVEJ** arlnk nme nme stc    *Type*: *arlnk*

   Simple structure copy.  (MOVS is x86 parlance.)
   This is used to replace the SMOVEI/SMOVES pair, which was used when
   the ILI operand count was only 4.
   \'op1' is the source address
   \'op2' is the destination address
   \'nme1' is the names table entry for source struct.
   \'nme2' is the names table entry for the destination struct.
   \'op5' is actual number of bytes to copy.
   This gets turned into SMOVE and load/store operations by rm_smove

   *Attributes*: other null trm dom
   .CG notCG

#. **XMOVE** arlnk nme    *Type*: *arlnk*

   Structure copy.
     \'op1' is the source address.
     \'op2' is the destination address.
     \'nme' is names table entry for destination struct.

   *Attributes*: other null trm dom
   .CG terminal "movapd" sse_avx

#. **ST** arlnk nme stc    *Type*: *irlnk*

   Store integer value.
   In ILI, the value to be stored must fit without implicit truncation, i.e. immediately
   reloading using LD with the same size modifier must reproduce the value that was stored.
   In LILI or AILI, ST may perform implicit truncation.
   \'op1' is a pointer to an ili representing the value being stored.

   \'op2' is a pointer to the address expression of the variable being defined.

   \'nme' is a pointer to a names table entry of the variable being defined.

   \'stc' is the size modifier of the memory operation as described for
   the LD ili above.

   *Attributes*: store null trm
   .CG terminal "mov" move*direct* lat(1)

   *ld* direct lat(3)

   *st* direct lat(3)



#. **STSP** arlnk nme stc    *Type*: *splnk*

   Store single precision quantity.  'stc' must be MSZ_F4.

   *Attributes*: store null trm
   .CG terminal "movss" move avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



#. **STDP** arlnk nme stc    *Type*: *dplnk*

   Store double precision quantity.  'stc' must be MSZ_F8.

   *Attributes*: store null trm
   .CG terminal "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **STSCMPLX** arlnk nme stc    *Type*: *cslnk*

   Store single precision complex quantity.  'stc' is not used.

   *Attributes*: store null trm
   .CG terminal "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **STDCMPLX** arlnk nme stc    *Type*: *cdlnk*

   Store double precision complex quantity.  'stc' is not used.

   *Attributes*: store null trm
   .CG terminal "movupd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **STQ** arlnk nme stc    *Type*: *dplnk*

   Store an __m128 quantity.  'stc' is not used.

   *Attributes*: store null trm
   .CG terminal "movapd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **STQU** arlnk nme stc    *Type*: *dplnk*

   Store an unaligned __m128 quantity.  'stc' is not used.

   *Attributes*: store null trm
   .CG terminal "movupd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **ST256** arlnk nme stc    *Type*: *dplnk*

   Store an __m256 quantity.  'stc' is not used.

   *Attributes*: store null trm
   .CG terminal "vmovapd" 'y' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **ST256U** arlnk nme stc    *Type*: *dplnk*

   Store an unaligned __m256 quantity.  'stc' is not used.

   *Attributes*: store null trm
   .CG terminal "vmovupd" 'y' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **ST512** arlnk nme stc    *Type*: *512lnk*

   Store an __m512 value.  'stc' is not used.

   *Attributes*: store null trm
   .CG terminal "vmovupd" 'z' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **STA** arlnk nme    *Type*: *arlnk*

   Store address quantity inside of op1 into op2.
   Replaced by ST opcode in cgoptim1.

   *Attributes*: store null trm
   .CG terminal notAILI

#. **STRG1** stc    *Type*: *arlnk*

   Store address quantity inside of op1 argument register described by stc.
   Used in g++ style
   thunks when adjusting the \*this\* pointer, (the first argument) just
   before jumping through to the function Replaced by ST opcode in cgoptim1.

   *Attributes*: store null trm
   .CG terminal notAILI

#. **STKR** arlnk nme stc    *Type*: *krlnk*

   Store 64 bit integer value.  'stc' should be MSZ_I8.
   (There may be legacy cases needing repair where it is zero.)
   Replaced by ST opcode with size == MSZ_I8 in cgoptim1.

   *Attributes*: store null trm
   .CG terminal notAILI

``VZST``
   Special ili created by the vectorizer indicating that the variable
   whose address is op1 is stored; necessary in cases where
   the vectorizer replaces assignments with calls.  The optimizer will process
   the ili to create store information and then delete the ili.  Code generator
   will not see this ili.

   *Attributes*: other null trm
   .CG notCG

#. **JSR** lnk    *Type*: *sym*

   \'sym' is external function or subroutine being called (standard linkage).
   \'lnk' points to a list (terminated by NULL) of ARG ili for the
   arguments.

   *Attributes*: proc null lnk dom
   .CG terminal "call" asm_special ccmod

#. **JSRA** lnk stc stc    *Type*: *arlnk*

   JSR to routine whose address is pointed to by arlnk.
   lnk points to the list of ARG ILIs which represents the arguments.
   stc1 attribute flag (stdcall in x86)
   stc2 dtype

   *Attributes*: proc null lnk dom
   .CG terminal notAILI

#. **QJSR** lnk    *Type*: *sym*

   Quick (intrinsic) call.
   \'sym' is the external procedure being called.
   \'lnk' locates the list of arguments (define arg ILI - DAAR, DADR, DADP).

   *Attributes*: proc null lnk dom
   .CG terminal "call" asm_special ccmod

#. **GJSR** lnk sym    *Type*: *sym*

   Same as JSR, but the argument list is expressed using the general argument
   ILI, i.e., before applying the ABI.
   \'sym2' is the label to jump to if an exception is thrown,
   0 if the call cannot throw,
   or -1 if there is no cleanup.

   *Attributes*: proc null lnk dom
   .CG terminal notCG

#. **GJSRA** lnk stc stc sym    *Type*: *arlnk*

   Same as JSRA, but the argument list is expressed using the general argument
   ILI, i.e., before applying the ABI.

   *Attributes*: proc null lnk dom
   .CG terminal notCG

``NULL``
   Used to mark the end of an argument list for a JSR, QJSR or JSRA ili.

   *Attributes*: other null lnk
   .CG notAILI

#. **GARG** lnk stc nme    *Type*: *lnk*

   A general argument link, used before applying the ABI
   \'lnk' (first) points to the value of the argument.
   \'lnk' (second) points to the next ARG ILI.
   First \'stc' is the dtype.
   Second \'stc' is an NME value, if set, for address arguments.

   *Attributes*: define null lnk
   .CG notCG

#. **GARGRET** lnk stc nme    *Type*: *lnk*

   A general argument link representing the return value of the function
   \'lnk' (first) points to the value of the argument.
   \'lnk' (second) points to the next ARG ILI.
   \'stc' is the dtype
   \'nme' is the nme

   *Attributes*: define null lnk
   .CG notCG

#. **VA_ARG** stc    *Type*: *arlnk*

   va_arg(va_list x, typeof_arg) computes the address of the argument
   'arlnk' address of the va_list
   'stc' the dtype of the argument being reference

   *Attributes*: arth null ar
   .CG notCG

#. **ARGIR** lnk    *Type*: *irlnk*

   Defines an integer memory argument.
   \'irlnk' points to the register value of the argument.
   \'lnk' points to the next ARG ILI.

   *Attributes*: define null lnk
   .CG memarg "mov" 'l'*direct* lat(1)

   *ld* direct lat(3)

   *st* direct lat(3)



#. **ARGSP** lnk    *Type*: *splnk*

   Defines a single-precision memory argument.
   \'splnk' points to the register value of the argument.
   \'lnk' points to the next ARG ILI.

   *Attributes*: define null lnk
   .CG memarg "movss" avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



#. **ARGDP** lnk    *Type*: *dplnk*

   Defines a double precision memory argument.
   \'dplnk' points to the register value of the argument.
   \'lnk' points to the next ARG ILI.

   *Attributes*: define null lnk
   .CG memarg "movsd" avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **ARGAR** lnk stc    *Type*: *arlnk*

   A memory argument of type pointer or struct/union.
   \'arlnk' points to the value of the argument.
   \'lnk' points to the next ARG ILI.
   \'stc' is the dtype if this is a struct arg, else it is 0.

   *Attributes*: define null lnk
   .CG memarg "mov" 'q'*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



#. **ARGKR** lnk    *Type*: *krlnk*

   Defines a 64 bit integer memory argument.
   \'krlnk' points to the value of the argument.
   \'lnk' points to the next ARG ILI.

   *Attributes*: define null lnk
   .CG memarg "mov" 'q'*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



#. **ARGRSRV** lnk    *Type*: *stc*

   For WINDOWS-ABI - reserve space in memory argument area for register arguments.
   \'stc' defines the number of bytes to reserve.

   *Attributes*: define null lnk
   .CG memarg notAILI

#. **DAIR** ir lnk    *Type*: *irlnk*

   Define integer argument in general purpose register for a JSR or QJSR.

   *Attributes*: define null lnk
   .CG "mov" 'l' move*direct* lat(1)

   *ld* direct lat(3)

   *st* direct lat(3)



#. **DASP** sp lnk    *Type*: *splnk*

   Define a single precision register argument for a JSR or QJSR.

   *Attributes*: define null lnk
   .CG "movss" move avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



#. **DASPSP** dp lnk    *Type*: *dplnk*

   Define a C struct argument of two floats, passed in the indicated xmm register.

   *Attributes*: define null lnk
   .CG "movq" sse_avx*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



#. **DACS** cs lnk    *Type*: *cslnk*

   Define a C struct argument of two floats, passed in the indicated xmm register.

   *Attributes*: define null lnk
   .CG "movsd" move sse_avx*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



#. **DACD** cd lnk    *Type*: *cdlnk*

   Define a C struct argument of two double, passed in the indicated xmm register.

   *Attributes*: define null lnk
   .CG "movupd" move sse_avx*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



#. **DADP** dp lnk    *Type*: *dplnk*

   Define a double precision argument for a JSR or QJSR.

   *Attributes*: define null lnk
   .CG "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **DA128** dp lnk    *Type*: *dplnk*

   Define an __m128 argument for a JSR or QJSR.

   *Attributes*: define null lnk
   .CG "movupd" move sse_avx*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



#. **DA256** dp lnk    *Type*: *dplnk*

   Define an __m256 argument in a ymm register for a JSR or QJSR (AVX only).

   *Attributes*: define null lnk
   .CG "vmovupd" 'y' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **PSARG** stc lnk    *Type*: *xmm*

   Move symbolic register 'xmm' into actual register 'stc' (typically
   XR_XMM0 or XR_XMM1) in preparation for call to vector intrinsic function.

   *Attributes*: define null lnk
   .CG "movaps" move sse_avx*ld* double lat(4)

   *st* double lat(3)

   *double* lat(2)



#. **PDARG** stc lnk    *Type*: *xmm*

   Move symbolic register 'xmm' into actual register 'stc' (typically
   XR_XMM0 or XR_XMM1) in preparation for call to vector intrinsic function.

   *Attributes*: define null lnk
   .CG "movapd" move ssedp sse_avx*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **DAAR** ar lnk    *Type*: *arlnk*

   Define argument in address register for a JSR or QJSR.
   Lnk1 points to the expression to be moved into the specified (ar2)
   address register. Lnk3 locates the next argument for the JSR.

   *Attributes*: define null lnk
   .CG notCG replaceby DAKR

#. **DAKR** kr lnk    *Type*: *krlnk*

   Define argument in integer64 register for a JSR or QJSR.

   *Attributes*: define null lnk
   .CG "mov" 'q' move*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



#. **DFRIR** ir    *Type*: *lnk*

   Define function result in a integer register.

   *Attributes*: define null ir cse
   .CG terminal asm_nop 'l'

#. **DFRSP** sp    *Type*: *lnk*

   Define single precision function result.

   *Attributes*: define null sp cse
   .CG terminal asm_nop

#. **DFRDP** dp    *Type*: *lnk*

   Define double precision function result in an xmm register.

   *Attributes*: define null dp cse
   .CG terminal asm_nop

#. **DFRCS** cs    *Type*: *lnk*

   Define single precision complex function result in an xmm register.

   *Attributes*: define null cs cse
   .CG terminal asm_nop

#. **DFRCD** cd    *Type*: *lnk*

   Define double precision complex function result in an xmm register.

   *Attributes*: define null cd cse
   .CG terminal asm_nop

#. **DFR128** dp    *Type*: *lnk*

   Define 128-bit function result in an xmm register.

   *Attributes*: define null dp cse
   .CG terminal asm_nop

#. **DFR256** dp    *Type*: *lnk*

   Define 256-bit function result in an ymm register.

   *Attributes*: define null dp cse
   .CG terminal asm_nop 'y' avx_only

#. **DFRAR** ar    *Type*: *lnk*

   Define function result in an address register.
   \'op1' points to one of the JSR ILI.

   *Attributes*: define null ar cse
   .CG notCG replaceby DFRKR

#. **DFRKR** kr    *Type*: *lnk*

   Define function result in a integer64 register.

   *Attributes*: define null kr cse
   .CG terminal asm_nop 'q'

#. **STSPSP** arlnk nme stc    *Type*: *dplnk*

   Store the result of a function returning a struct of two floats.
   dplnk always points to a DFRDP or DPDF ili.
   stc is always MSZ_F8.

   *Attributes*: other null trm
   .CG terminal "movq" ssest sse_avx*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



``IRDF``
   Define one of the 64-bit general purpose registers.

   *Attributes*: define null ir cse
   .CG terminal asm_nop 'l'

``SPDF``
   Define single precision register (xmm register).

   *Attributes*: define null sp cse
   .CG terminal asm_nop

``DPDF``
   Define double precision register (xmm register).

   *Attributes*: define null dp cse
   .CG terminal asm_nop

``ARDF``
   Define address register. (ar is actual register number).

   *Attributes*: define null ar cse
   .CG notCG replaceby KRDF

``KRDF``
   Define integer64 register.

   *Attributes*: define null kr
   .CG terminal asm_nop 'q'

#. **MVIR** ir    *Type*: *irlnk*

   Move integer value into specific integer register, ir.

   *Attributes*: move null trm
   .CG terminal notAILI 'l'

#. **MVSP** sp    *Type*: *splnk*

   This ili represents a single precision function return value.
   For X86_64, the value is moved into the specified xmm register.

   *Attributes*: move null trm
   .CG terminal "movss" move avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



#. **MVSPSP** dp    *Type*: *dplnk*

   Move two single precision values to the lower 64 bits of the
   specified xmm register.  dplnk always points to a LDDP ili.

   *Attributes*: move null trm
   .CG terminal "movq" sse_avx*ld* double fadd fmul fst lat(4)

   *st* double fst lat(4)

   *double* fadd fmul lat(2)



#. **SPSP2SCMPLX** splnk    *Type*: *splnk*

   Form a single complex value out of two single precision real values.

   *Attributes*: other null cs cse
   .CG "unpcklps" sse_avx asm_special

``SPSP2SCMPLXI0``
   Form a single complex value out of two single precision real values, imaginary part is 0.

   *Attributes*: other null cs cse
   .CG "unpcklps" sse_avx asm_special

#. **DPDP2DCMPLX** dplnk    *Type*: *dplnk*

   Form a double complex value out of two double precision real values.

   *Attributes*: other null cd cse
   .CG "unpcklpd" sse_avx asm_special

``DPDP2DCMPLXI0``
   Form a double complex value out of two double precision real values, imaginary part is 0.

   *Attributes*: other null cd cse
   .CG "unpcklpd" sse_avx asm_special

``SCMPLX2IMAG``
   Return single precision imaginary part of a single complex value.

   *Attributes*: other null sp cse
   .CG "movshdup" sse_avx asm_special

``DCMPLX2IMAG``
   Return double precision imaginary part of a double complex value.

   *Attributes*: other null dp cse
   .CG "unpckhpd" sse_avx asm_special

``SCMPLX2REAL``
   Return single precision real part of a single complex value.

   *Attributes*: other null sp cse
   .CG "movss" sse_avx asm_special

``DCMPLX2REAL``
   Return double precision real part of a double complex value.

   *Attributes*: other null dp cse
   .CG "movsd" sse_avx asm_special

#. **MVDP** dp    *Type*: *dplnk*

   This ili represents a double precision function return value.
   For X86_64, the value is moved into the specified xmm register.

   *Attributes*: move null trm
   .CG terminal "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **MVQ** dp    *Type*: *dplnk*

   This ili represents an __m128 function return value.
   For X86_64, the value is moved into the specified xmm register.

   *Attributes*: move null trm
   .CG terminal "movapd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **MV256** dp    *Type*: *dplnk*

   This ili represents an __m256 function return value.
   For X86_64, the value is moved into the specified ymm register.

   *Attributes*: move null trm
   .CG terminal "vmovapd" 'y' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``MOVSP``
   Move a single-precision xmm register value.

   *Attributes*: move null sp
   .CG CGonly "movss" move avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



``MOVDP``
   Move a double-precision xmm register value.

   *Attributes*: move null dp
   .CG CGonly "movsd" move avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``MOVCS``
   Move a single-precision complex xmm register value.

   *Attributes*: move null cs
   .CG CGonly "movsd" move avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



``MOVCD``
   Move a double-precision complex xmm register value.

   *Attributes*: move null cd
   .CG CGonly "movupd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``MOVQP``
   Move an __m128 xmm register value.

   *Attributes*: move null dp
   .CG CGonly "movapd" move sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``MOV256``
   Move an __m256 ymm register value.

   *Attributes*: move null dp
   .CG CGonly "vmovapd" 'y' move avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **MVAR** ar    *Type*: *arlnk*

   Move address value into specific address register, ar.

   *Attributes*: move null trm
   .CG terminal notCG replaceby MVKR

#. **MVKR** kr    *Type*: *krlnk*

   Move integer value into specific integer register, kr.

   *Attributes*: move null trm
   .CG terminal notAILI 'q'

``FREEIR``
   Ensures that the result reg is freed.
   The FREExx ili are eliminated by the linearizer phase of the code generator.

   *Attributes*: other null trm
   .CG terminal notAILI

``FREESP``

   *Attributes*: other null trm
   .CG terminal notAILI

``FREEDP``

   *Attributes*: other null trm
   .CG terminal notAILI

``FREECS``

   *Attributes*: other null trm
   .CG terminal notAILI

``FREECD``

   *Attributes*: other null trm
   .CG terminal notAILI

``FREEAR``

   *Attributes*: other null trm
   .CG terminal notCG replaceby FREEKR

``FREEKR``

   *Attributes*: other null trm
   .CG terminal notAILI

#. **FREE** stc    *Type*: *lnk*


   *Attributes*: other null trm
   .CG terminal notAILI

``ENTRY``
   Main function entry or fortran ENTRY.

   *Attributes*: other null trm dom
   .CG terminal asm_nop

``EXIT``
   Exit the procedure.

   *Attributes*: other null trm dom
   .CG terminal asm_special

``ARGSAVE``
   For varargs/stdargs functions, this ili appears immediately after ENTRY
   ili.  This ili stores the registers which may contain incoming arguments
   into a stack array where they can be accessed by the varargs/stdarg macros.
   \'sym' is a symbol table pointer to the stack array.

   *Attributes*: other null trm dom
   .CG terminal asm_special "leaq"*direct* lat(2)



``NOP``
   Null operation - used when a linear ilo is deleted.
   Also, is the opcode for the head of the aili list.

   *Attributes*: other null trm
   .CG asm_nop

``ASM``
   Implements C inline assembly code, asm(), feature. Also used as
   a convenience by the code generator.  'sym' is a symbol table
   pointer to a string constant.

   *Attributes*: other null trm dom
   .CG terminal asm_special

#. **GASM** lnk lnk lnk    *Type*: *sym*

   Compatible ASM language representation to support asm().
   sym - the asm string
   lnk1 - linked list of generic GASMLNKOs of output expressions
   lnk2 - linked list of specific GASMLNKI/SP/DP/As of input expressions
   lnk3 - linked list of generic GASMLNKCs of clobber strings
   NOTE: For now we add ccmod. In the future we may only want to indicate ccmod
   if the user specifies "cc" in the clobber list.

   *Attributes*: other null trm dom
   .CG terminal asm_special ccmod

#. **GASMCNM** sym    *Type*: *sym*

   Used to represent a symbolic name for a gasm constraint
   sym - identifier of constraint name. Stored as an int since we only care
         about the name, not its type.
   sym - constraint number

   *Attributes*: other null trm
   .CG terminal asm_nop

#. **GASMLNKG** nme lnk lnk    *Type*: *sym*

   generic gasmlnk;
   sym - descriptor string
   nme - nme being stored
   lnk1 - input or output expression
   lnk2 - next GASMLNKG

   *Attributes*: other null lnk
   .CG asm_nop

#. **GASMLNKTYP** lnk    *Type*: *stc*

   generic gasmlnk - stores type
   stc - base type of expression
   lnk1 - input or output expression

   *Attributes*: other null lnk
   .CG asm_nop

#. **GASMLNKC** lnk    *Type*: *sym*

   sym - descriptor string
   lnk - next GASMLNKC

   *Attributes*: other null lnk
   .CG asm_nop

#. **GASMLNKO** nme lnk stc    *Type*: *sym*

   sym - descriptor string
   nme - nme being stored
   lnk - next GASMLNKO
   stc - dtype of expression

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKI** nme irlnk lnk    *Type*: *sym*

   Represents Word reg.
   sym - descriptor string
   nme - nme being stored
   irlnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKB** nme irlnk lnk    *Type*: *sym*

   Same as GASMLNKI, but represents byte reg
   sym - descriptor string
   nme - nme being stored
   irlnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKH** nme irlnk lnk    *Type*: *sym*

   Same as GASMLNKI, but represents Half-word reg
   sym - descriptor string
   nme - nme being stored
   irlnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKKR** nme krlnk lnk    *Type*: *sym*

   Same as GASMLNKI, but represents quad word reg
   sym - descriptor string
   nme - nme being stored
   krlnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKSP** nme splnk lnk    *Type*: *sym*

   sym - descriptor string
   nme - nme being stored
   splnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKDP** nme dplnk lnk    *Type*: *sym*

   sym - descriptor string
   nme - nme being stored
   dplnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNK256** nme dplnk lnk    *Type*: *sym*

   __m256
   sym - descriptor string
   nme - nme being stored
   dplnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKQP** nme dplnk lnk    *Type*: *sym*

   __m128
   sym - descriptor string
   nme - nme being stored
   dplnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKA** nme arlnk lnk    *Type*: *sym*

   sym - descriptor string
   nme - nme being stored
   arlnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLNKS** nme arlnk lnk    *Type*: *sym*

   the operand is a struct
   sym - descriptor string
   nme - nme being stored
   arlnk - the input expression
   lnk - next specific GASMLNK

   *Attributes*: other null lnk
   .CG "" asm_nop

#. **GASMLDI** stc nme    *Type*: *stc*

   word register
   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null ir
   .CG asm_nop

#. **GASMLDH** stc nme    *Type*: *stc*

   half word register
   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null ir
   .CG asm_nop

#. **GASMLDB** stc nme    *Type*: *stc*

   byte register
   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null ir
   .CG asm_nop

#. **GASMLDKR** stc nme    *Type*: *stc*

   quad register
   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null kr
   .CG asm_nop

#. **GASMLDSP** stc nme    *Type*: *stc*

   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null sp
   .CG asm_nop

#. **GASMLDDP** stc nme    *Type*: *stc*

   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null dp
   .CG asm_nop

#. **GASMLDQP** stc nme    *Type*: *stc*

   128-bit object (typically used for XMM reg)
   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null dp
   .CG asm_nop

#. **GASMLD256** stc nme    *Type*: *stc*

   256-bit object (typically used for YMM reg)
   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null dp
   .CG asm_nop

#. **GASMLDA** stc nme    *Type*: *stc*

   stc - output argument number, 0..n
   stc - optional field filled in by CG, this is the constaint used.
   nme - nme of object we're loading

   *Attributes*: other null ar
   .CG asm_nop

``FPSAVE``
   Store the frame pointer in the location whose address is specified
   by op1.

   *Attributes*: other null trm dom
   .CG terminal notAILI

``VFENTER``
   Enter a "function" which will compute the value of an expression
   used as a variable format field. op1 locates a temporary area
   used to set up the environment of the expression:
    op1+0 -- contains the fp to use for the expression
    op1+4 -- where to save the current fp
   The code for VFENTER performs the following:
   \1.  save current fp in addr(op1)+4
   \2.  load fp from addr(op1)+0

   *Attributes*: other null trm dom
   .CG terminal asm_special

#. **VFEXIT** irlnk    *Type*: *arlnk*

   Exit the variable format field function.  lnk1 locates the temporary
   area (see VFENTER).  lnk2 is the function return value. The code for
   VFEXIT performs the following:
   \1.  value of lnk2 --> integer function return register
   \2.  restore fp from addr(lnk1)+4
   \3.  return.

   *Attributes*: other null trm dom
   .CG terminal asm_special

#. **PREFETCHNTA** stc nme    *Type*: *arlnk*

   Prefetch cache line.  Non-Temporal Access - prefetch in such a way to
   minimize cache pollution.  Second operand, 'stc' is not used.

   *Attributes*: other null trm ssenme
   .CG terminal "prefetchnta"*direct* lat(20)



#. **PREFETCHT0** stc nme    *Type*: *arlnk*

   Prefetch cache line into all cache levels.

   *Attributes*: other null trm ssenme
   .CG terminal "prefetcht0"*direct* lat(20)



#. **PREFETCHW** stc nme    *Type*: *arlnk*

   Prefetch cache line into L1 data cache.  Used in anticipation to subsequent
   store into the cache line.

   *Attributes*: other null trm ssenme
   .CG terminal "prefetchw"*direct* lat(20)



#. **PREFETCH** stc nme    *Type*: *arlnk*

   Prefetch cache line into L1 data cache.

   *Attributes*: other null trm ssenme
   .CG terminal "prefetch"*direct* lat(20)



#. **BPREFETCHI** irlnk sym    *Type*: *irlnk*

   This ILI immediately precedes a sequence of PREFETCHxx ILIs.  During
   linearisation it is replaced by:
       if ( irlnk1 != irlnk2 ) goto sym
   where 'sym' is a label which immediately follows the last prefetch in
   the sequence (at the position marked by an EPREFETCH ILI).

   *Attributes*: other null trm dom
   .CG notCG terminal

#. **BPREFETCHK** krlnk sym    *Type*: *krlnk*

   This is the same as BPREFETCHI except that the first two operands are
   'krlnk's instead of 'irlnk's.

   *Attributes*: other null trm dom
   .CG notCG terminal

#. **EPREFETCH** sym    *Type*: *sym*

   This ILI immediately follows a sequence of PREFETCHxx ILIs.  'sym1' is
   a label which is the target of the conditional jump from a BPREFETCH
   ILI.  If ( sym2 != sym1 ) then the label 'sym1' is immediately preceded
   by an unconditional jump to 'sym2'.

   *Attributes*: other null trm dom
   .CG terminal asm_special

``LABEL``
   This ILI represents a label 'sym' that is within a basic block.

   *Attributes*: other null trm dom
   .CG terminal asm_special


#. **PSLD** xmm nme    *Type*: *arlnk*

   Load packed real\*4 values from address 'arlnk' into 'xmm'.  'xmm' may
   be an xmm, ymm or zmm register and 'arlnk' must be 16, 32 or 64-byte
   aligned respectively.

   *Attributes*: pload null trm ssenme
   .CG terminal "movaps" move sse_avx*ld* double lat(4)

   *st* double lat(3)

   *double* lat(2)



#. **PDLD** xmm nme    *Type*: *arlnk*

   Load packed real\*8 values from address 'arlnk' into 'xmm'.  'xmm' may
   be an xmm, ymm or zmm register and 'arlnk' must be 16, 32 or 64-byte
   aligned respectively.

   *Attributes*: pload null trm ssenme
   .CG terminal "movapd" move ssedp sse_avx*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PI4LD** xmm nme    *Type*: *arlnk*

   Load packed integer\*4 values from address 'arlnk' into 'xmm'.  'xmm'
   may be an xmm, ymm or zmm register and 'arlnk' must be 16, 32 or
   64-byte aligned respectively.

   *Attributes*: pload null trm ssenme
   .CG terminal "movdqa" move ssedp avx3_special*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PI8LD** xmm nme    *Type*: *arlnk*

   Load packed integer\*8 values from address 'arlnk' into 'xmm'.  'xmm'
   may be an xmm, ymm or zmm register and 'arlnk' must be 16, 32 or
   64-byte aligned respectively.

   *Attributes*: pload null trm ssenme
   .CG terminal "movdqa" move ssedp avx3_special*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PILD** xmm nme    *Type*: *arlnk*

   Load packed integer\*4 or integer\*8 values from address 'arlnk' into
   'xmm'.  'xmm' may be an xmm, ymm or zmm register and 'arlnk' must be
   16, 32 or 64-byte aligned respectively.

   *Attributes*: pload null trm ssenme
   .CG terminal "movdqa" move ssedp sse_avx*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PSLDU** xmm nme    *Type*: *arlnk*

   Load packed real\*4 values from address 'arlnk' into 'xmm'.  'xmm' may
   be an xmm, ymm or zmm register and there are no alignment requirements
   for 'arlnk'.

   *Attributes*: pload null trm ssenme
   .CG terminal "movups" move sse_avx

#. **PDLDU** xmm nme    *Type*: *arlnk*

   Load packed real\*8 values from address 'arlnk' into 'xmm'.  'xmm' may
   be an xmm, ymm or zmm register and there are no alignment requirements
   for 'arlnk'.

   *Attributes*: pload null trm ssenme
   .CG terminal "movupd" move ssedp sse_avx

#. **PI4LDU** xmm nme    *Type*: *arlnk*

   Load packed integer\*4 values from address 'arlnk' into 'xmm'.  'xmm'
   may be an xmm, ymm or zmm register and there are no alignment
   requirements for 'arlnk'.

   *Attributes*: pload null trm ssenme
   .CG terminal "movdqu" move ssedp avx3_special

#. **PI8LDU** xmm nme    *Type*: *arlnk*

   Load packed integer\*8 values from address 'arlnk' into 'xmm'.  'xmm'
   may be an xmm, ymm or zmm register and there are no alignment
   requirements for 'arlnk'.

   *Attributes*: pload null trm ssenme
   .CG terminal "movdqu" move ssedp avx3_special

#. **PILDU** xmm nme    *Type*: *arlnk*

   Load packed integer\*4 or integer\*8 values from address 'arlnk' into
   'xmm'.  'xmm' may be an xmm, ymm or zmm register and there are no
   alignment requirements for 'arlnk'.

   *Attributes*: pload null trm ssenme
   .CG terminal "movdqu" move ssedp sse_avx

#. **PSMASKLD** xmm nme xmm    *Type*: *arlnk*

   Conditionally load packed real\*4 elements from the 16-byte (for xmm)
   or 32-byte (for ymm) memory location whose starting address is given
   by 'arlnk' into the corresponding elements of the destination register
   'xmm1', under the control of a mask in 'xmm2'.  The mask bit for each
   real\*4 element is the most significant bit of that element in the mask
   register 'xmm2'.  If a mask bit is 1 then the corresponding real\*4
   element is copied from memory to 'xmm1', otherwise that element of
   'xmm1' is set to 0.

   *Attributes*: pload null trm ssenme
   .CG terminal "vmaskmovps" avx_only

#. **PDMASKLD** xmm nme xmm    *Type*: *arlnk*

   Conditionally load packed real\*8 elements from the 16-byte (for xmm)
   or 32-byte (for ymm) memory location whose starting address is given
   by 'arlnk' into the corresponding elements of the destination register
   'xmm1', under the control of a mask in 'xmm2'.  The mask bit for each
   real\*8 element is the most significant bit of that element in the mask
   register 'xmm2'.  If a mask bit is 1 then the corresponding real\*8
   element is copied from memory to 'xmm1', otherwise that element of
   'xmm1' is set to 0.

   *Attributes*: pload null trm ssenme
   .CG terminal "vmaskmovpd" ssedp avx_only

#. **PSLD_SCALAR** xmm nme    *Type*: *arlnk*

   Move 4-byte scalar value whose address is indicated by arlnk,
   into least significant word of the 16-byte xmm register indicated by 'xmm'.

   *Attributes*: other null trm ssenme
   .CG terminal "movss" avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



#. **PSLD_LOWH** xmm nme    *Type*: *arlnk*

   Load 2 single precision values to low half of xmm register.
   This opcode and the next are used in combination, in place of "movups"
   due to a Hammer performance penalty for using "movups".

   *Attributes*: other null trm ssenme
   .CG terminal "movlps" avx_special

#. **PSLD_HIGHH** xmm nme    *Type*: *arlnk*

   Load 2 single precision values to high half of xmm register.

   *Attributes*: other null trm ssenme
   .CG terminal "movhps" avx_special

#. **PDLD_LOWH** xmm nme    *Type*: *arlnk*

   Load 8 bytes from memory into low half of xmm register denoted by xmm.

   *Attributes*: other null trm ssenme
   .CG terminal "movlpd" ssedp avx_special*ld* direct fadd fmul fst lat(4)

   *st* direct fst lat(2)



#. **PDLD_HIGHH** xmm nme    *Type*: *arlnk*

   Load 8 bytes from memory into high half of xmm register denoted by xmm.

   *Attributes*: other null trm ssenme
   .CG terminal "movhpd" ssedp avx_special*ld* direct fadd fmul fst lat(4)

   *st* direct fst lat(2)



#. **PI1INSERT** xmm nme stc    *Type*: *arlnk*

   SSE4.1 and AVX instruction to load an integer\*1 value from 'arlnk' and
   insert it into 'xmm' at the byte offset given by 'stc'.

   *Attributes*: other null trm ssenme
   .CG terminal "pinsrb" sse_avx asm_special

#. **PI2INSERT** xmm nme stc    *Type*: *arlnk*

   SSE2 and AVX instruction to load an integer\*2 value from 'arlnk' and
   insert it into 'xmm' at the word offset given by 'stc' (where a 'word'
   is 2 bytes).

   *Attributes*: other null trm ssenme
   .CG terminal "pinsrw" sse_avx asm_special

#. **PI4INSERT** xmm nme stc    *Type*: *arlnk*

   SSE4.1 and AVX instruction to load an integer\*4 value from 'arlnk' and
   insert it into 'xmm' at the dword offset given by 'stc' (where a
   'dword' is 4 bytes).

   *Attributes*: other null trm ssenme
   .CG terminal "pinsrd" sse_avx asm_special

#. **PI8INSERT** xmm nme stc    *Type*: *arlnk*

   SSE4.1 and AVX instruction to load an integer\*8 value from 'arlnk' and
   insert it into 'xmm' at the qword offset given by 'stc' (where a
   'qword' is 8 bytes).  This instruction can only be used on x86-64.

   *Attributes*: other null trm ssenme
   .CG terminal "pinsrq" sse_avx asm_special


#. **PSST** xmm nme    *Type*: *arlnk*

   Store packed real\*4 values from 'xmm' to address 'arlnk'.  'xmm' may
   be an xmm, ymm or zmm register and 'arlnk' must be 16, 32 or 64-byte
   aligned respectively.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movaps" move ssest sse_avx*ld* double lat(4)

   *st* double lat(3)

   *double* lat(2)



#. **PDST** xmm nme    *Type*: *arlnk*

   Store packed real\*8 values from 'xmm' to address 'arlnk'.  'xmm' may
   be an xmm, ymm or zmm register and 'arlnk' must be 16, 32 or 64-byte
   aligned respectively.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movapd" move ssedp ssest sse_avx*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PI4ST** xmm nme    *Type*: *arlnk*

   Store packed integer\*4 values from 'xmm' to address 'arlnk'.  'xmm'
   may be an xmm, ymm or zmm register and 'arlnk' must be 16, 32 or
   64-byte aligned respectively.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movdqa" move ssedp ssest avx3_special*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PI8ST** xmm nme    *Type*: *arlnk*

   Store packed integer\*8 values from 'xmm' to address 'arlnk'.  'xmm'
   may be an xmm, ymm or zmm register and 'arlnk' must be 16, 32 or
   64-byte aligned respectively.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movdqa" move ssedp ssest avx3_special*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PIST** xmm nme    *Type*: *arlnk*

   Store packed integer\*4 or integer\*8 values from 'xmm' to address
   'arlnk'.  'xmm' may be an xmm, ymm or zmm register and 'arlnk' must be
   16, 32 or 64-byte aligned respectively.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movdqa" move ssedp ssest sse_avx*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PSSTU** xmm nme    *Type*: *arlnk*

   Store packed real\*4 values from 'xmm' to address 'arlnk'.  'xmm' may
   be an xmm, ymm or zmm register and there are no alignment requirements
   for 'arlnk'.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movups" move ssest sse_avx

#. **PDSTU** xmm nme    *Type*: *arlnk*

   Store packed real\*8 values from 'xmm' to address 'arlnk'.  'xmm' may
   be an xmm, ymm or zmm register and there are no alignment requirements
   for 'arlnk'.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movupd" move ssedp ssest sse_avx

#. **PI4STU** xmm nme    *Type*: *arlnk*

   Store packed integer\*4 values from 'xmm' to address 'arlnk'.  'xmm'
   may be an xmm, ymm or zmm register and there are no alignment
   requirements for 'arlnk'.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movdqu" move ssedp ssest avx3_special

#. **PI8STU** xmm nme    *Type*: *arlnk*

   Store packed integer\*8 values from 'xmm' to address 'arlnk'.  'xmm'
   may be an xmm, ymm or zmm register and there are no alignment
   requirements for 'arlnk'.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movdqu" move ssedp ssest avx3_special

#. **PISTU** xmm nme    *Type*: *arlnk*

   Store packed integer\*4 or integer\*8 values from 'xmm' to address
   'arlnk'.  'xmm' may be an xmm, ymm or zmm register and there are no
   alignment requirements for 'arlnk'.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movdqu" move ssedp ssest sse_avx

#. **PSMASKST** xmm nme xmm    *Type*: *arlnk*

   Conditionally store packed real\*4 elements from the source register
   'xmm1' into the corresponding elements of the 16-byte (for xmm) or
   32-byte (for ymm) memory location whose starting address is given by
   'arlnk', under the control of a mask in 'xmm2'.  The mask bit for each
   real\*4 element is the most significant bit of that element in the mask
   register 'xmm2'.  If a mask bit is 1 then the corresponding real\*4
   element is copied from 'xmm1' to memory, otherwise that element of
   memory is left unchanged.

   *Attributes*: pstore null trm ssenme
   .CG terminal "vmaskmovps" ssest avx_only

#. **PDMASKST** xmm nme xmm    *Type*: *arlnk*

   Conditionally store packed real\*8 elements from the source register
   'xmm1' into the corresponding elements of the 16-byte (for xmm) or
   32-byte (for ymm) memory location whose starting address is given by
   'arlnk', under the control of a mask in 'xmm2'.  The mask bit for each
   real\*8 element is the most significant bit of that element in the mask
   register 'xmm2'.  If a mask bit is 1 then the corresponding real\*8
   element is copied from 'xmm1' to memory, otherwise that element of
   memory is left unchanged.

   *Attributes*: pstore null trm ssenme
   .CG terminal "vmaskmovpd" ssedp ssest avx_only

#. **PSSTS** xmm nme    *Type*: *arlnk*

   Streaming store.
   Store 16 bytes from xmm register denoted by xmm into aligned memory
   bypassing cache.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movntps" move ssest sse_avx

#. **PSSTS_SCALAR** xmm nme    *Type*: *arlnk*

   Scalar streaming store single precision quantity.

   *Attributes*: other null trm ssenme
   .CG terminal "movntss" move ssest

#. **SSTS_SCALAR** arlnk nme stc    *Type*: *splnk*

   Scalar streaming store single precision quantity.

   *Attributes*: store null trm
   .CG terminal "movntss" move

#. **PDSTS** xmm nme    *Type*: *arlnk*

   Streaming store.
   Store 16 bytes from xmm register denoted by xmm into aligned memory
   bypassing cache.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movntpd" move ssedp ssest sse_avx

#. **PDSTS_SCALAR** xmm nme    *Type*: *arlnk*

   Scalar streaming store double precision quantity.

   *Attributes*: other null trm ssenme
   .CG terminal "movntsd" move ssedp ssest

#. **DSTS_SCALAR** arlnk nme    *Type*: *dplnk*

   Scalar streaming store double precision quantity.

   *Attributes*: store null trm
   .CG terminal "movntsd" move

#. **PISTS** xmm nme    *Type*: *arlnk*

   Streaming store.  Store 16 bytes, 4 or byte integer, from xmm register
   denoted by xmm into aligned memory, bypassing cache.

   *Attributes*: pstore null trm ssenme
   .CG terminal "movntdq" move ssedp ssest sse_avx

#. **PSST_SCALAR** xmm nme    *Type*: *arlnk*

   Store value from xmm register into 4-byte variable.

   *Attributes*: other null trm ssenme
   .CG terminal "movss" move ssest avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



#. **PDST_LOWH** xmm nme    *Type*: *arlnk*

   Store low half of xmm register into 8-byte memory location.

   *Attributes*: other null trm ssenme
   .CG terminal "movsd" move ssedp ssest avx_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **PDST_HIGHH** xmm nme    *Type*: *arlnk*

   Store high half of xmm register into 8-byte memory location.

   *Attributes*: other null trm ssenme
   .CG terminal "movhpd" ssedp ssest avx_special*ld* direct fadd fmul fst lat(4)

   *st* direct fst lat(2)



#. **PSST_LOWH** xmm nme    *Type*: *arlnk*

   Store 2 single precision values from low half of xmm register.
   This opcode and the next are used in combination, in place of "movups"
   due to a Hammer performance penalty for using "movups".

   *Attributes*: other null trm ssenme
   .CG terminal "movlps" ssest avx_special

#. **PSST_HIGHH** xmm nme    *Type*: *arlnk*

   Store 2 single precision values from high half of xmm register.

   *Attributes*: other null trm ssenme
   .CG terminal "movhps" ssest avx_special

``SFENCE``
   X86 sfence instruction used in conjunction with streaming stores.

   *Attributes*: other null trm dom
   .CG terminal "sfence"


#. **PSMOVX** xmm    *Type*: *xmm*

   Move low order 4 byte value of xmm1 into low order 4 bytes of xmm2,
   without disturbing the other 12 bytes of xmm2.

   *Attributes*: other null trm
   .CG terminal "movss" avx_special*ld* double lat(4)

   *st* double lat(3)

   *double* lat(2)



#. **PSMOV** xmm    *Type*: *xmm*

   Copy the packed real\*4 values from 'xmm1' to 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "movaps" move sse_avx*ld* double lat(4)

   *st* double lat(3)

   *double* lat(2)



#. **PDMOV** xmm    *Type*: *xmm*

   Copy the packed real\*8 values from 'xmm1' to 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "movapd" move ssedp sse_avx*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PI4MOV** xmm    *Type*: *xmm*

   Copy the packed integer\*4 values from 'xmm1' to 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "movdqa" move avx3_special*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PI8MOV** xmm    *Type*: *xmm*

   Copy the packed integer\*8 values from 'xmm1' to 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "movdqa" move avx3_special*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **PIMOV** xmm    *Type*: *xmm*

   Copy the packed integer\*4 or integer\*8 values from 'xmm1' to 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "movdqa" move sse_avx*ld* double fadd fmul fst lat(2)

   *st* double fst lat(3)

   *double* fadd fmul lat(2)



#. **MOVSHDUP** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*4 values.  This sets:
       xmm2(3:0) = [ xmm1(3), xmm1(3), xmm1(1), xmm1(1) ]
   where the subscripts refer to real\*4 elements.

   *Attributes*: other null trm
   .CG terminal "movshdup" sse_avx

#. **MOVSLDUP** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*4 values.  This sets:
       xmm2(3:0) = [ xmm1(2), xmm1(2), xmm1(0), xmm1(0) ]
   where the subscripts refer to real\*4 elements.

   *Attributes*: other null trm
   .CG terminal "movsldup" sse_avx

#. **MOVDDUP** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*8 values.  This sets:
       xmm2(1:0) = [ xmm1(0), xmm1(0) ]
   where the subscripts refer to real\*8 elements.

   *Attributes*: other null trm
   .CG terminal "movddup" ssedp sse_avx


#. **PSDFR** xmm    *Type*: *stc*

   Move 16-byte register 'stc' containing result of vector intrinsic function,
   into symbolic register 'xmm'.  'stc' is typically XR_XMM0.

   *Attributes*: other null trm
   .CG terminal "movaps" move sse_avx

#. **PDDFR** xmm    *Type*: *stc*

   Move 16-byte register 'stc' containing result of vector intrinsic function,
   into symbolic register 'xmm'.  'stc' is typically XR_XMM0.

   *Attributes*: other null trm
   .CG terminal "movapd" move ssedp sse_avx


#. **PSMV_LOW** xmm    *Type*: *splnk*

   Copy a real\*4 value into the bottom of an 'xmm' register.

   *Attributes*: other null trm
   .CG terminal "movss" move avx_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



#. **PDMV_LOWH** xmm    *Type*: *dplnk*

   Copy a real\*8 value into the low half of an 'xmm' register.

   *Attributes*: other null trm
   .CG terminal "movlpd" move ssedp avx_special*ld* direct fadd fmul fst lat(4)

   *st* direct fst lat(2)



#. **PDMV_HIGHH** xmm    *Type*: *dplnk*

   Copy a real\*8 value into the high half of an 'xmm' register.  If the
   input operand is a register, the "unpcklpd" instruction is used instead.

   *Attributes*: other null trm
   .CG terminal "movhpd" ssedp avx_special*ld* direct fadd fmul fst lat(4)

   *st* direct fst lat(2)



#. **PDMV_DUP** xmm    *Type*: *dplnk*

   Copy a real\*8 value into both the low and high halves of an 'xmm' register.

   *Attributes*: other null trm
   .CG terminal "movddup" ssedp sse_avx*double* fmul lat(4)



#. **PSCMPLXMV_LOWH** xmm    *Type*: *cslnk*

   Copy a complex\*8 value into the low half of an 'xmm' register.

   *Attributes*: other null trm
   .CG terminal "movlps" move avx_special

#. **PDCMPLXMV** xmm    *Type*: *cdlnk*

   Copy a complex\*16 value into an 'xmm' register.

   *Attributes*: other null trm
   .CG terminal "movupd" move sse_avx

#. **PI4MV_LOW** xmm    *Type*: *irlnk*

   Copy an integer\*4 value into the bottom of an 'xmm' register with zero
   extension to 16 bytes.  E.g. llvect uses this followed by PI4SHUF to
   store 4 copies of an integer\*4 value in an 'xmm' register.  Typically
   this is done in the preheader of a vectorised loop to initialise the
   register for packed integer\*4 operations.

   *Attributes*: other null trm
   .CG terminal "movd" 'l' sse_avx asm_special

#. **PI8MV_LOW** xmm    *Type*: *krlnk*

   Copy an integer\*8 value into the low half of an 'xmm' register with
   zero extension to 16 bytes.  E.g. llvect uses this followed by
   UNPCKLQDQ to store 2 copies of an integer\*8 value in an 'xmm'
   register.  Typically this is done in the preheader of a vectorised
   loop to initialise the register for packed integer\*8 operations.

   *Attributes*: other null trm
   .CG terminal "movd" 'q' sse_avx asm_special


#. **MOVHLPS** xmm    *Type*: *xmm*

   Move high half of sp values from one xmm register into a low half of 2nd
   xmm register.

   *Attributes*: other null trm
   .CG terminal "movhlps" sse_avx

#. **MOVLHPS** xmm    *Type*: *xmm*

   Move low half of sp values from one xmm register into a high half of 2nd
   xmm register.

   *Attributes*: other null trm
   .CG terminal "movlhps" sse_avx

#. **UNPCKLPS** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*4 values.  This sets:
       xmm2(3:0) = [ xmm1(1), xmm2(1), xmm1(0), xmm2(0) ]
   where the subscripts refer to real\*4 elements.

   *Attributes*: other null trm
   .CG terminal "unpcklps" sse_avx

#. **UNPCKHPS** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*4 values.  This sets:
       xmm2(3:0) = [ xmm1(3), xmm2(3), xmm1(2), xmm2(2) ]
   where the subscripts refer to real\*4 elements.

   *Attributes*: other null trm
   .CG terminal "unpckhps" sse_avx

#. **UNPCKLPD** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*8 values.  This sets:
       xmm2(1:0) = [ xmm1(0), xmm2(0) ]
   where the subscripts refer to real\*8 elements.

   *Attributes*: other null trm
   .CG terminal "unpcklpd" ssedp sse_avx

#. **UNPCKHPD** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*8 values.  This sets:
       xmm2(1:0) = [ xmm1(1), xmm2(1) ]
   where the subscripts refer to real\*8 elements.

   *Attributes*: other null trm
   .CG terminal "unpckhpd" ssedp sse_avx

#. **UNPCKLDQ** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed integer\*4 values.  This sets:
       xmm2(3:0) = [ xmm1(1), xmm2(1), xmm1(0), xmm2(0) ]
   where the subscripts refer to integer\*4 elements.  This is only used
   in AILIs on x86-32, where it is generated from a PI8MV_LOW ILI.

   *Attributes*: other null trm
   .CG CGonly terminal "punpckldq" ssedp sse_avx

#. **UNPCKHQDQ** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed integer\*8 values.  This sets:
       xmm2(1:0) = [ xmm1(1), xmm2(1) ]
   where the subscripts refer to integer\*8 elements.  This is only used
   in AILIs on x86-64, where it is generated from a PDFLOATK ILI.

   *Attributes*: other null trm
   .CG CGonly terminal "punpckhqdq" ssedp sse_avx

#. **UNPCKLQDQ** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed integer\*8 values.  This sets:
       xmm2(1:0) = [ xmm1(0), xmm2(0) ]
   where the subscripts refer to integer\*8 elements.

   *Attributes*: other null trm
   .CG terminal "punpcklqdq" ssedp sse_avx

#. **PSSHUF** xmm stc    *Type*: *xmm*

   Shuffle contents of xmm registers.  Used to move value in
   least significant word into the 3 other words of a register:
   xmm1 and xmm2 denote the (same) xmm register, and stc3 is the
   immediate constant 0.

   *Attributes*: other null trm
   .CG terminal "shufps" sse_avx asm_special

#. **PDSHUF** xmm stc    *Type*: *xmm*

   Shuffle contents of xmm registers.  Used to switch 2 d.p. values
   in register.

   *Attributes*: other null trm
   .CG terminal "shufpd" ssedp sse_avx asm_special

#. **PI4SHUF** xmm stc    *Type*: *xmm*

   Shuffle contents of xmm register containing 4-byte integers.

   *Attributes*: other null trm
   .CG terminal "pshufd" sse_avx asm_special


#. **PTEST** xmm    *Type*: *xmm*

   This sets the ZF flag if the bitwise AND of all the bits in the xmm
   register operands is 0, otherwise it clears the ZF flag, and it sets
   the CF flag if the bitwise ANDN of all the bits in the operands is 0,
   otherwise it clears the CF flag.  Due to the latter operation its
   operands are not commutative.  It clears the AF, OF, PF and SF flags.

   *Attributes*: other null ir
   .CG "ptest" ccmod sse_avx asm_special


#. **PI4ADD** xmm nme    *Type*: *arlnk*

   SSE2 packed signed or unsigned integer\*4 addition.

   *Attributes*: other comm trm ssenme
   .CG terminal "paddd" sse_avx

#. **PI4AND** xmm nme    *Type*: *arlnk*

   SSE2 packed bitwise AND.  For pre-AVX512 targets the same instruction
   '[v]pand' is generated for all integer sizes, but for AVX512 the
   letter 'd' is added to the instruction mnemonic to denote integer\*4
   operands and result.

   *Attributes*: other comm trm ssenme
   .CG terminal "pand" avx3_special

#. **PI4ANDN** xmm nme    *Type*: *arlnk*

   SSE2 packed bitwise AND NOT.  For pre-AVX512 targets the same
   instruction '[v]pandn' is generated for all integer sizes, but for
   AVX512 the letter 'd' is added to the instruction mnemonic to denote
   integer\*4 operands and result.

   *Attributes*: other null trm ssenme
   .CG terminal "pandn" avx3_special

#. **PI4MAX** xmm nme    *Type*: *arlnk*

   SSE4.1 packed signed integer\*4 maximum.

   *Attributes*: other comm trm ssenme
   .CG terminal "pmaxsd" sse_avx

#. **PI4MIN** xmm nme    *Type*: *arlnk*

   SSE4.1 packed signed integer\*4 minimum.

   *Attributes*: other comm trm ssenme
   .CG terminal "pminsd" sse_avx

#. **PI4MUL** xmm nme    *Type*: *arlnk*

   SSE4.1 packed signed integer\*4 multiplication, yielding the low half
   of the integer\*8 result.

   *Attributes*: other comm trm ssenme
   .CG terminal "pmulld" sse_avx

#. **PI4OR** xmm nme    *Type*: *arlnk*

   SSE2 packed bitwise OR.  For pre-AVX512 targets the same instruction
   '[v]por' is generated for all integer sizes, but for AVX512 the letter
   'd' is added to the instruction mnemonic to denote integer\*4 operands
   and result.

   *Attributes*: other comm trm ssenme
   .CG terminal "por" avx3_special

#. **PI4SUBR** xmm nme    *Type*: *arlnk*

   SSE2 packed signed or unsigned integer\*4 reverse subtraction.

   *Attributes*: other null trm ssenme
   .CG terminal "psubd" sse_avx

#. **PI4XOR** xmm nme    *Type*: *arlnk*

   SSE2 packed bitwise XOR.  For pre-AVX512 targets the same instruction
   '[v]pxor' is generated for all integer sizes, but for AVX512 the
   letter 'd' is added to the instruction mnemonic to denote integer\*4
   operands and result.

   *Attributes*: other comm trm ssenme
   .CG terminal "pxor" avx3_special


#. **PI4ADDX** xmm    *Type*: *xmm*

   SSE2 packed signed or unsigned integer\*4 addition.

   *Attributes*: other comm trm
   .CG terminal "paddd" sse_avx

#. **PI4ANDX** xmm    *Type*: *xmm*

   SSE2 packed bitwise AND.  For pre-AVX512 targets the same instruction
   '[v]pand' is generated for all integer sizes, but for AVX512 the
   letter 'd' is added to the instruction mnemonic to denote integer\*4
   operands and result.

   *Attributes*: other comm trm
   .CG terminal "pand" avx3_special

#. **PI4ANDNX** xmm    *Type*: *xmm*

   SSE2 packed bitwise AND NOT.  For pre-AVX512 targets the same
   instruction '[v]pandn' is generated for all integer sizes, but for
   AVX512 the letter 'd' is added to the instruction mnemonic to denote
   integer\*4 operands and result.

   *Attributes*: other null trm
   .CG terminal "pandn" avx3_special

#. **PI4MAXX** xmm    *Type*: *xmm*

   SSE4.1 packed signed integer\*4 maximum.

   *Attributes*: other comm trm
   .CG terminal "pmaxsd" sse_avx

#. **PI4MINX** xmm    *Type*: *xmm*

   SSE4.1 packed signed integer\*4 minimum.

   *Attributes*: other comm trm
   .CG terminal "pminsd" sse_avx

#. **PI4MULX** xmm    *Type*: *xmm*

   SSE4.1 packed signed integer\*4 multiplication, yielding the low half
   of the integer\*8 result.

   *Attributes*: other comm trm
   .CG terminal "pmulld" sse_avx

#. **PI4ORX** xmm    *Type*: *xmm*

   SSE2 packed bitwise OR.  For pre-AVX512 targets the same instruction
   '[v]por' is generated for all integer sizes, but for AVX512 the letter
   'd' is added to the instruction mnemonic to denote integer\*4 operands
   and result.

   *Attributes*: other comm trm
   .CG terminal "por" avx3_special

#. **PI4SUBRX** xmm    *Type*: *xmm*

   SSE2 packed signed or unsigned integer\*4 reverse subtraction.

   *Attributes*: other null trm
   .CG terminal "psubd" sse_avx

#. **PI4XORX** xmm    *Type*: *xmm*

   SSE2 packed bitwise XOR.  For pre-AVX512 targets the same instruction
   '[v]pxor' is generated for all integer sizes, but for AVX512 the
   letter 'd' is added to the instruction mnemonic to denote integer\*4
   operands and result.

   *Attributes*: other comm trm
   .CG terminal "pxor" avx3_special


#. **PI8ADD** xmm nme    *Type*: *arlnk*

   SSE2 packed signed or unsigned integer\*8 addition.

   *Attributes*: other comm trm ssenme
   .CG terminal "paddq" sse_avx

#. **PI8AND** xmm nme    *Type*: *arlnk*

   SSE2 packed bitwise AND.  For pre-AVX512 targets the same instruction
   '[v]pand' is generated for all integer sizes, but for AVX512 the
   letter 'q' is added to the instruction mnemonic to denote integer\*8
   operands and result.

   *Attributes*: other comm trm ssenme
   .CG terminal "pand" avx3_special

#. **PI8ANDN** xmm nme    *Type*: *arlnk*

   SSE2 packed bitwise AND NOT.  For pre-AVX512 targets the same
   instruction '[v]pandn' is generated for all integer sizes, but for
   AVX512 the letter 'q' is added to the instruction mnemonic to denote
   integer\*8 operands and result.

   *Attributes*: other null trm ssenme
   .CG terminal "pandn" avx3_special

#. **PI8OR** xmm nme    *Type*: *arlnk*

   SSE2 packed bitwise OR.  For pre-AVX512 targets the same instruction
   '[v]por' is generated for all integer sizes, but for AVX512 the letter
   'q' is added to the instruction mnemonic to denote integer\*8 operands
   and result.

   *Attributes*: other comm trm ssenme
   .CG terminal "por" avx3_special

#. **PI8SUBR** xmm nme    *Type*: *arlnk*

   SSE2 packed signed or unsigned integer\*8 reverse subtraction.

   *Attributes*: other null trm ssenme
   .CG terminal "psubq" sse_avx

#. **PI8XOR** xmm nme    *Type*: *arlnk*

   SSE2 packed bitwise XOR.  For pre-AVX512 targets the same instruction
   '[v]pxor' is generated for all integer sizes, but for AVX512 the
   letter 'q' is added to the instruction mnemonic to denote integer\*8
   operands and result.

   *Attributes*: other comm trm ssenme
   .CG terminal "pxor" avx3_special


#. **PI8ADDX** xmm    *Type*: *xmm*

   SSE2 packed signed or unsigned integer\*8 addition.

   *Attributes*: other comm trm
   .CG terminal "paddq" sse_avx

#. **PI8ANDX** xmm    *Type*: *xmm*

   SSE2 packed bitwise AND.  For pre-AVX512 targets the same instruction
   '[v]pand' is generated for all integer sizes, but for AVX512 the
   letter 'q' is added to the instruction mnemonic to denote integer\*8
   operands and result.

   *Attributes*: other comm trm
   .CG terminal "pand" avx3_special

#. **PI8ANDNX** xmm    *Type*: *xmm*

   SSE2 packed bitwise AND NOT.  For pre-AVX512 targets the same
   instruction '[v]pandn' is generated for all integer sizes, but for
   AVX512 the letter 'q' is added to the instruction mnemonic to denote
   integer\*8 operands and result.

   *Attributes*: other null trm
   .CG terminal "pandn" avx3_special

#. **PI8ORX** xmm    *Type*: *xmm*

   SSE2 packed bitwise OR.  For pre-AVX512 targets the same instruction
   '[v]por' is generated for all integer sizes, but for AVX512 the letter
   'q' is added to the instruction mnemonic to denote integer\*8 operands
   and result.

   *Attributes*: other comm trm
   .CG terminal "por" avx3_special

#. **PI8SUBRX** xmm    *Type*: *xmm*

   SSE2 packed signed or unsigned integer\*8 reverse subtraction.

   *Attributes*: other null trm
   .CG terminal "psubq" sse_avx

#. **PI8XORX** xmm    *Type*: *xmm*

   SSE2 packed bitwise XOR.  For pre-AVX512 targets the same instruction
   '[v]pxor' is generated for all integer sizes, but for AVX512 the
   letter 'q' is added to the instruction mnemonic to denote integer\*8
   operands and result.

   *Attributes*: other comm trm
   .CG terminal "pxor" avx3_special


#. **PI4CMPX** xmm stc    *Type*: *xmm*

   Vector dword integer compare; stc is the compare code;
   one of the instructions pcmpXXd is generated for this ili.

   *Attributes*: other null trm
   .CG terminal sse_avx asm_special

#. **PI8CMPX** xmm stc    *Type*: *xmm*

   Vector qword integer compare; stc is the compare code;
   one of the instructions pcmpXXq is generated for this ili.

   *Attributes*: other null trm
   .CG terminal sse_avx asm_special

#. **PUI4MAXX** xmm    *Type*: *xmm*

   SSE4.1 packed unsigned dword integer maximum.

   *Attributes*: other comm trm
   .CG terminal "pmaxud"

#. **PUI4MINX** xmm    *Type*: *xmm*

   SSE4.1 packed unsigned dword integer minimum.

   *Attributes*: other comm trm
   .CG terminal "pminud"

#. **PUI4MAX** xmm nme    *Type*: *arlnk*

   SSE4.1 packed unsigned dword integer maximum.

   *Attributes*: other comm trm ssenme
   .CG terminal "pmaxud"

#. **PUI4MIN** xmm nme    *Type*: *arlnk*

   SSE4.1 packed unsigned dword integer minimum.

   *Attributes*: other comm trm ssenme
   .CG terminal "pminud"


#. **PSADD** xmm nme    *Type*: *arlnk*

   Perform 4 single-precision floating-point adds of the 4 values
   in the 16-byte aligned memory location denoted by arlnk, and
   the 4 values in the xmm register denoted by xmm.
   The results are placed in xmm register 'xmm'.

   *Attributes*: other comm trm ssenme
   .CG terminal "addps" sse_avx*double* fadd lat(7:5)



#. **PSSUBR** xmm nme    *Type*: *arlnk*

   Reverse subtract: computes 'xmm' - 'arlnk', result placed in the
   xmm register denoted by 'xmm'.

   *Attributes*: other null trm ssenme
   .CG terminal "subps" sse_avx*double* fadd lat(7:5)



#. **PSMUL** xmm nme    *Type*: *arlnk*

   Multiply contents of memory and 16-byte xmm register.

   *Attributes*: other comm trm ssenme
   .CG terminal "mulps" sse_avx*double* fmul lat(7:5)



#. **PSDIVR** xmm nme    *Type*: *arlnk*

   Reverse divide: op2/op1 -> op2.

   *Attributes*: other null trm ssenme
   .CG terminal "divps" sse_avx*double* fmul lat(35:33)



#. **PSAND** xmm nme    *Type*: *arlnk*

   Bitwise AND operation on s.p. values - used to implement absolute value.

   *Attributes*: other comm trm ssenme
   .CG terminal "andps" sse_avx*double* fmul lat(5:3)



#. **PSXOR** xmm nme    *Type*: *arlnk*

   Bitwise XOR operation on s.p. values.

   *Attributes*: other comm trm ssenme
   .CG terminal "xorps" sse_avx*double* fmul lat(5:3)



#. **PSMAX** xmm nme    *Type*: *arlnk*

   Single-precision packed maximum.

   *Attributes*: other comm trm ssenme
   .CG terminal "maxps" sse_avx*double* fadd lat(5:3)



#. **PSMIN** xmm nme    *Type*: *arlnk*

   Single-precison packed minimum.

   *Attributes*: other comm trm ssenme
   .CG terminal "minps" sse_avx*double* fadd lat(5:3)



#. **PSSQRT** xmm nme    *Type*: *arlnk*

   Compute square root of 4 s.p. values in memory and put result into
   xmm register denoted by xmm.

   *Attributes*: other null trm ssenme
   .CG terminal "sqrtps" sse_avx*double* fmul lat(41:39)



#. **RCPPS** xmm nme    *Type*: *arlnk*

   Compute single-precision approximations to reciprocal.

   *Attributes*: other null trm ssenme
   .CG terminal "rcpps" avx3_special*double* fmul lat(41:39)



#. **RSQRTPS** xmm nme    *Type*: *arlnk*

   Compute single-precision approximations to reciprocal square root.

   *Attributes*: other null trm ssenme
   .CG terminal "rsqrtps" avx3_special*double* fmul lat(41:39)



#. **CMPNEQPS** xmm nme    *Type*: *arlnk*

   Used for single-precision sqrt approximation.

   *Attributes*: other null trm ssenme
   .CG terminal "cmpneqps" sse_avx*double* fadd lat(5:3)




#. **HADDPS** xmm    *Type*: *xmm*

   Horizontal add packed single.

   *Attributes*: other null trm
   .CG terminal "haddps" sse_avx

#. **PSADDX** xmm    *Type*: *xmm*

   Perform 4 single-precision floating point additions of the 4
   values in xmm register xmm1 and the 4 values in register xmm2.
   The results are placed in register xmm2.

   *Attributes*: other comm trm
   .CG terminal "addps" sse_avx*double* fadd lat(7:5)



#. **PSADDSUBX** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*4 values.  This subtracts the
   even-index values in 'xmm1' from the corresponding values in 'xmm2',
   and adds the odd-index values in 'xmm1' to the corresponding values in
   'xmm2', placing the result in 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "addsubps" sse_avx*double* fadd lat(5:7)



#. **PSSUBRX** xmm    *Type*: *xmm*

   Reverse-subtract contents of two 16-byte xmm registers.

   *Attributes*: other null trm
   .CG terminal "subps" sse_avx*double* fadd lat(7:5)



#. **PSMULX** xmm    *Type*: *xmm*

   Multiply contents of two 16-byte xmm registers.

   *Attributes*: other comm trm
   .CG terminal "mulps" sse_avx*double* fmul lat(7:5)



#. **PSDIVRX** xmm    *Type*: *xmm*

   Reverse-divide contents of two 16-byte xmm registers.

   *Attributes*: other null trm
   .CG terminal "divps" sse_avx*double* fmul lat(35:33)



#. **PSANDX** xmm    *Type*: *xmm*

   Bitwise AND operation on s.p. values - used to implement absolute value.

   *Attributes*: other comm trm
   .CG terminal "andps" sse_avx*double* fmul lat(5:3)



#. **PSANDNX** xmm    *Type*: *xmm*

   Bitwise ANDNOT operation on s.p. values.

   *Attributes*: other null trm
   .CG terminal "andnps" sse_avx*double* fmul lat(5:3)



#. **PSORX** xmm    *Type*: *xmm*

   Bitwise OR operation on s.p. values.

   *Attributes*: other comm trm
   .CG terminal "orps" sse_avx*double* fadd lat(5:3)



#. **PSXORX** xmm    *Type*: *xmm*

   Compute bitwise exclusive-OR of two xmm registers and place result
   in second register.

   *Attributes*: other comm trm
   .CG terminal "xorps" sse_avx*double* fmul lat(5:3)



#. **PSMAXX** xmm    *Type*: *xmm*

   Single precision packed maximum.

   *Attributes*: other comm trm
   .CG terminal "maxps" sse_avx*double* fadd lat(5:3)



#. **PSMINX** xmm    *Type*: *xmm*

   Single precision packed minimum.

   *Attributes*: other comm trm
   .CG terminal "minps" sse_avx*double* fadd lat(5:3)



#. **PSSQRTX** xmm    *Type*: *xmm*

   Compute square root of 4 s.p. values in 1st xmm register and put result into
   2nd xmm register.

   *Attributes*: other null trm
   .CG terminal "sqrtps" sse_avx*double* fmul lat(41:39)



#. **RCPPSX** xmm    *Type*: *xmm*

   Compute single-precision approximations to reciprocal.

   *Attributes*: other null trm
   .CG terminal "rcpps" avx3_special*double* fmul lat(41:39)



#. **RSQRTPSX** xmm    *Type*: *xmm*

   Compute single-precision approximations to reciprocal square root.

   *Attributes*: other null trm
   .CG terminal "rsqrtps" avx3_special*double* fmul lat(41:39)



#. **CMPNEQPSX** xmm    *Type*: *xmm*

   Used for single-precision square root approximation.

   *Attributes*: other null trm
   .CG terminal "cmpneqps" sse_avx

#. **PSCMPX** xmm stc    *Type*: *xmm*

   Vector compare of single precision values.  'stc' is comparison code.
   One of the instructions cmpXXps is generated for this ili.

   *Attributes*: other null trm
   .CG terminal sse_avx asm_special


#. **PDADD** xmm nme    *Type*: *arlnk*

   Perform 2 double-precision floating-point adds of the 2 values
   in the 16-byte aligned memory location denoted by arlnk, and
   the 2 values in the xmm register denoted by xmm.
   The results are placed in xmm register 'xmm'.

   *Attributes*: other comm trm ssenme
   .CG terminal "addpd" ssedp sse_avx*double* fadd lat(7:5)



#. **PDSUBR** xmm nme    *Type*: *arlnk*

   Reverse subtract: computes 'xmm' - 'arlnk', result placed in the
   xmm register denoted by 'xmm'.

   *Attributes*: other null trm ssenme
   .CG terminal "subpd" ssedp sse_avx*double* fadd lat(7:5)



#. **PDMUL** xmm nme    *Type*: *arlnk*

   Multiply contents of memory and 16-byte xmm register.

   *Attributes*: other comm trm ssenme
   .CG terminal "mulpd" ssedp sse_avx*double* fmul lat(7:5)



#. **PDDIVR** xmm nme    *Type*: *arlnk*

   Reverse divide: op2/op1 -> op2.

   *Attributes*: other null trm ssenme
   .CG terminal "divpd" ssedp sse_avx*double* fmul lat(39:37)



#. **PDAND** xmm nme    *Type*: *arlnk*

   Bitwise AND operation on d.p. values - used to implement absolute value.

   *Attributes*: other comm trm ssenme
   .CG terminal "andpd" ssedp sse_avx*direct* fadd lat(5:3)



#. **PDXOR** xmm nme    *Type*: *arlnk*

   Bitwise XOR operation on d.p. values.

   *Attributes*: other comm trm ssenme
   .CG terminal "xorpd" ssedp sse_avx*double* fmul lat(5:3)



#. **PDMAX** xmm nme    *Type*: *arlnk*

   Double precision packed maximum.

   *Attributes*: other comm trm ssenme
   .CG terminal "maxpd" ssedp sse_avx*direct* fadd lat(5:3)



#. **PDMIN** xmm nme    *Type*: *arlnk*

   Double precision packed minimum.

   *Attributes*: other comm trm ssenme
   .CG terminal "minpd" ssedp sse_avx*direct* fadd lat(5:3)



#. **PDSQRT** xmm nme    *Type*: *arlnk*

   Compute square root of 2 d.p. values in memory and put result into
   xmm register denoted by xmm.

   *Attributes*: other null trm ssenme
   .CG terminal "sqrtpd" ssedp sse_avx*double* fmul lat(53:51)




#. **HADDPD** xmm    *Type*: *xmm*

   Horizontal add packed double.

   *Attributes*: other null trm
   .CG terminal "haddpd" ssedp sse_avx

#. **PDADDX** xmm    *Type*: *xmm*

   Perform 2 double-precision floating point additions of the 2
   values in xmm register xmm1 and the 2 values in register xmm2.
   The results are placed in register xmm2.

   *Attributes*: other comm trm
   .CG terminal "addpd" ssedp sse_avx*double* fadd lat(5:7)



#. **PDADDSUBX** xmm    *Type*: *xmm*

   'xmm1' and 'xmm2' contain packed real\*8 values.  This subtracts the
   even-index values in 'xmm1' from the corresponding values in 'xmm2',
   and adds the odd-index values in 'xmm1' to the corresponding values in
   'xmm2', placing the result in 'xmm2'.

   *Attributes*: other null trm
   .CG terminal "addsubpd" ssedp sse_avx*double* fadd lat(5:7)



#. **PDSUBRX** xmm    *Type*: *xmm*

   Reverse-subtract contents of two 16-byte xmm registers.

   *Attributes*: other null trm
   .CG terminal "subpd" ssedp sse_avx*double* fadd lat(7:5)



#. **PDMULX** xmm    *Type*: *xmm*

   Multiply contents of two 16-byte xmm registers.

   *Attributes*: other comm trm
   .CG terminal "mulpd" ssedp sse_avx*double* fmul lat(7:5)



#. **PDDIVRX** xmm    *Type*: *xmm*

   Reverse-divide contents of two 16-byte xmm registers.

   *Attributes*: other null trm
   .CG terminal "divpd" ssedp sse_avx*double* fmul lat(39:37)



#. **PDANDX** xmm    *Type*: *xmm*

   Bitwise AND operation on d.p. values - used to implement absolute value.

   *Attributes*: other comm trm
   .CG terminal "andpd" ssedp sse_avx*direct* fadd lat(5:3)



#. **PDANDNX** xmm    *Type*: *xmm*

   Bitwise ANDNOT operation on d.p. values.

   *Attributes*: other null trm
   .CG terminal "andnpd" ssedp sse_avx

#. **PDORX** xmm    *Type*: *xmm*

   Bitwise OR operation on d.p. values.

   *Attributes*: other comm trm
   .CG terminal "orpd" ssedp sse_avx

#. **PDXORX** xmm    *Type*: *xmm*

   Compute bitwise exclusive-OR of two xmm registers and place result
   in second register.

   *Attributes*: other comm trm
   .CG terminal "xorpd" ssedp sse_avx*double* fmul lat(5:3)



#. **PDMAXX** xmm    *Type*: *xmm*

   Double precision packed maximum.

   *Attributes*: other comm trm
   .CG terminal "maxpd" ssedp sse_avx*double* fadd lat(5:3)



#. **PDMINX** xmm    *Type*: *xmm*

   Double precision packed minimum.

   *Attributes*: other comm trm
   .CG terminal "minpd" ssedp sse_avx*double* fadd lat(5:3)



#. **PDSQRTX** xmm    *Type*: *xmm*

   Compute square root of 2 d.p. values in 1st xmm register and put result into
   2nd xmm register.

   *Attributes*: other null trm
   .CG terminal "sqrtpd" ssedp sse_avx*double* fmul lat(53:51)



#. **PDCMPX** xmm stc    *Type*: *xmm*

   Vector compare of double precision values.  'stc' is comparison code.
   One of the instructions cmpXXpd is generated for this ili.

   *Attributes*: other null trm
   .CG terminal sse_avx asm_special ssedp


#. **PSLLSH** xmm    *Type*: *irlnk*

   Shift packed 4-byte integers left.

   *Attributes*: other null trm
   .CG terminal "pslld" sse_avx

#. **PSRLSH** xmm    *Type*: *irlnk*

   Shift packed 4-byte integers logical right (zero fill).

   *Attributes*: other null trm
   .CG terminal "psrld" sse_avx

#. **PSRASH** xmm    *Type*: *irlnk*

   Shift packed 4-byte integers arithmetically right (sign extend).

   *Attributes*: other null trm
   .CG terminal "psrad" sse_avx

#. **PDLLSH** xmm    *Type*: *irlnk*

   Shift packed 8-byte integers left.

   *Attributes*: other null trm
   .CG terminal "psllq" ssedp sse_avx

#. **PDRLSH** xmm    *Type*: *irlnk*

   Shift packed 8-byte integers logical right (zero fill).

   *Attributes*: other null trm
   .CG terminal "psrlq" ssedp sse_avx

#. **PDRASH** xmm    *Type*: *irlnk*

   Shift packed 8-byte integers arithmetically right (sign extend).
   NO SUCH INSTRUCTION.

   *Attributes*: other null trm
   .CG notCG terminal "psraq" ssedp


#. **PBBLENDX** xmm xmm    *Type*: *xmm*

   SSE4.1 Variable Blend Packed Bytes

   *Attributes*: other null trm
   .CG terminal "pblendvb" sse_avx asm_special

#. **PDBLENDX** xmm xmm    *Type*: *xmm*

   SSE4.1 Variable Blend Packed Double Precision Floating-Point Values

   *Attributes*: other null trm
   .CG terminal "blendvpd" sse_avx asm_special ssedp

#. **PSBLENDX** xmm xmm    *Type*: *xmm*

   SSE4.1 Variable Blend Packed Single Precision Floating-Point Values

   *Attributes*: other null trm
   .CG terminal "blendvps" sse_avx asm_special

#. **PBBLEND** xmm nme xmm    *Type*: *arlnk*

   SSE4.1 Variable Blend Packed Bytes

   *Attributes*: other null trm ssenme
   .CG terminal "pblendvb" sse_avx asm_special

#. **PDBLEND** xmm nme xmm    *Type*: *arlnk*

   SSE4.1 Variable Blend Packed Double Precision Floating-Point Values

   *Attributes*: other null trm ssenme
   .CG terminal "blendvpd" sse_avx asm_special ssedp

#. **PSBLEND** xmm nme xmm    *Type*: *arlnk*

   SSE4.1 Variable Blend Packed Single Precision Floating-Point Values

   *Attributes*: other null trm ssenme
   .CG terminal "blendvps" sse_avx asm_special


#. **PDBROADCAST** xmm    *Type*: *dplnk*

   An AVX-only ILI which broadcasts a real\*8 value to all 8-byte elements
   of a ymm or zmm register 'xmm'.

   *Attributes*: other null trm
   .CG terminal "vbroadcastsd" ssedp avx_only avx_special

#. **PSBROADCAST** xmm    *Type*: *splnk*

   An AVX-only ILI which broadcasts a real\*4 value to all 4-byte elements
   of an xmm, ymm or zmm register 'xmm'.

   *Attributes*: other null trm
   .CG terminal "vbroadcastss" avx_only avx_special

#. **PCDBROADCAST** xmm    *Type*: *cdlnk*

   An AVX-only ILI which broadcasts a (real\*8, real\*8) complex value to
   all 16-byte elements of a zmm register 'xmm'.

   *Attributes*: other null trm
   .CG terminal "vbroadcastf32x4" ssedp avx_only avx_special

#. **PCSBROADCAST** xmm    *Type*: *cslnk*

   An AVX-only ILI which broadcasts a (real\*4, real\*4) complex value to
   all 8-byte elements of a ymm or zmm register 'xmm'.

   *Attributes*: other null trm
   .CG terminal "vbroadcastsd" avx_only avx_special

#. **PI4BROADCAST** xmm    *Type*: *irlnk*

   An AVX-only ILI which broadcasts an integer\*4 value to all 4-byte
   elements of an xmm, ymm or zmm register 'xmm'.

   *Attributes*: other null trm
   .CG terminal "vpbroadcastd" avx_only avx_special

#. **PI8BROADCAST** xmm    *Type*: *krlnk*

   An AVX-only ILI which broadcasts an integer\*8 value to all 8-byte
   elements of an xmm, ymm or zmm register 'xmm'.

   *Attributes*: other null trm
   .CG terminal "vpbroadcastq" avx_only avx_special

#. **VEXTRACT** xmm nme stc    *Type*: *arlnk*

   An AVX-only ILI.  stc = (suffix_flag | n), where 'suffix_flag' is a
   flag such as SUF_f128 that specifies which 'vextract...' instruction
   to use and 'n' is an integer in the range 0-3.  'xmm' is a ymm or zmm
   source register, and this ILI stores the contents of its n'th 128-bit
   or 256-bit element to the address 'arlnk'.

   *Attributes*: other null trm ssenme
   .CG terminal "vextract" avx_only avx_special

#. **VEXTRACTX** xmm stc    *Type*: *xmm*

   This is the same as VEXTRACT except that the destination is 'xmm2' (an
   xmm or ymm register) rather than the address 'arlnk'.

   *Attributes*: other null trm
   .CG terminal "vextract" avx_only avx_special

#. **VINSERT** xmm nme stc    *Type*: *arlnk*

   An AVX-only ILI.  stc = (suffix_flag | n), where 'suffix_flag' is a
   flag such as SUF_f128 that specifies which 'vinsert...' instruction to
   use and 'n' is an integer in the range 0-3.  This ILI loads 128 or 256
   bits of data from address 'arlnk' to the n'th 128-bit or 256-bit
   element of 'xmm', which is a ymm or zmm register, leaving its other
   element(s) unchanged.

   *Attributes*: other null trm ssenme
   .CG terminal "vinsert" avx_only avx_special

#. **VINSERTX** xmm stc    *Type*: *xmm*

   This is the same as VINSERT except that the source is 'xmm1' (an xmm
   or ymm register) rather than the address 'arlnk'.

   *Attributes*: other null trm
   .CG terminal "vinsert" avx_only avx_special

#. **VEXTRACTF128** xmm nme    *Type*: *arlnk*

   An AVX-only ILI.  Store the high lane of 'xmm' (a ymm register
   containing floating-point data) to the address 'arlnk'.

   *Attributes*: other null trm ssenme
   .CG terminal "vextractf128" avx_only avx_special

#. **VEXTRACTF128X** xmm    *Type*: *xmm*

   An AVX-only ILI.  Copy the high lane of 'xmm1' (a ymm register
   containing floating-point data) to 'xmm2' (an xmm register).

   *Attributes*: other null trm
   .CG terminal "vextractf128" avx_only avx_special

#. **VEXTRACTI128** xmm nme    *Type*: *arlnk*

   An AVX2-only ILI.  Store the high lane of 'xmm' (a ymm register
   containing integer data) to the address 'arlnk'.

   *Attributes*: other null trm ssenme
   .CG terminal "vextracti128" avx_only avx_special

#. **VEXTRACTI128X** xmm    *Type*: *xmm*

   An AVX2-only ILI.  Copy the high lane of 'xmm1' (a ymm register
   containing integer data) to 'xmm2' (an xmm register).

   *Attributes*: other null trm
   .CG terminal "vextracti128" avx_only avx_special

#. **VINSERTF128** xmm nme    *Type*: *arlnk*

   An AVX-only ILI.  Load 128 bits of floating-point data from address
   'arlnk' to the high lane of 'xmm' (a ymm register), leaving its low
   lane unchanged.

   *Attributes*: other null trm ssenme
   .CG terminal "vinsertf128" avx_only avx_special

#. **VINSERTF128X** xmm    *Type*: *xmm*

   An AVX-only ILI.  Copy the contents of 'xmm1' (an xmm register
   containing floating-point data) to the high lane of 'xmm2' (a ymm
   register), leaving its low lane unchanged.

   *Attributes*: other null trm
   .CG terminal "vinsertf128" avx_only avx_special

#. **VINSERTI128** xmm nme    *Type*: *arlnk*

   An AVX2-only ILI.  Load 128 bits of integer data from address 'arlnk' to
   the high lane of 'xmm' (a ymm register), leaving its low lane unchanged.

   *Attributes*: other null trm ssenme
   .CG terminal "vinserti128" avx_only avx_special

#. **VINSERTI128X** xmm    *Type*: *xmm*

   An AVX2-only ILI.  Copy the contents of 'xmm1' (an xmm register
   containing integer data) to the high lane of 'xmm2' (a ymm register),
   leaving its low lane unchanged.

   *Attributes*: other null trm
   .CG terminal "vinserti128" avx_only avx_special


#. **PDFMA** xmm nme xmm    *Type*: *arlnk*

   A packed real\*8 FMA3 or FMA4 instruction which computes:
       dest = <sign> (factor1 \* factor2) <addop> term
   where:
       arlink = factor2 or term
       xmm1   = ((arlnk == factor2) ? term : factor2)
       xmm2   = dest

   Since ILIs have a maximum of 4 operands this ILI is always immediately
   preceded by an FMATYPE ILI which provides other information about the
   FMA instruction, namely (i) flags to specify the values of <sign>
   (+/-) and <addop> (+/-), and whether 'dest' is the same as 'factor1'
   or 'term', and for P[DS]FMA, whether arlnk is 'factor2' or 'term', and
   (ii) the 'factor1' operand.

   Note, for FMA3 'dest' must be the same as either 'factor1' or 'term'.

   *Attributes*: other null trm ssenme
   .CG terminal asm_special ssedp

#. **PDFMAX** xmm xmm xmm    *Type*: *xmm*

   A packed real\*8 FMA3 or FMA4 instruction which computes:
   	dest = <sign> (factor1 \* factor2) <addop> term
   where:
   	xmm1 = factor1
   	xmm2 = factor2
   	xmm3 = term
   	xmm4 = dest

   Since ILIs have a maximum of 4 operands this ILI is always immediately
   preceded by an FMATYPE ILI which specifies the values of <sign> (+/-)
   and <addop> (+/-).

   Note, for FMA3 'dest' must be the same as either 'factor1' or 'term'.

   *Attributes*: other null trm
   .CG terminal asm_special ssedp

#. **PSFMA** xmm nme xmm    *Type*: *arlnk*

   This is the same as PDFMA except that it specifies a packed real\*4
   FMA3 or FMA4 instruction.

   *Attributes*: other null trm ssenme
   .CG terminal asm_special

#. **PSFMAX** xmm xmm xmm    *Type*: *xmm*

   This is the same as PDFMAX except that it specifies a packed real\*4
   FMA3 or FMA4 instruction.

   *Attributes*: other null trm
   .CG terminal asm_special

#. **FMATYPE** xmm    *Type*: *stc*

   This provides extra information about the immediately following
   P[DS]FMA or P[DS]FMAX ILI.  Its operands are:

   stc = a set of flags which specify the values of <sign> (+/-) and
         <addop> (+/-), and whether 'dest' is the same as 'factor1' or
         'term', and for P[DS]FMA, whether arlnk is 'factor2' or 'term'.
         The flags are defined by 'FMA\_...' macros in "ili.h".

   xmm = the 'factor1' operand for P[DS]FMA, or 0 for P[DS]FMAX.

   *Attributes*: other null trm
   .CG terminal notAILI


``CLTD``
   Used with signed integer divide/mod instruction.
   Sign extends %eax into %edx.

   *Attributes*: other null ir
   .CG CGonly "cltd" ccmod asm_special*direct* lat(1)



``CQTO``
   Used with signed integer64 divide/mod instruction.

   *Attributes*: other null kr
   .CG CGonly "cqto" ccmod asm_special*direct* lat(1)



``CLTQ``
   Sign extends register %rax from 32 to 64 bits.  Used in the final peephole
   pass to replace IKMV when possible.

   *Attributes*: other null trm
   .CG CGonly "cltq" ccmod asm_special*direct* lat(1)



``CMOV``
   Conditionally copy op2 into op1 based on condition codes.

   *Attributes*: load null ir
   .CG CGonly asm_special "cmov"*ld* direct lat(4)

   *direct* lat(1)



``CMOVSP``
   Single precision conditional move.  Expanded by the CG.

   *Attributes*: load null sp
   .CG CGonly "movss" sse_avx asm_special*ld* double lat(3)

   *st* direct lat(2)

   *direct* lat(2)



``CMOVDP``
   Double precision conditional move.  Expanded by the CG.

   *Attributes*: load null dp
   .CG CGonly "movsd" sse_avx asm_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``CMOVSCMPLX``
   Single precision complex conditional move.  Expanded by the CG.

   *Attributes*: load null cs
   .CG CGonly "movsd" sse_avx asm_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``CMOVDCMPLX``
   Double precision complex conditional move.  Expanded by the CG.

   *Attributes*: load null cd
   .CG CGonly "movupd" sse_avx asm_special*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



``CMOVLPD``
   Same as CMOVDP, but used when "movlpd" is preferred.

   *Attributes*: load null dp
   .CG CGonly "movlpd" sse_avx asm_special*ld* direct fadd fmul fst lat(4)

   *st* direct fst lat(2)



``CSETB``
   Conditional set of a byte

   *Attributes*: store null ir
   .CG CGonly asm_special "set"*ld* direct lat(4)

   *direct* lat(1)



``INC``
   Increment integer register or memory operand.

   *Attributes*: arth null ir cse
   .CG CGonly ccarith "inc"*direct* lat(1)



``DEC``
   Decrement integer register or memory operand.

   *Attributes*: arth null ir cse
   .CG CGonly ccarith "dec"*direct* lat(1)



#. **LEA** stc    *Type*: *irlnk*

   32-bit load effective address instruction.  This only appears in the
   linear and attributed ILIs, not the shared ILIs.  The LILI is created
   by 'cglinear.c:optimize_imul()', in which case 'irlnk' is used as both
   the base and index register, and 'stc' is the shift count, which may
   be 1, 2, 4 or 8.  The AILI may be generated from a LEA LILI or it may
   be created by a peephole optimisation.

   *Attributes*: arth null ir cse
   .CG CGonly "lea" 'l'*direct* lat(1)



#. **KLEA** stc    *Type*: *krlnk*

   64-bit load effective address instruction.  This is only generated on
   x86-64, and it only appears in the linear and attributed ILIs, not the
   shared ILIs.  It is created by 'cglinear.c:optimize_imul()'.  'krlnk'
   is used as both the base and index register, and 'stc' is the shift
   count, which may be 1, 2, 4 or 8.

   *Attributes*: arth null kr cse
   .CG CGonly "lea" 'q'*direct* lat(1)



``MOV``
   Synonym for LD and ST, and register to register moves.

   *Attributes*: move null ir cse
   .CG CGonly "mov" move*direct* lat(1)

   *ld* direct lat(3)

   *st* direct lat(3)



``MOVABS``
   Used in place of MOV and ACON_STATIC, etc., when a full 64-bit address
   is required.  Used to support the Hammer-64 medium code model.

   *Attributes*: move null ir cse
   .CG CGonly "movabs" move

#. **BIH** stc    *Type*: *stc*

   Created by the code generator to represent, in the linear ili and the AILI,
   the beginning of a basic block.  The first operand is the bih number, and
   the second is the label symbol table pointer, if any.

   *Attributes*: other null trm dom
   .CG CGonly terminal asm_nop

``DEF``
   Placed into the AILI to indicate the definition of a register which is
   otherwise not explicitly defined (by appearing in the 'dest' field of
   some aili).  The register allocators need this information in certain
   cases.

   *Attributes*: other null trm
   .CG CGonly asm_nop

``USE``
   Placed into the AILI to indicate the use of a register which is otherwise
   not explicitly used.  The register allocators need to know this in order
   to avoid a conflicting register allocation, etc.

   *Attributes*: other null trm
   .CG CGonly asm_nop

``STACK_ADJ``
   Placed into the AILI to indicate that the stack pointer has been
   modified by the value specified in the src1 field of the aili.
   No code is generated for this ili.

   *Attributes*: other null trm
   .CG CGonly asm_special

``ALLOC``
   Allocate memory for a C or C++ variable length array.
   'krlnk' is the size.  Result is the address of the allocated memory.

   *Attributes*: arth null ar
   .CG notCG

``DEALLOC``
   Deallocate memory that was allocated by ALLOC.
   'arlnk' is the memory address.

   *Attributes*: other null trm
   .CG notCG

``ALLOCA``
   Allocate memory with alloca
   'krlnk' is the size.  Result is the address of the allocated memory.

   *Attributes*: arth null ar
   .CG notAILI

#. **CFA** nme    *Type*: *arlnk*

   Materialize the outer call frame address as a builtin.  This is
   placed into a load address register from a memory location whose address
   is represented by op1.

   *Attributes*: other null ar cse
   .CG 'l' asm_special

#. **EHRET** nme    *Type*: *arlnk*

   Materialize the return address of the caller as a builtin.  This is
   placed into a load address register from a memory location whose address
   is represented by op1.

   *Attributes*: other null ar cse
   .CG 'l' asm_special

#. **EHREGST** sym    *Type*: *sym*

   Store implicit registers into the syms: catch_clause and caught_object

   *Attributes*: other null trm
   .CG asm_special terminal

#. **EHREGLD** sym    *Type*: *sym*

   Materialize the syms: catch_clause and caught_object into the two symbols
   from implicit registers

   *Attributes*: other null trm
   .CG asm_special terminal

#. **EHRESUME** sym    *Type*: *sym*

   Resume propagation of an existing in-flight exception whose unwinding was
   interrupted to run some cleanup code.

   *Attributes*: other null trm
   .CG asm_special terminal

``ACCEL``
   Start a block of code to be targeted for accelerator.
   Link to list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ENDACCEL``
   End a block of code to be targeted for accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCKERNELS``
   Start a block of kernels to be targeted for accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCENDKERNELS``
   End a block of kernels to be targeted for accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCPAR``
   Start a block of parallel code to be targeted for accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCENDPAR``
   End a block of parallel code to be targeted for accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCSCALARREG``
   Start a block of code to run as a scalar kernel on the accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCENDSCALARREG``
   End a block of code to run as a scalar kernel on the accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCSERIAL``
   Start a block of code to run as a serial kernel on the accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCENDSERIAL``
   End a block of code to run as a serial kernel on the accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

``ACCELLP``
   The following loop is to be targeted for the accelerator.
   Link to a list of clauses.

   *Attributes*: other null trm
   .CG notCG

#. **ACCSLOOP** stc    *Type*: *lnk*

   The following loop in a serial region is to be targeted for the accelerator.
   Link to a list of clauses.
   The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;

   *Attributes*: other null trm
   .CG notCG

#. **ACCKLOOP** stc    *Type*: *lnk*

   The following loop in a kernels region is to be targeted for the accelerator.
   Link to a list of clauses.
   The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;

   *Attributes*: other null trm
   .CG notCG

#. **ACCPLOOP** stc    *Type*: *lnk*

   The following loop in a parallel region is to be targeted for the accelerator.
   Link to a list of clauses.
   The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;

   *Attributes*: other null trm
   .CG notCG

#. **ACCATTACH** lnk lnk sym    *Type*: *lnk*

   Attach the pointer/allocatable member in an aggregate structure data variable

   *Attributes*: other null lnk
   .CG notCG

#. **ACCDETACH** lnk lnk sym    *Type*: *lnk*

   Detach the pointer/allocatable member in an aggregate structure data variable

   *Attributes*: other null lnk
   .CG notCG

#. **ACCCOPY** lnk lnk sym stc    *Type*: *lnk*

   Variable or array will be copied from host to device and back.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCCOPYIN** lnk lnk sym stc    *Type*: *lnk*

   Variable or array will be copied from host to device.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCCOPYOUT** lnk lnk sym stc    *Type*: *lnk*

   Variable or array will be copied from device to host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCLOCAL** lnk lnk sym stc    *Type*: *lnk*

   Variable or array will be allocated on the device but not copied.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCCREATE** lnk lnk sym stc    *Type*: *lnk*

   Variable or array will be allocated on the device but not copied
   to or from the host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCDELETE** lnk lnk sym stc    *Type*: *lnk*

   Variable or array will be deleted from the device but not copied
   to or from the host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCPDELETE** lnk lnk sym stc    *Type*: *lnk*

   Variable or array will be deleted from the device but not copied,
   unless in a data region to or from the host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCPRESENT** lnk lnk sym stc    *Type*: *lnk*

   Variable or array must be present on the device.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCPCOPY** lnk lnk sym stc    *Type*: *lnk*

   Variable or array may be present on the device, but if not will be copied.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCPCOPYIN** lnk lnk sym stc    *Type*: *lnk*

   Variable or array may be present on the device, but if not will be copied in.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCPCOPYOUT** lnk lnk sym stc    *Type*: *lnk*

   Variable or array may be present on the device, but if not will be copied out.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.

   *Attributes*: other null lnk
   Fifth arg is the policy index
   .CG notCG

#. **ACCPCREATE** lnk lnk sym stc    *Type*: *lnk*

   Variable or array may be present on the device, but if not will be allocated,
   but not copied.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCPNOT** lnk lnk sym stc    *Type*: *lnk*

   Variable or array may be present on the device, but if not will NOT be allocated
   nor copied.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCNO_CREATE** lnk lnk sym stc    *Type*: *lnk*

   Variable or array may be present on the device, but if not will NOT be allocated
   nor copied.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCUPDATEHOST** lnk lnk stc    *Type*: *lnk*

   Variable or array will be copied from device back to host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCUPDATESELF** lnk lnk stc    *Type*: *lnk*

   Variable or array will be copied from device back to the current thread.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCUPDATEDEV** lnk lnk stc    *Type*: *lnk*

   Variable or array will be copied from host to device.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCUPDATEHOSTIFP** lnk lnk stc    *Type*: *lnk*

   Variable or array will be copied from device back to host, if present.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCUPDATESELFIFP** lnk lnk stc    *Type*: *lnk*

   Variable or array will be copied from device back to the current thread, if present.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCUPDATEDEVIFP** lnk lnk stc    *Type*: *lnk*

   Variable or array will be copied from host to device, if present.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

``ACCUPDATE``
   Head of a list of update clauses.

   *Attributes*: other null trm
   .CG notCG

``PCASTCOMPARE``
   Head of a list of PCAST compare clauses.

   *Attributes*: other null trm
   .CG notCG

#. **ACCCOMPARE** lnk lnk stc    *Type*: *lnk*

   Variable or array will be copied from device back to host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **PGICOMPARE** lnk lnk stc    *Type*: *lnk*

   Variable or array will be copied from device back to host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCPRIVATE** lnk lnk    *Type*: *lnk*

   Variable or array is private to an iteration of the loop or to a worker.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fourth argument is the symbol that points to the device copy, if there is such
   a symbol.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCFIRSTPRIV** lnk lnk    *Type*: *lnk*

   Variable or array is private to the workers, but initialize with values from the host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCCACHE** lnk lnk    *Type*: *lnk*

   The compiler should move the array to the highest level of the
   software-managed cache.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCDEVICEPTR** lnk lnk sym stc    *Type*: *lnk*

   Variable or array will be copied from device to host.
   First link is to next clause.
   Second link is to the array bounds.
   Third link is to ACCSYMLNK.
   Fifth arg is the policy index

   *Attributes*: other null lnk
   .CG notCG

#. **ACCAUTO** stc    *Type*: *lnk*

   The execution mode will be selected by the compiler (gang/worker/vector/seq)
   First link is to next clause.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCVECTOR** lnk stc    *Type*: *lnk*

   The iterations of the loop will be executed in vector mode on the accelerator
   First link is to next clause.
   Second link is to the vector size expression, or to IL_NULL if not set.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCPARALLEL** lnk stc    *Type*: *lnk*

   The iterations of the loop will be executed in parallel on the accelerator.
   Same as ACCGANG except for the name.
   First argument is the link to the next clause.
   Second argument is the number of gangs.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCGANG** lnk stc stc    *Type*: *lnk*

   The iterations of the loop will be executed in across gangs on the accelerator.
   First argument is the link to the next clause.
   Second argument is the number of gangs.
   Third argument is the device_type argument.
   Fourth argument is the dimension, where the default is dimension zero (cuda X dimension).

   *Attributes*: other null lnk
   .CG notCG

#. **ACCGANGCHUNK** lnk stc    *Type*: *lnk*

   The gang static-scheduling chunk size.
   First argument is the link to the next clause.
   Second argument is the chunk size.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCWORKER** lnk stc    *Type*: *lnk*

   The iterations of the loop will be executed in across workers on the accelerator
   First argument is the link to the next clause.
   Second argument is the number of workers.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCSEQ** lnk stc    *Type*: *lnk*

   The iterations of the loop will be executed sequentially on the accelerator.
   First argument is the link to the next clause.
   Second argument is the block size, if any.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCHOST** lnk stc    *Type*: *lnk*

   The iterations of the loop will be executed on the host.
   First link is the link to the next clause.
   Second link is the block size, if any.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCSHORTLOOP** stc    *Type*: *lnk*

   Trip count is less than the maximum size of a vector operation
   (for vector schedule) or less than the maximum number of
   simultaneously active parallel iterations (for parallel schedule)
   First link is the link to the next clause.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCTILE** lnk stc stc    *Type*: *lnk*

   Tile this loop.
   First link is to the next clause.
   Second link is to a list of ACCSIZE ILI.
   Third argument is the tile depth.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCSIZE** lnk    *Type*: *lnk*

   A size expression.
   The first link is to the next size expression, if any, or to NULL.
   The second link is the expression, if any, or to NULL.

   *Attributes*: other null lnk
   .CG notCG

``ACCINDEPENDENT``
   The iterations of the loop are data-independent.
   Link to the next clause.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCNUMGANGS** lnk stc stc    *Type*: *lnk*

   How many gangs to instantiate.
   First link is the link to the next clause.
   Second argument is the number of gangs.
   Third argument is the device_type argument.
   Fourth argument is the dimension, where the default is dimension zero (cuda X dimension).

   *Attributes*: other null lnk
   .CG notCG

#. **ACCNUMWORKERS** lnk stc    *Type*: *lnk*

   How many workers to instantiate.
   First link is the link to the next clause.
   Second argument is the number of workers.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCVLENGTH** lnk stc    *Type*: *lnk*

   How long a vector to instantiate.
   First link is the link to the next clause.
   Second argument is the vector length expression.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCIF** lnk    *Type*: *lnk*

   Region will execute conditionally on host or accelerator.
   First link is the link to the next clause.
   Second link is the conditional expression.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCDEVID** lnk stc    *Type*: *lnk*

   Device ID of the device to use for this directive or construct.
   First link is the link to the next clause.
   Second link is the device ID expression.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCUNROLL** lnk stc stc    *Type*: *lnk*

   Control loop unrolling; the 3rd element tells whether it's the parallel, vector, or sequential loop to be unrolled
   First link is the link to the next clause.
   Second link is the unroll expression, which must be a constant.
   Third argument is 1 to unroll sequential loop, 2 to unroll parallel/gang loop,
   3 to unroll vector loop, 0 to unroll the original loop.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

``ACCKERNEL``
   Mark this loop as the kernel loop; link to other arguments.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCTRIPLE** lnk lnk lnk    *Type*: *lnk*

   Specify bounds of sub-arrays in accelerator clauses.
   First link to subsequent ACCTRIPLE.
   Second link to lower bound, third to upper bound, last to stride.

   *Attributes*: other null lnk
   .CG notCG

``ACCDATAREG``
   Generate data movement to/from accelerator.
   Link to list of arguments.

   *Attributes*: other null trm
   .CG notCG

``ACCENTERDATA``
   Generate data movement at enter data directive.
   Link to list of arguments.

   *Attributes*: other null trm
   .CG notCG

``ACCEXITDATA``
   Generate data movement at exit data directive.
   Link to list of arguments.

   *Attributes*: other null trm
   .CG notCG

``ACCFINALEXITDATA``
   Generate data movement at exit data directive with finalize clause.
   Link to list of arguments.

   *Attributes*: other null trm
   .CG notCG

``ACCENDDATAREG``
   Generate matching data movement to/from accelerator

   *Attributes*: other null trm
   .CG notCG

#. **ACCPHI** stc stc    *Type*: *lnk*

   PHI operator used in accelerator optimizing code generator.
   Link points to ACCPHILINK, and the 2nd operand is a symbol numbering.
   3rd operand is nonzero for loop header phi

   *Attributes*: other null trm
   .CG notCG notAILI accel

#. **ACCLHPHI** stc    *Type*: *lnk*

   PHI operator for loop headers used in accelerator optimizing code generator.
   Link points to ACCPHILINK, and the 2nd operand is a symbol numbering.

   *Attributes*: other null trm
   .CG notCG notAILI accel

#. **ACCPHILINK** lnk    *Type*: *lnk*

   PHI operator for loop headers used in accelerator optimizing code generator.
   First link is to next PHILINK, 2nd link is the chain to the reaching def.

   *Attributes*: other null lnk
   .CG notCG notAILI accel

``ACCINIT``
   Dummy initial value for factored use-def chains.
   First link is to next PHILINK, 2nd link is the chain to the reaching def.

   *Attributes*: other null trm
   .CG notCG notAILI accel

``ACCVAR``
   Used in accelerator optimizing code generator, a builtin variable ref.

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCLDSYM** stc    *Type*: *stc*

   Used in accelerator optimizing code generator, a load of a temp variable

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCSTSYM** stc stc    *Type*: *lnk*

   Used in accelerator optimizing code generator, a load of a temp variable

   *Attributes*: other null trm
   .CG notCG notAILI accel

#. **ACCIVAL** stc    *Type*: *stc*

   Used in accelerator optimizing code generator, a literal constant;
   uses two operands to hold an ISZ_T value.

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCJSR** lnk    *Type*: *stc*

   Used in accelerator optimizing code generator, special routine call

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCRETURN** lnk    *Type*: *stc*

   Used in accelerator optimizing code generator, return value from a function call
   Short constant holds the return datatype.

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCLOR** lnk    *Type*: *lnk*

   Used in accelerator optimizing code generator, logical OR

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCCAST** stc    *Type*: *lnk*

   Used in accelerator optimizing code generator, type casting

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCJMP** sym    *Type*: *lnk*

   Used in accelerator optimizing code generator, conditional jump
   The 'sym' is a normally an ACBLK index.  During linearization, the 'stc' will
   be a symbol index if positive and an ACBLK index negated if negative, until
   'acc_replace_labels'.

   *Attributes*: branch null trm
   .CG notCG notAILI accel

#. **ACCARG** lnk    *Type*: *lnk*

   Used in accelerator optimizing code generator, argument list

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCBOUND** lnk stc stc    *Type*: *lnk*

   Used in accelerator optimizing code generator, array bounds check.
   Fields are subscript expression, ACCBOUND2, line number, array symbol

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCBOUND2** lnk stc    *Type*: *lnk*

   Used in accelerator optimizing code generator, array bounds check.
   Fields are lower bound, upper bound, subscript number.

   *Attributes*: other null lnk
   .CG notCG notAILI accel

#. **ACCWAIT** stc    *Type*: *lnk*

   Used in accelerator code, wait on the host for each kernel to finish.
   Link to next argument.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG notAILI

``ACCNOWAIT``
   Used in accelerator code, don't wait on the host for each kernel to finish.
   Link to next argument.

   *Attributes*: other null lnk
   .CG notCG notAILI

#. **ACCASYNC** lnk stc    *Type*: *lnk*

   Used in accelerator code, perform this activity asynchronously.
   First link to next argument.
   Second link to async expression.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG notAILI

``ACCWAITDIR``
   Used in accelerator code, wait on the host for async activities to finish.
   Link to list of clauses.

   *Attributes*: other null trm
   .CG notCG notAILI

#. **ACCWAITARG** lnk stc    *Type*: *lnk*

   Used in accelerator code, wait on the host for async activities to finish.
   First link to next argument.
   Second link to async expression.
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG notAILI

#. **ACCLOOP** stc sym    *Type*: *lnk*

   Used in accelerator code, to generate an explicit 'vector' loop.
   The first argument is the trip count, the second is an accelerator symbol number of the loop variable.
   The third argument is the label of the exit branch.

   *Attributes*: branch null trm
   .CG notCG notAILI accel

``ACCENDLOOP``
   Used in accelerator code, to end an explicit 'vector' loop.
   The argument is the label of the top of the loop.

   *Attributes*: branch null trm
   .CG notCG notAILI accel


#. **ARGQP** lnk    *Type*: *dplnk*

   Defines a quad precision memory argument.
   \'dplnk' points to the register value of the argument.
   \'lnk' points to the next ARG ILI.

   *Attributes*: define null lnk
   .CG memarg "movupd" sse_avx*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **ARG256** lnk    *Type*: *dplnk*

   Defines a 256-bit memory argument.
   \'dplnk' points to the register value of the argument.
   \'lnk' points to the next ARG ILI.

   *Attributes*: define null lnk
   .CG memarg "vmovupd" 'y' avx_only*ld* double fadd fmul fst lat(3)

   *st* direct fst lat(2)

   *direct* fadd fmul lat(2)



#. **GENARG** lnk stc stc    *Type*: *lnk*

   Define an argument for a function call.
   The ARG ILIs for all of a function's arguments are linked together.
   \'lnk1' points to the argument.
   \'lnk2' points to the next ARG ILI.
   \'stc1' is the datatype of the argument, if available
   \'stc2' is the NME

   *Attributes*: define null lnk
   .CG notCG

#. **GENARG2** lnk stc stc    *Type*: *lnk*

   Define 2nd argument of an argument pair for a function call.
   This will be linked immediately to the matching GENARG
   The ARG ILIs for all of a function's arguments are linked together.
   \'lnk1' points to the argument.
   \'lnk2' points to the next ARG ILI.
   \'stc1' is the datatype of the argument, if available
   \'stc2' is the NME

   *Attributes*: define null lnk
   .CG notCG

#. **RETURN** stc nme    *Type*: *lnk*

   Define return value from a function.
   \'lnk' points to the return value.
   \'stc' is the datatype of the argument.
   \'nme' is the nme of the argument

   *Attributes*: move null trm
   .CG notCG

``KERNEL``
   Start a nest of loops to be turned into CUDA kernels

   *Attributes*: other null trm
   .CG notCG

``ENDKERNEL``
   End a nest of loops to be turned into CUDA kernels

   *Attributes*: other null trm
   .CG notCG

#. **KERNELBLOCK** lnk stc    *Type*: *lnk*

   Block size for one kernel loop.
   The constant is the loop nest level.

   *Attributes*: other null trm
   .CG notCG

#. **KERNELGRID** lnk stc    *Type*: *lnk*

   Grid size for one kernel loop.
   The constant is the loop nest level.

   *Attributes*: other null trm
   .CG notCG

#. **KERNELNEST** stc    *Type*: *lnk*

   nest depth of kernel loops

   *Attributes*: other null trm
   .CG notCG

#. **KERNELSTREAM** stc    *Type*: *lnk*

   stream argument to CUF kernel

   *Attributes*: other null trm
   .CG notCG

#. **KERNELDEVICE** stc    *Type*: *lnk*

   device argument to CUF kernel

   *Attributes*: other null trm
   .CG notCG

#. **ACCIMPDATAREG** stc    *Type*: *lnk*

   Generate data movement to/from accelerator.
   This is for the implicit data region; the constant is normally zero,
   but is '1' when there is a need for a pgi_cu_init call regardless of
   whether there is any data to move or allocate

   *Attributes*: other null trm
   .CG notCG

``ACCENDIMPDATAREG``
   Generate matching data movement to/from accelerator
   This is for the implicit data region
   The short constant tells how many implicit data regions were generated

   *Attributes*: other null trm
   .CG notCG

#. **ACCMIRROR** lnk lnk sym    *Type*: *lnk*

   Variable or array will be mirrored on the device as on the host

   *Attributes*: other null lnk
   .CG notCG

#. **ACCREFLECT** lnk lnk sym    *Type*: *lnk*

   Variable or array has been reflected on the device as on the host

   *Attributes*: other null lnk
   .CG notCG

#. **ACCREDUCTION** lnk lnk stc    *Type*: *lnk*

   Variable is a reduction variable.  'stc' is the operator.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCCACHEDIR** stc    *Type*: *lnk*

   Accelerator CACHE directive.
   The 'stc' argument is normally zero, but is set to '1' if this is a 'readonly' cache directive.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCCACHEARG** lnk lnk    *Type*: *lnk*

   Accelerator CACHE argument.
   First lnk argument is the link to the next ACCCACHEARG or clause.
   Second is a list of ACCTRIPLE ilis for the array bounds.
   Third is an ACCSYMLNK.

   *Attributes*: other null lnk
   .CG notCG

``ACCHOSTDATA``
   Begin host data region.

   *Attributes*: other null trm
   .CG notCG

``ACCENDHOSTDATA``
   End host data region.

   *Attributes*: other null trm
   .CG notCG

#. **ACCUSEDEVICE** lnk lnk sym    *Type*: *lnk*

   Use the device address of a variable or array.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCUSEDEVICEIFP** lnk lnk sym    *Type*: *lnk*

   Use the device address of a variable or array, if present

   *Attributes*: other null lnk
   .CG notCG

#. **ACCSYMLNK** lnk lnk nme    *Type*: *sym*

   This is used from a link from many other accelerator ILI to
   recover the original symbol as well as a link to the address tree,
   if appropriate.
   Symbol is a symbol pointer.
   The first link is a link to reference the symbol.
   The second link is a link to reference the parent of the symbol, if the symbol was a member.
   The constant value is the NME of the parent, if the symbol was a member.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCCOLLAPSE** stc stc stc    *Type*: *lnk*

   Number of loops associated with the loop construct.
   First link to next argument.
   Second argument is the collapse depth.
   Third argument is set if this is a nontightly nested loop (force)
   Last argument is the device_type argument.

   *Attributes*: other null lnk
   .CG notCG

``ACCDEFNONE``
   Tells the accelerator CG that a default-none clause is in effect.
   The link is to other clauses.

   *Attributes*: other null lnk
   .CG notCG

``ACCDEFPRESENT``
   Tells the accelerator CG that a default-present clause is in effect.
   The link is to other clauses.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCDEVICERES** lnk lnk sym    *Type*: *lnk*

   Variable or array will be resident on the device.

   *Attributes*: other null lnk
   .CG notCG

#. **ACCLINK** lnk lnk sym    *Type*: *lnk*

   A link to the variable or array will be resident on the device.

   *Attributes*: other null lnk
   .CG notCG

``ACCLOOPPRIVATE``
   The symbol must be made implicitly private in the containing loop.

   *Attributes*: other null trm
   .CG notCG

#. **ACCJMPTABLE** lnk stc    *Type*: *lnk*

   Used in the Accelerator CG.
   A jump table.
   The first link is to a linked list of ACCJMPENTRY ACLILI.
   The second link is to the expression used to index the table.
   The 'stc' is an ACBLK index of the default jump target.

   *Attributes*: other null trm
   .CG notCG

#. **ACCJMPENTRY** lnk stc    *Type*: *lnk*

   Used in the Accelerator CG.
   A jump table entry.
   The first link is to the next entry in a linked list of ACCJMPENTRY ACLILI.
   The second link is to an ACCIVAL that contains the value to match for this jump table entry.
   The 'stc' is an ACBLK index of this jump target.

   *Attributes*: other null lnk
   .CG notCG

``VCON``

   *Attributes*: cons null lnk cse vect
   .CG notCG

#. **VLD** nme stc    *Type*: *arlnk*

   For all vector ILI except VCON the last operand is the vector dtype

   *Attributes*: load null lnk vect
   .CG notCG

#. **VLDU** nme stc    *Type*: *arlnk*


   *Attributes*: load null lnk vect
   .CG notCG

#. **VNEG** stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VADD** lnk stc    *Type*: *lnk*


   *Attributes*: arth comm lnk cse vect
   .CG notCG

#. **VSUB** lnk stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VMUL** lnk stc    *Type*: *lnk*


   *Attributes*: arth comm lnk cse vect
   .CG notCG

#. **VDIV** lnk lnk stc    *Type*: *lnk*

   Last lnk is a potential mask

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VDIVZ** lnk lnk stc    *Type*: *lnk*

   Vector divide where divide by zero does not fault.

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VMOD** lnk lnk stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VMODZ** lnk lnk stc    *Type*: *lnk*

   Vector remainder where divide by zero does not fault.

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VCVTV** stc stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect

#. **VCVTS** stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VCVTR** stc stc    *Type*: *lnk*

   Reinterpret the bits of a vector as if they were a different vector type.
   This should always be a no-op at runtime.

   *Attributes*: arth null lnk cse vect

#. **VNOT** stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VAND** lnk stc    *Type*: *lnk*


   *Attributes*: arth comm lnk cse vect
   .CG notCG

#. **VOR** lnk stc    *Type*: *lnk*


   *Attributes*: arth comm lnk cse vect
   .CG notCG

#. **VXOR** lnk stc    *Type*: *lnk*


   *Attributes*: arth comm lnk cse vect
   .CG notCG

#. **VCMPNEQ** lnk stc    *Type*: *lnk*

   Used for single-precision square root approximation.

   *Attributes*: arth comm lnk cse vect
   .CG notCG

#. **VLSHIFTV** lnk stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VRSHIFTV** lnk stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VLSHIFTS** lnk stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VRSHIFTS** lnk stc    *Type*: *lnk*


   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VURSHIFTS** lnk stc    *Type*: *lnk*

   Vector unsigned (logical) right shift by a scalar

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VMIN** lnk stc    *Type*: *lnk*

   Vector minimum

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VMAX** lnk stc    *Type*: *lnk*

   Vector maximum

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VABS** stc    *Type*: *lnk*

   Vector absolute value

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VSQRT** lnk stc    *Type*: *lnk*

   Vector square root

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VCOS** lnk stc    *Type*: *lnk*

   Vector cosine - final link is potential mask as it is
   for all the math intrinsic calls (will be IL_NULL if no mask)

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VSIN** lnk stc    *Type*: *lnk*

   Vector sine

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VSINCOS** lnk stc    *Type*: *lnk*

   Vector sine-cosine

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VASIN** lnk stc    *Type*: *lnk*

   Vector arc sine

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VACOS** lnk stc    *Type*: *lnk*

   Vector arc cosine

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VATAN** lnk stc    *Type*: *lnk*

   Vector arctangent

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VATAN2** lnk lnk stc    *Type*: *lnk*

   Vector arctangent2

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VTAN** lnk stc    *Type*: *lnk*

   Vector tangent

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VSINH** lnk stc    *Type*: *lnk*

   Vector hyperbolic sine

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VCOSH** lnk stc    *Type*: *lnk*

   Vector hyperbolic cosine

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VTANH** lnk stc    *Type*: *lnk*

   Vector hyperbolic tangent

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VEXP** lnk stc    *Type*: *lnk*

   Vector natural exponential

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VLOG** lnk stc    *Type*: *lnk*

   Vector natural logarithm

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VLOG10** lnk stc    *Type*: *lnk*

   Vector logarithm base 10

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VPOW** lnk lnk stc    *Type*: *lnk*

   Vector pow float lnk

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VPOWI** lnk lnk stc    *Type*: *lnk*

   Vector pow float to integer

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VPOWK** lnk lnk stc    *Type*: *lnk*

   Vector pow double to integer\*8

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VPOWIS** lnk lnk stc    *Type*: *lnk*

   Vector pow float to scalar integer

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VPOWKS** lnk lnk stc    *Type*: *lnk*

   Vector pow double to scalar integer\*8

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VFPOWK** lnk lnk stc    *Type*: *lnk*

   Vector pow float to integer\*8

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VFPOWKS** lnk lnk stc    *Type*: *lnk*

   Vector pow float to scalar integer\*8

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VDPOWI** lnk lnk stc    *Type*: *lnk*

   Vector pow double to integer

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VDPOWIS** lnk lnk stc    *Type*: *lnk*

   Vector pow double to scalar integer

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VRSQRT** lnk stc    *Type*: *lnk*

   Vector reciprocal square root

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VFLOOR** lnk stc    *Type*: *lnk*

   Vector floor

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VCEIL** lnk stc    *Type*: *lnk*

   Vector ceiling

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VAINT** lnk stc    *Type*: *lnk*

   Vector truncation

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VRCP** lnk stc    *Type*: *lnk*

   Vector reciprocal

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VST** arlnk nme stc    *Type*: *lnk*


   *Attributes*: store null trm vect
   .CG terminal notCG

#. **VSTU** arlnk nme stc    *Type*: *lnk*


   *Attributes*: store null trm vect
   .CG terminal notCG

#. **VFMA1** lnk lnk stc    *Type*: *lnk*

   Vector FMA for LLVM intrinsic - lnk1\*lnk2+lnk3, with stc the dtype

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VFMA2** lnk lnk stc    *Type*: *lnk*

   Vector FMA for LLVM intrinsic - lnk1\*lnk2-lnk3, with stc the dtype

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VFMA3** lnk lnk stc    *Type*: *lnk*

   Vector FMA for LLVM intrinsic - -lnk1\*lnk2+lnk3, with stc the dtype

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VFMA4** lnk lnk stc    *Type*: *lnk*

   Vector FMA for LLVM intrinsic - -lnk1\*lnk2-lnk3, with stc the dtype

   *Attributes*: arth null lnk cse vect
   .CG notCG

#. **VPERMUTE** lnk lnk stc    *Type*: *lnk*

   Shuffle contents of vector registers. lnk1 and lnk2 can be the same vector
   or lnk2 can be null. lnk1 dtype is used as dtype for both lnk1 and lnk2,
   unless lnk2 is null. stc is the result dtype, lnk3 is a vector constant
   representing a mask where each field represents which L-to-R element of
   concatenated <lnk1,lnk2> vector is to be placed in corresponding result
   field. lnk3 size must match the size of the result vector, but can be
   different than lnk1 and lnk2's size.

   *Attributes*: other null lnk vect
   .CG notCG

#. **VBLEND** lnk lnk stc    *Type*: *lnk*

   Vector blend/select of lnk2 & lnk3. lnk1 is the mask, stc is the dtype

   *Attributes*: other null lnk cse vect
   .CG notCG

#. **VCMP** lnk lnk stc    *Type*: *stc*

   Vector compare of lnk1 & lnk2. stc1 is the condition code, stc2 is the dtype

   *Attributes*: arth null lnk cse vect
   .CG notCG

``X87CON``
   x87 80-bit extended precision floating-point constant.

   *Attributes*: cons null x87 cse


#. **X87LD** nme stc    *Type*: *arlnk*

   Load integer or floating-point data into the X87 FPU from memory.
   'stc' is a MSZ\_... memory size/type code.

   *Attributes*: load null x87
   .CG asm_special

#. **X87ST** arlnk nme stc    *Type*: *x87lnk*

   Store, possibly with conversion, data from the X87 FPU to memory.
   'stc' is a MSZ\_... memory size/type code.

   *Attributes*: store null trm
   .CG asm_special terminal

``X87ABS``
   x87 80-bit extended precision absolute value.

   *Attributes*: arth null x87 cse
   .CG "fabs"

``X87CHS``
   x87 80-bit extended precision negation.

   *Attributes*: arth null x87 cse
   .CG "fchs"

``X87RNDINT``
   x87 80-bit extended precision round to integer with current rounding mode.

   *Attributes*: arth null x87 cse
   .CG "frndint"

#. **X87ADD** x87lnk    *Type*: *x87lnk*

   x87 80-bit extended precision floating-point addition.

   *Attributes*: arth comm x87 cse
   .CG "fadd" asm_special

#. **X87SUB** x87lnk    *Type*: *x87lnk*

   x87 80-bit extended precision floating-point subtraction.

   *Attributes*: arth null x87 cse
   .CG "fsub" asm_special

#. **X87MUL** x87lnk    *Type*: *x87lnk*

   x87 80-bit extended precision multiply.

   *Attributes*: arth comm x87 cse
   .CG "fmul" asm_special

#. **X87DIV** x87lnk    *Type*: *x87lnk*

   x87 80-bit extended precision divide.

   *Attributes*: arth null x87 cse
   .CG "fdiv" asm_special

#. **X87CMP** x87lnk stc    *Type*: *x87lnk*

   x87 80-bit extended precision comparison.

   *Attributes*: arth null ir cse
   .CG "fucomi" asm_special ccmod

#. **X87CMOV** x87lnk x87lnk    *Type*: *irlnk*

   Select op2 if X87CMP test in op1 is satisfied, else op3.

   *Attributes*: other null x87 cse
   .CG "fcmov" asm_special

#. **X87ARG** lnk    *Type*: *x87lnk*

   Defines an x87 80-bit extended precision value to be passed as an
   argument to a function call via memory.
   \'x87lnk' points to the value of the argument.
   \'lnk' points to the next ARG ILI.

   *Attributes*: define null lnk
   .CG memarg "fstpt"

``X87TOINT``
   Convert an x87 80-bit extended precision value to a signed integer
   Used by LLVM only.

   *Attributes*: arth null ir cse
   .CG notCG

``X87TOUINT``
   Convert an x87 80-bit extended precision value to an unsigned integer
   Used by LLVM only.

   *Attributes*: arth null ir cse
   .CG notCG

``X87TOKINT``
   Convert an x87 80-bit extended precision value to a long long integer
   Used by LLVM only.

   *Attributes*: arth null kr cse
   .CG notCG

``X87TOUKINT``
   Convert an x87 80-bit extended precision value to an unsigned long long integer
   Used by LLVM only.

   *Attributes*: arth null kr cse
   .CG notCG

``X87TOSP``
   Convert an x87 80-bit extended precision value single precision
   Used by LLVM only.

   *Attributes*: arth null sp cse
   .CG notCG

``X87TODP``
   Convert an x87 80-bit extended precision value to double precision
   Used by LLVM only.

   *Attributes*: arth null dp cse
   .CG notCG

``X87FROMINT``
   Convert a signed integer to an  x87 80-bit extended precision value
   Used by LLVM only.

   *Attributes*: arth null x87 cse
   .CG notCG

``X87FROMUINT``
   Convert an unsigned integer to an x87 80-bit extended precision value
   Used by LLVM only.

   *Attributes*: arth null x87 cse
   .CG notCG

``X87FROMKINT``
   Convert a long long to an  x87 80-bit extended precision value
   Used by LLVM only.

   *Attributes*: arth null x87 cse
   .CG notCG

``X87FROMUKINT``
   Convert an unsigned long long to an x87 80-bit extended precision value
   Used by LLVM only.

   *Attributes*: arth null x87 cse
   .CG notCG

``X87FROMSP``
   Convert a float to an x87 80-bit extended precision value
   Used by LLVM only.

   *Attributes*: arth null x87 cse
   .CG notCG

``X87FROMDP``
   Convert a double to an x87 80-bit extended precision value
   Used by LLVM only.

   *Attributes*: arth null x87 cse
   .CG notCG

#. **X87RETURN** stc    *Type*: *x87lnk*

   Define a x87 80-bit extended precision real function result.
   Appears twice for complex-valued function results, in which case the
   imaginary part is returned first so that the real part is returned on
   top of the stack.

   *Attributes*: define null trm
   .CG terminal asm_nop

#. **X87RESULT** stc    *Type*: *lnk*

   Acquire the x87 80-bit extended precision result of a function call.
   Appears twice for complex-valued function calls, in which case the first
   acquires the real part and the second acquires the imaginary part.

   *Attributes*: define null x87 dom
   .CG terminal asm_nop

``X87FREE``

   *Attributes*: other null trm
   .CG terminal notAILI

``X87CSE``

   *Attributes*: arth null x87
   .CG notCG

``X87XCH``
   Exchanges the top of the x87 floating-point register stack with another entry.

   *Attributes*: define null x87
   .CG CGonly "fxch"

``X87POP``
   Pops an entry from the x87 floating-point register stack.

   *Attributes*: define null x87
   .CG CGonly "fstp" asm_special

``X87DUP``
   Duplicates an entry on the x87 floating-point register stack.

   *Attributes*: define null x87
   .CG CGonly "fld" asm_special

#. **BCONCUR** lnk    *Type*: *sym*

   Start auto parallel region of an outlined function sym.

   *Attributes*: other null trm
   .CG notCG

``ECONCUR``
   End auto parallel region of an outlined function sym.

   *Attributes*: other null trm
   .CG notCG

#. **HFADD** hplnk    *Type*: *hplnk*

   Half-precision floating-point addition.

   *Attributes*: arth comm hp cse
   .CG notCG

``HFNEG``
   Half-precision negation.

   *Attributes*: arth null hp cse
   .CG notCG

#. **HFSUB** hplnk    *Type*: *hplnk*

   Half-precision floating-point subtraction.

   *Attributes*: arth null hp cse
   .CG notCG

#. **HFMUL** hplnk    *Type*: *hplnk*

   Half-precision floating-point multiply.

   *Attributes*: arth comm hp cse
   .CG notCG

#. **HFDIV** hplnk    *Type*: *hplnk*

   Half-precision divide.

   *Attributes*: arth null hp cse
   .CG notCG

#. **HFCMP** hplnk stc    *Type*: *hplnk*

   Half float compare with result of true or false.

   *Attributes*: arth null ir cse
   .CG notCG

#. **HFCMPZ** stc    *Type*: *hplnk*

   Half float compare with zero; result is TRUE or FALSE.

   *Attributes*: arth null ir cse
   .CG notCG

#. **DFRHP** hp    *Type*: *lnk*

   Define half precision function result.

   *Attributes*: define null hp cse
   .CG terminal asm_nop

``HFCON``
   Half-precision floating-point constant.

   *Attributes*: cons null hp cse
   .CG notCG

#. **LDHP** nme stc    *Type*: *arlnk*

   Load half-precision floating value.  'stc' is not used.

   *Attributes*: load null hp
   .CG notCG

``HP2SP``
   Half precison to single precision conversion.

   *Attributes*: arth null sp
   .CG notCG

``SP2HP``
   Single precison to half precision conversion.

   *Attributes*: arth null hp
   .CG notCG

``DP2HP``
   Double precison to half precision conversion.

   *Attributes*: arth null hp
   .CG notCG

#. **STHP** arlnk nme stc    *Type*: *hplnk*

   Store half precision quantity.  'stc' must be MSZ_F2.

   *Attributes*: store null trm
   .CG notCG

#. **ARGHP** lnk    *Type*: *hplnk*

   Defines a half-precision memory argument.
   \'hplnk' points to the register value of the argument.
   \'lnk' points to the next ARG ILI.

   *Attributes*: define null lnk
   .CG notCG

``CSEHP``
   Half precision register cse.

   *Attributes*: arth null hp
   .CG notCG

#. **HFCJMP** hplnk stc sym    *Type*: *hplnk*

   Half precision compare and jump to the label 'sym'
   if the condition, denoted by stc, is true.

   *Attributes*: branch null trm dom
   .CG terminal conditional_branch notAILI

#. **HFCJMPZ** stc sym    *Type*: *hplnk*

   Half precision compare with zero and branch to label 'sym'.

   *Attributes*: branch null trm dom
   .CG notCG conditional_branch

#. **MVHP** ir    *Type*: *hplnk*

   Move half FP value into specific integer register, ir.

   *Attributes*: move null trm
   .CG terminal notAILI 'l'

#. **HFMAX** hplnk    *Type*: *hplnk*

   Half-precision max

   *Attributes*: arth comm hp cse
   .CG notCG

#. **HFMIN** hplnk    *Type*: *hplnk*

   Half-precision min

   *Attributes*: arth comm hp cse
   .CG notCG
   .so ilitp_atomic.n

``MFENCE``
   x86 MFENCE instruction.

   *Attributes*: other null trm fence
   .CG CGonly terminal "mfence"

``X86XCHG``
   x86 XCHG instruction. Used only in AILI, and only with memory operand as destination.
   Always immediately followed by a DEF instruction that defines
   the same register as the source operand of the XCHG.

   *Attributes*: other null ir
   .CG CGonly "xchg"

``X86XADD``
   x86 XADD instruction. Use and constraints are same as for XCHG.

   *Attributes*: other null ir
   .CG CGonly "xadd"

``X86CMPXCHG``
   x86 CMPXCHG instruction. Used only in AILI, and only with memory operand as destination.
   Always immediately followed by a DEF instruction that defines
   the same register as the second source operand (comparand),
   which must be one of AL, AX, EAX, RAX.

   *Attributes*: other null ir
   .CG CGonly "cmpxchg" ccmod
